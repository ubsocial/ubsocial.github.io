<!doctype html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" href="../icons/logoTit.png">
    <link rel="stylesheet" href="../estilo.css">
    <title>UB Social</title>
</head>
<body>
<div class="container-fluid">


    <div class="row">
        <div class="col-sm-12">
            <nav class="navbar rounded-bottom fixed-top navbar-expand-lg navbar-light bg-light shadow">
                <div class="container-fluid">
                    <a class="navbar-brand" href="../index.html"><img src="../icons/logo.png" class="d-inline-block align-text-top" width="11pt"> UB Social</a>
                    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
                    <div class="collapse navbar-collapse" id="navbarNav">
                        <ul class="navbar-nav">
                            <li class="nav-item"><a class="nav-link" href="../index.html">Home</a></li>
                            <li class="nav-item"><a class="nav-link" href="../sobre/sobre.html">Sobre</a></li>
                            <li class="nav-item"><a class="nav-link" href="../cursos.html">Cursos</a></li>
                            <li class="nav-item"><a class="nav-link" href="../livros/livros.html">Livros</a></li>
                        </ul>
                    </div>
                </div>
            </nav>
        </div>
    </div>

    <div class="row">
        <div class="col-sm-12 text-center" id="titulo">
            <h1>Computação Quântica</h1>
            <h6>Conceito, princípios e aplicações</h6>
            <a href="../index.html" class="btn btn-link text-decoration-none mb-3">Voltar</a>
        </div>

        <div class="col-sm-12">
            <p class="text-warning text-center">RESUMO EM CONSTRUÇÃO</p>
            <h4>Material complementar:</h4>
            <ul>
                <li>Conteúdo no YouTube: <a class="text-decoration-none">Acesse em breve</a></li>
                <li>Conteúdo no GitHub: <a href="https://github.com/mateusschwede/computacao_quantica" target="_blank" class="text-decoration-none">Acesse</a></li>
                <li>Curso gratuito com certificado na Workover Academy: <a class="text-decoration-none">Acesse em breve</a></li>
            </ul>

            <br><h4>Conceito:</h4>
            <ul>
                <li><b>Computação clássica</b>: baseada na física clássica (arquitetura de Von Neumann), onde processador (CPU) opera com bits 0 (desligado, sem eletricidade) ou 1 (ligado, com eletricidade);
                    <ul>
                        <li>Processamento sequencial: 1 item por vez (ex: explorará cada caminho do labirinto, por vez, até encontrar solução otimizada).</li>
                    </ul>
                </li>
                <li><b>Computação quântica</b>: baseada na física quântica (mecânica quântica - partícula quantum), onde processador (QPU) opera com partículas subatômicas qubits (bit quântico - qbit - qubit topológico) 0, 1 ou ambos simultaneamente resultante de superposição de estados, onde partículas podem existir em múltiplos estados simultaneamente (Gato de Schrödinger). Entrelaçamento quântico permite que qubits atuem de ambas formas simultaneamente (ser inverso ao outro qubit. Sendo 0, será 1 ao mesmo tempo, independentemente da distância entre ambos - ação fantasmagórica à distância, Einstein). NISQ (Noisy Intermediate-Scale Quantum), descreve era atual de computadores quânticos, com dezenas a centenas de qubits suscetíveis a ruído. Com 300 qubits, computador quântico poderia representar mais estados do que nº de átomos no universo observável.
                    <ul>
                        <li>Qubit: descrito por vetor de estado em sistema quântico de 2 níveis, o qual é matematicamente equivalente a vetor em espaço vetorial complexo de 2 dimensões, conhecido como espaço de Hilbert, via notação bra-ket de Paul Dirac;</li>
                        <li>Processamento paralelo: itens processados simultaneamente (ex: explorará todos caminhos do labirinto simultaneamente até encontrar solução otimizada instantaneamente);</li>
                        <li>Resfriamento dos elétrons (-273,5°C) os mantém aproximadamente emaranhados (emaranhamento quântico), diminuindo agitação térmica, formando pares (pares de Cooper) que saltam de um lado a outro no circuito, formando qubit supercondutor;</li>
                        <li>Supercondutividade: fios supercondutores transportam elétrons sem resistência, eliminando perdas de energia, possibilitando circuitos quânticos (circuitos com capacitores e junções Josephson). Teletransporte quântico é processo pelo qual estado quântico exato de qubit é transferido de local para outro, sem mover sua partícula física;</li>
                        <li>Portas lógicas quânticas: operam em qubits, permitindo manipulação de estados quânticos de qubits para processamento. Porta Hadamard (H) cria superposição, porta CNOT (controlled-NOT) gera entrelaçamento, porta Z (fase). Porta NOT Quântica (Pauli-X), no caso clássico, troca 1 por 0 e vice-versa. Generalização para caso quântico é dada por operador X que satisfaz X |0⟩=|1⟩ e X|1⟩=|0⟩;</li>
                        <li>Interferência quântica: ondas de qubits podem interferir entre si, gerando respostas em padrões de interferência de probabilidade aumentada a encontrar partícula (interferência construtiva) ou padrões de interferência de probabilidade diminuída/nula a encontrar partícula (interferência destrutiva);</li>
                        <li>Decoerência: processo onde sistema em estado quântico colapsa/perde para estado não quântico, ocasionado intencionalmente, ou por fatores ambientais;</li>
                        <li>Correção de erro quântico (QEC): técnica para manter qubits estáveis e confiáveis, codificando dados de qubit lógico (ideal) em muitos qubits físicos (reais e ruidosos);</li>
                        <li>Pontos quânticos ("átomos artificiais"): pequeno semicondutor capaz de capturar elétron único e usá-lo em Spin do elétron, ou carga confinada, como qubit. Qubits de pontos quânticos podem ser manipulados com uso de campos magnéticos. São altamente escaláveis e compatíveis com tecnologias de semicondutores atuais.</li>
                    </ul>
                </li>
            </ul>

            <br><h4>Necessidade da computação quântica:</h4>
            <p id="textoPost">Chips compõem-se bilhões de transistores (semicondutores microscópicos que controlam fluxo de elétrons binários - não passa energia é 0, passa energia é 1). Em 1975, Gordon Moore, cofundador da Intel, observou que quantidade de transistores em chip de circuito integrado dobra aproximadamente a cada 2 anos (Lei de Moore), resultando chips menores e mais rápidos. Atualmente, transistores de silício chegaram à escala de nanômetros, com dimensões próximas ao tamanho de átomos individuais (miniaturização extrema). Ocasionará problemas físicos em túnel quântico (tunelamento quântico - elétrons começam atravessar barreiras microscópicas, causando vazamentos de corrente), aquecimento (quanto mais transistores, mais calor, limitando desempenho), custo e energia. Computação clássica está chegando ao limite físico do silício (espaço físico para encolher e acelerar chips está fisicamente lotado - problema do caixeiro-viajante). Moore prevê tal limite em meados de 2025.</p>

            <br><h4>Hardware de suporte:</h4>
            <p id="textoPost">Chip de processamento quântico é minúsculo (muitas vezes menor que moeda), mas necessita de grande sistema de suporte para funcionamento íntegro, pois qubits são extremamente sensíveis (qualquer calor, luz, som ou vibração pode destruir o estado quântico). Planos que compõem hardware quântico:</p>
            <ol>
                <li>Plano de dados quânticos (área de hospedagem): essência do computador quântico, inclui qubits físicos e estruturas necessárias para mantê-los no lugar;</li>
                <li>Plano de controle e medição (método de transferência): converte sinais digitais em analógicos ou de controle de ondas. Esses sinais analógicos executam operações nos qubits do plano de dados quânticos;</li>
                <li>Plano de processador de controle e processador host (computação para controle): plano de processador de controle implementa algoritmo quântico ou sequência de operações. Processador host interage com software quântico e fornece sinal digital ou sequência de bits clássicos para plano de controle e medição. Geralmente computador clássico é usado para suportar hardware quântico.</li>
            </ol>
            <ul>
                <li>Blindagem térmica: isola chip de variações de temperatura, garantindo estabilidade do estado quântico. Resfriamento criogênico mantém chip a temperaturas próximas de -273,15°C (zero absoluto), garantindo estado de supercondutividade;</li>
                <li>Blindagem eletromagnética: protege chip de interferências externas, garantindo operação estável, evitando feixes eletromagnéticos indesejados. Ímãs supercondutores mantém estado da matéria estável, com elétrons emaranhados e controláveis;</li>
                <li>Proteção contra luz: materiais especiais bloqueiam feixes de luz visível, evitando interferência de agitação no estado quântico dos qubits;</li>
                <li>Isolamento vibracional e acústico: combina técnicas de isolamento para proteger chip de vibrações e ruídos indesejados;</li>
                <li>Proteção contra radiação: barreiras especiais protegem chip de radiações ionizantes, evitando decoerência;</li>
                <li>Vácuo e gaiolas ópticas: eliminam partículas do ar que poderiam causar decoerência (perda do estado quântico);</li>
                <li>Tecnologia fotônica: utiliza fótons (partículas de luz) como qubits fotônicos, alinhados e controlados por lasers, permitindo transmissão de dados quânticos (comunicação quântica). Chave quântica (QKD - Quantum Key Distribution) é transmitida via impulsão de laser por fótons (transporte via fibra óptica ou espaço livre) e, se interceptada, a própria luz denuncia tentativa de espionagem e dados são desmaterializados, tornando-a impossível de ser copiada sem detecção;</li>
                <li>Tecnologia de íons aprisionados (trapped ions - armadilhas de íons - IonQ): átomos neutros/frios (armadilhas de átomos neutros - neutral atom trap) carregados (íons) são presos em gaiola de luz para resfriamento e manipulados com lasers. Cada íon aquecido representa 1 qubit;</li>
                <li>Centros de Vacância em Diamante (NV Centers): defeito específico na estrutura cristalina do diamante, onde átomo de carbono é substituído por nitrogênio ao lado de lacuna (vacância), pode funcionar como qubit. Spin eletrônico do centro NV pode ser manipulado com micro-ondas e lido opticamente, e pode operar à temperatura ambiente, embora escalabilidade seja desafio.</li>
            </ul>

            <br><h4>Circuitos quânticos:</h4>
            <p id="textoPost">Sequência de portas quânticas usadas em cálculo.</p>
            <ol>
                <li>Entrada: qubits de entrada são preparados em estado inicial, geralmente '|0⟩' para cada qubit. Estado conjunto de múltiplos qubits é descrito matematicamente pelo que é chamado de seu produto tensorial;</li>
                <li>Linhas horizontais: cada linha representa evolução temporal de único qubit. Elas não são necessariamente fios físicos, podendo ser apenas passagem do tempo para íon aprisionado ou deslocamento espacial de fóton;</li>
                <li>Sentido: circuito é lido da esquerda para direita, descrevendo evolução do sistema quântico no tempo;</li>
                <li>Portas quânticas: blocos nas linhas representam portas quânticas, que são operações unitárias aplicadas aos qubits;</li>
                <li>Linhas verticais: segmento vertical conectando múltiplas linhas de qubits, como em uma porta CNOT, informa que porta atua simultaneamente nesses qubits. Linha vertical representa sincronismo da operação, e não o envio de informação;</li>
                <li>Controle: em porta controlada (como CNOT), um ponto sólido (●) em linha indica que qubit representado nessa linha é qubit de controle. Caso esteja no estado '|1⟩', porta realiza operação no qubit alvo; caso esteja no estado '|0⟩', porta não realiza operação alguma. Caso qubit de controle seja estado superposto ou ambos qubits estejam emaranhados, não é possível compreender comportamento individual do qubit de controle e do qubit alvo. Deve-se considerar ação do operador unitário, que representa todo circuito, atuando simultaneamente no estado conjunto dos qubits;</li>
                <li>Saída: no final do circuito, qubits que compõem saída podem ser medidos. Medição colapsa superposição de cada qubit para resultado clássico (0 ou 1).</li>
            </ol>

            <br><h4>Cotidiano com computação quântica:</h4>
            <p id="textoPost">Computação quântica complementará coexistência a computação clássica (integração híbrida), pois dispositivos computacionais ainda utilizam demais componentes de interpretação binária clássica. Computação quântica é utilizada em longos processamentos de dados, como descriptografia, pesquisas científicas, simulações moleculares, IAs avançadas, etc. Criptografia pós-quântica (PQC), novos algoritmos clássicos resistentes a ataques quânticos e clássicos, são desenvolvidos como resposta à ameaça da computação quântica. Distribuição quântica de chaves (QKD) é baseada em princípios quânticos para comunicação inviolável. Protocolo BB84 permite criar chave secreta entre 2 partes. Tentativas de espionagem alteram estados quânticos e são detectadas. Problemas de otimização em finanças e engenharia, onde computação quântica, via algoritmos QAOA ou recozimento quântico, pode encontrar soluções melhores e mais rápidas para problema do caixeiro-viajante, roteamento de veículos, e otimização de cadeias de suprimentos.</p>
            <ul>
                <li>Supremacia quântica (quantum supremacy): ponto em que computador quântico executa tarefa impossível para computador clássico em tempo viável;</li>
                <li>Utilidade quântica (quantum utility): cotidiano atual, em que computadores quânticos já executam tarefas úteis, ainda que sem superar métodos clássicos em todos casos;</li>
                <li>Vantagem quântica prática (practical quantum advantage): estágio futuro esperado, onde desempenho e custo-benefício superarão efetivamente métodos clássicos em aplicações reais.</li>
            </ul>

            <br><h4>Recozimento quântico:</h4>
            <p id="textoPost">Método alternativo ao modelo de portas, usado para resolver problemas de otimização e amostragem. Busca estado de energia mínima de sistema físico representando problema. Qubits evoluem de superposição inicial para configuração final, usando tunelamento quântico para atravessar barreiras de energia e evitar ótimos locais, aumentando chance de alcançar solução global. Aplicações incluem otimização combinatória, finanças, rotas e machine learning. Problema da não linearidade, na aprendizagem clássica, ocorre quando métodos lineares não captam relações complexas. No ML quântico, embora operações sejam lineares, feature maps introduzem não linearidades eficazes. Circuitos variacionais (VQC) com portas parametrizadas aprendem funções altamente não lineares, semelhantes a redes neurais profundas.</p>

            <br><h4>Processadores de átomos de Rydberg:</h4>
            <p id="textoPost">Átomo de Rydberg corresponde a átomo excitado que possui, em média, 1 ou mais elétrons distantes do núcleo. Átomos de Rydberg têm várias propriedades peculiares, incluindo resposta exagerada a campos elétricos e magnéticos, bem como vida longa. Quando usados como qubits, oferecem interações atômicas fortes e controláveis ajustáveis ao selecionar diferentes estados.</p>

            <br><h4>Processadores baseados em ressonância magnética nuclear (RMN):</h4>
            <p id="textoPost">Dado quântico armazenado nos spins nucleares dos átomos em moléculas, e portas lógicas manipulam essa informação via radiação eletromagnética. Pósitron ou elétron podem ter spin 'para cima', 'para baixo', ou ambos simultaneamente, representando estados do qubit. Momentos magnéticos nucleares fazem movimento natural de precessão na presença de campos magnéticos. Estados quânticos dos núcleos podem ser manipulados irradiando núcleos com pulsos de rádio frequência sintonizados na frequência de precessão dos mesmos.</p>

            <br><h4>Pilares dos algoritmos quânticos:</h4>
            <ul>
                <li>Transformada quântica de Fourier (QFT): versão quântica da Transformada Discreta de Fourier (DFT), base do algoritmo de Shor, que transforma amplitudes em espaço de frequências com ganho exponencial;</li>
                <li>Amplificação de amplitude: aumenta probabilidade do estado solução. Usada no algoritmo de Grover, aplicando rotações iterativas no vetor de estado;</li>
                <li>Interferência quântica: cancela estados incorretos (interferência destrutiva) e reforça corretos (construtiva), sendo base da eficiência quântica;</li>
                <li>Simulação hamiltoniana: simula sistemas quânticos via portas lógicas, mapeando Hamiltoniana (operador matemático que descreve energia total de sistema quântico) do sistema físico. Origem em Feynman;</li>
                <li>Princípio da incerteza: resultados são probabilísticos, requerindo múltiplas execuções e análise estatística para inferir solução.</li>
            </ul>

            <br><h4>Algoritmos quânticos:</h4>
            <ul>
                <li>Algoritmo de Shor (Peter Shor - 1994): resolve fatoração de nºs inteiros em tempo polinomial. Usa Transformada Quântica de Fourier para encontrar período de função. Permite deduzir fatores primos de N. Ameaça criptografia de chave pública baseada em fatoração, como RSA (Rivest - Shamir - Adleman);</li>
                <li>Algoritmo de Grover (Lov Grover - 1996): aceleração quadrática em busca não estruturada. Reduz tempo de busca de O(N) para O(√N). Aplicável a problemas de otimização e busca geral;</li>
                <li>Algoritmo Adiabático e Computação Quântica Adiabática (adiabatic quantum computing): baseado no teorema adiabático da física, onde sistema inicia no estado fundamental e evolui lentamente, mantendo-o. Usado em computadores quânticos adiabáticos como D-Wave, e voltado para problemas de otimização, como rotas logísticas. Processo envolve Hamiltoniana inicial simples evoluída para final complexa, em que estado final representa solução do problema. Computação adiabática é polinomialmente equivalente ao modelo de circuito, mas com aplicações distintas;</li>
                <li>Algoritmo HHL (Harrow, Hassidim e Lloyd): resolve sistemas de equações lineares e oferece aceleração exponencial em situações com aplicações potenciais em diversas áreas da ciência e engenharia;</li>
                <li>Algoritmos de simulação quântica: simulam sistemas quânticos complexos, como interações moleculares e materiais novos. Utilizam portas lógicas para modelar dinâmica quântica;</li>
                <li>Algoritmos de otimização quântica: resolvem problemas de otimização combinatória, como problema do caixeiro-viajante. Exemplos incluem QAOA (Quantum Approximate Optimization Algorithm) e VQE (Variational Quantum Eigensolver);</li>
                <li>Algoritmos de aprendizado de máquina quântica (QML): exploram paralelismo quântico para acelerar tarefas de aprendizado de máquina (Machine Learning), como classificação e clustering. Exemplos incluem QSVM (Quantum Support Vector Machine) e QNN (Quantum Neural Networks);</li>
                <li>Algoritmos de criptografia quântica: utilizam princípios quânticos para comunicação segura. Exemplo é QKD (Quantum Key Distribution), que permite troca segura de chaves criptográficas, detectando qualquer tentativa de interceptação;</li>
                <li>Algoritmos híbridos quântico-clássicos: combinam computação quântica e clássica para resolver problemas complexos. Exemplos incluem VQE e QAOA, onde parte do processamento é feito em computador clássico e parte em computador quântico;</li>
                <li>Algoritmos de otimização quântica baseados em annealing quântico: utilizam processos de resfriamento para encontrar soluções aproximadas para problemas de otimização. Exemplos incluem Quantum Annealing e algoritmos implementados em computadores quânticos adiabáticos;</li>
                <li>Algoritmos de simulação de materiais quânticos: modelam propriedades de materiais em nível quântico, permitindo estudo de novos materiais com propriedades desejadas. Exemplos incluem simulações de moléculas e materiais usando técnicas como VQE;</li>
                <li>Algoritmos de busca quântica em grafos: exploram estruturas de grafos para resolver problemas de busca e otimização. Exemplos incluem algoritmos baseados em caminhada quântica;</li>
                <li>Algoritmos de fatoração quântica além de Shor: exploram variações e melhorias no algoritmo de Shor para fatoração de nºs inteiros, visando maior eficiência e robustez;</li>
                <li>Algoritmos de simulação quântica de sistemas físicos: modelam sistemas físicos complexos, como dinâmica de partículas e interações quânticas, utilizando técnicas avançadas de simulação;</li>
                <li>Algoritmos de otimização quântica para logística e planejamento: aplicam computação quântica para resolver problemas práticos em logística, como roteirização e alocação de recursos;</li>
                <li>Algoritmos de aprendizado profundo quântico: combinam redes neurais profundas (Deep Learning Neural Networks) com computação quântica para melhorar desempenho em tarefas complexas de aprendizado de máquina;</li>
                <li>Algoritmos de criptografia pós-quântica: desenvolvem métodos criptográficos resistentes a ataques de computadores quânticos, garantindo segurança futura na comunicação;</li>
                <li>Algoritmos de simulação quântica para química computacional: modelam reações químicas e propriedades moleculares, facilitando descobertas em química e farmacologia;</li>
                <li>Algoritmos de otimização quântica para finanças: aplicam computação quântica para resolver problemas financeiros, como otimização de portfólios e precificação de derivativos;</li>
                <li>Algoritmos de aprendizado de máquina quântica para análise de dados: utilizam computação quântica para acelerar análise de grandes volumes de dados (Big Data), melhorando eficiência em tarefas como mineração de dados (Data Mining) e análise preditiva (Predictive Analytics).</li>
            </ul>

            <br><h4>Medições quânticas:</h4>
            <p id="textoPost">Ato de transformar possibilidade (superposição) em realidade (0 ou 1). Qubits estão constantemente em superposição (probabilidades % de estar em 0 à 1), e tornam-se definidos (0 ou 1) após medição. Exemplo, em superposição, um qubit pode estar 70% em 0 e 30% em 1, mas após medição será 0 ou 1.</p>
            <ul>
                <li>Computação clássica: bit possui estado definido (0 ou 1, contendo 2 combinações distintas). 2 bits combinados, formam-se 4 combinações distintas (00, 01, 10 e 11). n bits = 2ⁿ estados distintos;
                    <ul>
                        <li>1 bit: 2 estados possíveis (1 por vez);</li>
                        <li>2 bits: 4 estados possíveis (1 por vez);</li>
                        <li>3 bits: 8 estados possíveis (1 por vez).</li>
                    </ul>
                </li>
                <li>Computação quântica: qubit possui estado indefinido (superposição, contendo 2 combinações simultâneas, cada uma com respectiva probabilidade - combinação linear de estados básicos sob coeficientes de probabilidades para estados possíveis de 0 e 1). 2 qubits combinados, formam-se superposição de 4 combinações simultaneamente (00, 01, 10 e 11). n qubits = 2ⁿ estados simultaneamente.
                    <ul>
                        <li>1 qubit: 2 estados possíveis (2 simultaneamente (percentuais de cada));</li>
                        <li>2 qubits: 4 estados possíveis (4 simultaneamente (percentuais de cada));</li>
                        <li>3 qubits: 8 estados possíveis (8 simultaneamente (percentuais de cada)).</li>
                    </ul>
                </li>
            </ul>
            <p>Esparçador Pauli (Sparse Pauli) adventa matrizes de Pauli, onde são aplicadas 3 matrizes X, Y e Z em, além de I (identidade I), em um qubit, para medir seu estado.</p>
            <ul>
                <li>X = inverte qubit (como inverter 0/1)</li>
                <li>Z = muda fase (como mudar a "cor" invisível do estado)</li>
                <li>Y = combinação de X e Z</li>
                <li>I = não faz nada</li>
            </ul>
            <p id="textoPost">Em 3 qubits, operação X ⊗ Z ⊗ I (ou "XZI" - Pauli String, sequência de Paulis) aplica X no qubit 1, Z no qubit 2, e I (nada) no qubit 3. SparsePauliOp (Sparse Pauli Operator) é forma compacta (esparsa) de guardar combinações sem ocupar tanta memória. Estado quântico é "como sistema está", SparsePauli é "tipo de óculos com que você observa". Você escolhe "conjunto de lentes" (matrizes Pauli) para olhar seu sistema e obter informações (medições). Pauli noise (ruído de Pauli) é um modelo de ruído quântico que descreve erros aleatórios aplicados a qubits usando matrizes de Pauli (X, Y, Z). Usadas para simular imperfeições reais nas transformações de qubits, em computadores quânticos. X-error inverte estado (Bit-flip noise), Z-error muda fase (Phase-flip noise), e Y-error combina erros X e Z (inversão + mudança de fase, Bit-phase-flip noise). Depolarizing noise destaca forma simétrica de Pauli noise na aplicação de X, Y ou Z com mesma probabilidade.</p>

            <br><h4>Benchmarks quânticos:</h4>
            <p id="textoPost">Avaliam desempenho e utilidade dos computadores quânticos, sem implicar vantagem comprovada sobre métodos clássicos. Fidelidade de camada mede capacidade geral do processador em executar circuitos, revelando detalhes sobre qubits, portas e interferências. CLOPS (operações de camada de circuito por segundo) mede velocidade de execução de circuitos de volume quântico, combinando desempenho quântico e clássico. Ambas permitem comparar sistemas e acompanhar ganhos de performance. Profundidade do circuito indica quantas operações paralelas podem ser executadas antes da decoerência, determinando complexidade dos circuitos possíveis.</p>

            <br><h4>Linguagens de programação:</h4>
            <p id="textoPost">Linguagens utilizadas especificamente para processamento quântico. Ambientes disponíveis para desenvolvimento são IBM Quantum Experience, Azure Quantum, Google Quantum AI e AWS Braket. Plataformas IBM Quantum Platform, Azure Quantum, Google Quantum AI e AWS Braket oferecem ferramentas e recursos para desenvolvimento quântico.</p>
            <ul>
                <li>Qiskit: principal stack de software da IBM para computação quântica, indo além do desenvolvimento de circuitos. Inclui SDK, middleware e serviços para escrever, otimizar e executar programas em sistemas IBM Quantum, com novas ferramentas de IA generativa para assistência de código;</li>
                <li>Q#: linguagem quântica desenvolvida pela Microsoft, baseada no C#, voltada para desenvolvimento de algoritmos quânticos, controlando comportamento dos qubits e explorando superposição e entrelaçamento quântico. Exemplo abaixo cria par de Bell (estado de entrelaçamento quântico entre 2 qubits):
<small><pre><code>
open Microsoft.Quantum.Intrinsic; // Importa operações quânticas básicas
open Microsoft.Quantum.Measurement; // Importa operações de medição
open Microsoft.Quantum.Canon; // Importa operações canônicas

operation CreateBellPair() : (Result, Result) &#123;
    use qubits = Qubit[2]; // Aloca array de 2 qubits
    
    H(qubits[0]); // Aplica porta quântica Hadamard no 1º qubit (superposição)
    CNOT(qubits[0], qubits[1]); // Aplica porta quântica CNOT (Controlled-NOT, entrelaçamento)

    let result1 = M(qubits[0]); // Mede 1º qubit
    let result2 = M(qubits[1]); // Mede 2º qubit

    Reset(qubits[0]); // Reseta 1º qubit
    Reset(qubits[1]); // Reseta 2º qubit

    return (result1, result2); // Retorna resultados das medições (sempre iguais, exemplo, ambos 0 ou ambos 1)
&#125;
</code></pre></small>
                </li>
            </ul>

            <br><h4>Qiskit</h4>
            <ol>
                <li>Instalação:
<small><pre><code>
pip3 install qiskit qiskit-ibm-runtime matplotlib qiskit[visualization] jupyter
</code></pre></small>
                </li>
                <li>Conexão:
<small><pre><code>
from qiskit_ibm_runtime import QiskitRuntimeService

QiskitRuntimeService.save_account(
    channel="ibm_quantum_platform",
    token="SEU-TOKEN-IBM-QUANTUM-AQUI",
    overwrite=True
) # Usar apenas 1 vez para salvar conta

service = QiskitRuntimeService() # Usar para conectar conta em cada script
print("Conta conectada com sucesso!")
</code></pre></small>
                </li>
            </ol>

            <br><hr><h4>Exemplos práticos (Qiskit 2.2, em notebooks Python):</h4>
            <ol>
                <li>OBS: Preparação do ambiente (antes de executar os exemplos):
<small><pre><code>
# Instalar runtime (via terminal): pip3 install qiskit qiskit-ibm-runtime matplotlib qiskit[visualization] jupyter

# Conexão com IBM Quantum (única vez no ambiente):
from qiskit_ibm_runtime import QiskitRuntimeService
QiskitRuntimeService.save_account(token="SEU-TOKEN-IBM-QUANTUM-AQUI")
</code></pre></small>
                </li>
                <li>Estado Bell (par de entrelaçamento quântico):
<small><pre><code>
from qiskit import QuantumCircuit
from qiskit.quantum_info import SparsePauliOp
from qiskit.transpiler import generate_preset_pass_manager
from qiskit_ibm_runtime import EstimatorV2 as Estimator, QiskitRuntimeService
service = QiskitRuntimeService() # Conecta conta IBM Quantum, utilizar em cada script

qc = QuantumCircuit(2) # Cria circuito quântico com 2 qubits
qc.h(0) # Aplica porta Hadamard no qubit 0 (superposição)
qc.cx(0, 1) # Aplica porta CNOT (CX) com qubit 0 controlando qubit 1 (entrelaçamento)
qc.measure_all() # Mede todos qubits
qc.draw("mpl") # Desenha circuito
print(qc)
</code></pre></small>
                </li>
                <li>Estado GHZ (Greenberger–Horne–Zeilinger, estado de entrelaçamento quântico entre 3 ou mais qubits): circuito GHZ cria estado quântico onde 3 qubits ficam perfeitamente entrelaçados, onde todos estejam ao mesmo tempo em |000⟩ e |111⟩, compartilhando única correlação global que não pode ser separada entre eles
<small><pre><code>
from qiskit import QuantumCircuit
from qiskit_ibm_runtime import QiskitRuntimeService
service = QiskitRuntimeService() # Conectar conta IBM Quantum

from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere, plot_bloch_multivector
import matplotlib.pyplot as plt
from qiskit_ibm_runtime import QiskitRuntimeService
service = QiskitRuntimeService()

ghz = QuantumCircuit(3) # Circuito com 3 qubits

ghz.h(0) # Hadamard (colocar qubit 0 em superposição)
ghz.cx(0, 1) # CNOT (entrelaçar qubit 0 com qubit 1)
ghz.cx(0, 2) # CNOT (entrelaçar qubit 0 com qubit 2)

print("Circuito GHZ (desenho em texto):")
print(ghz.draw("text")) # Qubits entrelaçados em estado GHZ

state_ghz = Statevector.from_instruction(ghz) # Vetor de estado do circuito GHZ
print("Vetor de estado GHZ resultante:")
print(state_ghz)

# Visualização QSphere — mostra amplitudes e fases
fig = plot_state_qsphere(state_ghz)
fig.figure.savefig("ghz_qsphere.png")
plt.imshow(fig.figure.canvas.renderer.buffer_rgba())
plt.show() # Estados com diferentes pesos/amplitudes em lados opostos da esfera, mas com mesma fase em coerência quântica (superposição coerente) e fase relativa zero entre eles

# Visualização nos vetores de Bloch dos qubits individuais
fig = plot_bloch_multivector(state_ghz)
fig.figure.savefig("ghz_bloch.png")
plt.imshow(fig.figure.canvas.renderer.buffer_rgba())
plt.show() # Cada qubit individualmente está em estado misto (completamente indefinido), mas sistema global está em estado puro GHZ entrelaçado
</code></pre></small>
                </li>
                <li>Estado W (w state, estado de entrelaçamento quântico robusto entre 3 qubits): diferente do GHZ, estado W preserva entrelaçamento mesmo se qubit for perdido, sendo mais robusto
<small><pre><code>
from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere, plot_bloch_multivector
import matplotlib.pyplot as plt
import math
import numpy as np
from qiskit_ibm_runtime import QiskitRuntimeService
service = QiskitRuntimeService()

w_vec = np.array([0, 1, 1, 0, 1, 0, 0, 0], dtype=complex) / math.sqrt(3) # Vetor de estado W de 3 qubits, onde |001&gt;, |010&gt;, |100&gt; têm amplitude 1/√3

w = QuantumCircuit(3, name="W_state") # Circuito de 3 qubits em estado W
w.initialize(w_vec, [0, 1, 2]) # Inicializa 3 qubits no vetor w_vec

print("Circuito W (desenho em texto):")
print(w.draw("text"))

print("Circuito W (desenho em Matplotlib):")
fig = w.draw("mpl")
fig.savefig("w_circuit.png")
plt.imshow(fig.canvas.renderer.buffer_rgba())
plt.axis("off")
plt.show()

# QSphere: amplitudes e fases (3 bases computacionais têm amplitude diferente de zero, todas iguais a 1√3 ≈ 0.577)
fig = plot_state_qsphere(Statevector.from_instruction(w))
fig.figure.savefig("w_qsphere.png")
plt.imshow(fig.figure.canvas.renderer.buffer_rgba())
plt.axis("off")
plt.show()

# Bloch multivector: vetores de Bloch dos qubits individuais (3 qubits estão em estados individuais mistos, não puros)
# Chance de ser 1 (seta para baixo): Qubit só é 1 em 1 dos 3 termos da superposição, probabilidade = 1/3 (≅ 33%)
# Chance de ser 0 (seta para cima): Qubit é "0" nos outros 2 termos, probabilidade = 2/3 (≅ 67%)
fig2 = plot_bloch_multivector(Statevector.from_instruction(w))
fig2.figure.savefig("w_bloch.png")
plt.imshow(fig2.figure.canvas.renderer.buffer_rgba())
plt.axis("off")
plt.show()
</code></pre></small>
                </li>
                <li>Interferência quântica: portas quânticas manipulam amplitudes (valores complexos) - quando caminhos de amplitudes se somam com fases diferentes, elas podem se reforçar (construtiva) ou cancelar (destrutiva). Exemplo clássico: aplicar H, depois Z, depois H mostra interferência (par H Z H implementa rotação equivalente a X até diferença de fase, resultando em padrões de probabilidade diferentes dependendo das fases)
<small><pre><code>
# pip3 install qiskit qiskit-ibm-runtime qiskit-aer matplotlib qiskit[visualization]
# pip3 install qiskit-aer
from qiskit_ibm_runtime import QiskitRuntimeService
# QiskitRuntimeService.save_account(token="SEU_TOKEN_AQUI")

import math
import numpy as np
import matplotlib.pyplot as plt
from qiskit import QuantumCircuit, transpile
from qiskit.quantum_info import Statevector
from qiskit.visualization import plot_state_qsphere, plot_bloch_multivector
from qiskit_aer import AerSimulator  
from qiskit_ibm_runtime import QiskitRuntimeService
service = QiskitRuntimeService()

def show_fig(fig):
    fig.figure.savefig("tmp_fig.png")
    plt.imshow(fig.figure.canvas.renderer.buffer_rgba())
    plt.axis("off")
    plt.show()

qc_super = QuantumCircuit(1, name="superposition")  # Superposição básica
qc_super.h(0) # Hadamard cria superposição (|0&gt; + |1&gt;)/√2

print("Circuito superposição (Hadamard):")
print(qc_super.draw("text"))
fig = qc_super.draw(output="mpl")
show_fig(fig)

# Vetor de estado resultante (sem medida)
state = Statevector.from_instruction(qc_super)
fig_qs = plot_state_qsphere(state)
show_fig(fig_qs)
fig_bloch = plot_bloch_multivector(state)
show_fig(fig_bloch) # Bloch sphere, onde porta H leva |0&gt; ao equador (positivo, superposição igual de |0&gt; e |1&gt;)

# Interferência básica HZH vs HIH
qc_id = QuantumCircuit(1, name="H-I-H") # circuito identidade (identidade não altera estado)
qc_id.h(0)
qc_id.h(0)
qc_z = QuantumCircuit(1, name="H-Z-H") # circuito com interferência de fase Z no meio
qc_z.h(0)
qc_z.z(0)
qc_z.h(0)
print("Circuito H-I-H (texto):")
print(qc_id.draw("text"))
print("Circuito H-Z-H (texto):")
print(qc_z.draw("text"))

state_id = Statevector.from_instruction(qc_id) # vetor de estado H-I-H
state_z  = Statevector.from_instruction(qc_z) # vetor de estado H-Z-H
print("Vetor de estado (H-I-H):", state_id.data)
print("Vetor de estado (H-Z-H):", state_z.data)

fig_z = plot_state_qsphere(state_z) # QSphere para H-Z-H (mostra interferência causada pela porta Z, seta para baixo, informando +1 em |1&gt;)
show_fig(fig_z)

fig_z_bloch = plot_bloch_multivector(state_z) # Bloch para H-Z-H (mostra que estado final é |1&gt;, devido à interferência destrutiva em |0&gt;)
show_fig(fig_z_bloch)

sim = AerSimulator() # Simulador local de medições (sem ruído) para validar probabilidades

qc_meas = QuantumCircuit(1,1) # Medição do circuito original de superposição
qc_meas.h(0)
qc_meas.measure(0,0)

qc_id_meas = qc_id.copy() # Medições para H-I-H e H-Z-H
qc_id_meas.measure_all()
qc_z_meas = qc_z.copy()
qc_z_meas.measure_all()

for circuit, name in [(qc_meas, "H"), (qc_id_meas, "H-I-H"), (qc_z_meas, "H-Z-H")]: # Compile e execute (shots)
    t_qc = transpile(circuit, sim)
    result = sim.run(t_qc, shots=1024).result()
    print(f"\nContagens (&#123;name&#125;): &#123;result.get_counts()&#125;")

# H cria superposição (|0&gt; + |1&gt;)/√2, amplitudes iguais, medições ~50/50
# H-I-H é identidade, retorna |0&gt;
# H-Z-H muda fase via aplicação de Z, interferindo e invertendo, cancelando |0&gt; e reforçando |1&gt;
# Medições confirmam probabilidades calculadas pelo vetor de estado

# O simulador rodou 1024 vezes, sendo 0 (522 vezes) e 1 (502 vezes). Portanto, ~50% para 0 e ~50% para 1
# Em H-I-H, resultado foi 0 (1024 vezes) e 1 (0 vezes), confirmando identidade
# Em H-Z-H, resultado foi 1 (1024 vezes) e 0 (0 vezes), confirmando interferência que inverteu estado de |0&gt; para |1&gt;
</code></pre></small>
                </li>
            </ol>

            <br><h4>Algoritmo de Deutsch (Deutsch's problem):</h4>
            <p id="textoPost">1º algoritmo quântico da história. Resolve problema de Deutsch em etapa única, via computação quântica. Dada função 'f:&#123;0,1&#125;-&gt;&#123;0,1&#125;', queremos saber se a mesma é constante (f(0) = f(1)) ou balanceada (f(0) ≠ f(1)).</p>
            <ul>
                <li>Constante: f(x)=0 (sendo f(0)=0 e f(1)=0) ou f(x)=1 (sendo f(0)=1 e f(1)=1);</li>
                <li>Balanceada: f(x)=x (sendo f(0)=0 e f(1)=1) ou f(x)=¬x (sendo f(0)=1 e f(1)=0).</li>
            </ul>
            <p id="textoPost">A solução, na física clássica, avaliam-se ambas f(0) e f(1). Na física quântica, avaliam-se simultaneamente, via superposição e interferência, em única resposta (diferente de paralelismo clássico), extraindo propriedades da função, não valores individuais. Oráculo (porta Uf) é função escondida que algoritmo pode invocar, onde sabe-se apenas quais entradas e saídas, não seu código interno. Algoritmo quântico resolve Deutsch com apenas 1 consulta ao oráculo. Superposição avalia f(0) e f(1) simultaneamente, enquanto Interferência elimina resultados inúteis. Medição estratégica extrai propriedade global da função. Função constante resulta em estado |0⟩, enquanto função balanceada resulta em estado |1⟩.</p>
<small><pre><code>
# pip3 install qiskit qiskit-ibm-runtime qiskit-aer matplotlib qiskit[visualization]
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit import QuantumCircuit, transpile
from qiskit_aer import Aer, AerSimulator
QiskitRuntimeService.save_account(token="SEU_TOKEN_AQUI")

# Função oráculo, cria circuito quântico de função clássica f: &#123;0,1&#125; -&gt; &#123;0,1&#125;
def deutsch_function(case: int):
 
    # case 1: f(x) = 0 (constante)
    # case 2: f(x) = x (balanceada)
    # case 3: f(x) = ¬x (balanceada)
    # case 4: f(x) = 1 (constante)
    if case not in [1, 2, 3, 4]:
        raise ValueError("`case` must be 1, 2, 3, or 4.")
 
    f = QuantumCircuit(2) # circuito quântico de 2 qubits (1 de entrada, 1 de saída)
    if case in [2, 3]:
        f.cx(0, 1) # CNOT (f(x) = x ou f(x) = ¬x)
    if case in [3, 4]:
        f.x(1) # NOT (f(x) = ¬x ou f(x) = 1)
    return f

# Exemplo (case 3): f(x) = ¬x (balanceada)
display(deutsch_function(3).draw(output="mpl"))
# q0 (qubit de entrada): |0⟩ ou |1⟩
# q1 (qubit de saída): |1⟩ (inicializado em |1⟩ para permitir interferência)
# Porta CNOT aplicada de q0 para q1 (inverte q1 se q0 for |1⟩)
# Porta X (NOT) aplicada em q1 (inverte q1)
# Resultado final: f(0) = 1 e f(1) = 0

def compile_circuit(function: QuantumCircuit):
    n = function.num_qubits - 1
    qc = QuantumCircuit(n + 1, n) # n qubits de entrada + 1 qubit de saída
 
    qc.x(n) # Porta X em qubit de saída (inicializa em |1⟩)
    qc.h(range(n + 1)) # Portas Hadamard em todos qubits (superposição, exceto saída. q0 é superposição de |0⟩ e |1⟩ simultaneamente
 
    qc.barrier()
    qc.compose(function, inplace=True) # Oráculo quântico (CNOT + X), Porta CNOT (q0 é controle, q1 é alvo). Se q0 = 1 então q1 é invertido, se q0 = 0 então nada acontece. Porta X em q1 (inverte q1)
    qc.barrier()
 
    qc.h(range(n)) # Porta Hadamard em q0 (interferência - interferência construtiva em |0⟩, interferência destrutiva em |1⟩)
    qc.measure(range(n), range(n)) # Medição dos qubits de entrada q0 (resultado: 0 = constante, 1 = balanceada)
 
    return qc

# Exemplo de compilação do circuito Deutsch para f(x) = ¬x (case 3). c é bit clássico, resultado da medição
display(compile_circuit(deutsch_function(3)).draw(output="mpl"))

# Algoritmo de Deutsch, determina se função é constante (0) ou balanceada (1)
def deutsch_algorithm(function: QuantumCircuit):
    qc = compile_circuit(function)
 
    result = AerSimulator().run(qc, shots=1, memory=True).result()
    measurements = result.get_memory()
    if measurements[0] == "0":
        return "constant"
    return "balanced"

f = deutsch_function(3)
display(deutsch_algorithm(f))
</code></pre></small>

            <br><h4>Algoritmo de Deutsch-Jozsa (Deutsch-Jozsa's problem):</h4>
            <p id="textoPost">Expansão do algoritmo de Deutsch para funções com múltiplos qubits de entrada, determinando se função é constante ou balanceada via única consulta ao oráculo. Deutsch estipula categorizações de funções quando qubits de entrada n for 0 ou 1. Para valores n maiores que 1, Deutsch-Jozsa considera entradas "indiferentes", sendo promessas de constante ou balanceada.</p>
            <ul>
                <li>Constante: quando saída dos qubits de entrada será sempre 0 ou sempre 1;</li>
                <li>Balanceada (equilibrada): quando saída dos qubits de entrada será 0 e 1 em nº igual de vezes;</li>
                <li>Algoritmo retorna cadeia de bits com todos 0 se função for constante, e cadeia de bits com pelo menos um 1 se função for balanceada (equilibrada).</li>
            </ul>
            <p id="textoPost">Após aplicar portas Hadamard (superposição) nos qubits de entrada, aplicação de 2ª camada de portas Hadamard alterarão estado quântico dos qubits de entrada.</p>
<small><pre><code>
# pip3 install qiskit qiskit-ibm-runtime qiskit-aer matplotlib qiskit[visualization]
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit import QuantumCircuit, transpile
from qiskit_aer import Aer, AerSimulator
from qiskit.visualization import plot_histogram
from IPython.display import display
QiskitRuntimeService.save_account(token="SEU_TOKEN_AQUI")

# Função oráculo para Deutsch-Jozsa
def deutsch_jozsa_oracle(n, oracle_type="balanced"):
    oracle = QuantumCircuit(n + 1) # n qubits de entrada + 1 qubit auxiliar de saída (fase)

    if oracle_type == "constant": # Se função é constante (f(x) = 0), então nada ocorre
        pass

    elif oracle_type == "balanced": # Se função é balanceada (f(x) = 1 para metade dos inputs), então aplica CX (portas CNOTs para cada qubit, invertendo estado do qubit auxiliar)
        for qubit in range(n):
            oracle.cx(qubit, n)
    return oracle

# Construir circuito Deutsch-Jozsa
def deutsch_jozsa_circuit(n, oracle):
    qc = QuantumCircuit(n + 1, n) # n qubits de entrada + 1 qubit auxiliar de saída + n bits clássicos para medição

    # Colocar qubit auxiliar em |1>
    qc.x(n) # Aplica porta X (NOT) no qubit auxiliar
    qc.h(n) # Aplica porta Hadamard no qubit auxiliar

    # Aplica porta Hadamard nos qubits de entrada
    for qubit in range(n):
        qc.h(qubit)
    qc.barrier()

    qc.compose(oracle, inplace=True) # Aplica oráculo ao circuito
    qc.barrier()

    # Aplica 2ª camada de portas Hadamard nos qubits de entrada
    for qubit in range(n):
        qc.h(qubit)

    # Mede qubits de entrada nos bits clássicos correspondentes
    for qubit in range(n):
        qc.measure(qubit, qubit)
    return qc

n = 3  # Quantidade de qubits de entrada
oracle_type = "balanced"  # Tipo de função ('constant' ou 'balanced')
oracle = deutsch_jozsa_oracle(n, oracle_type) # Cria oráculo
qc = deutsch_jozsa_circuit(n, oracle) # Cria circuito Deutsch-Jozsa
display(qc.draw(output="mpl"))

simulator = Aer.get_backend("aer_simulator") # Usa simulador AER
compiled = transpile(qc, simulator) # Transpila circuito para backend do simulador
result = simulator.run(compiled, shots=1024).result() # Executa circuito no simulador
counts = result.get_counts() # Obtém resultados da medição

display(plot_histogram(counts))
print("Resultados:", counts) # Exibe resultados da medição (000 indica função constante, qualquer outro resultado indica função balanceada)
</code></pre></small>

            <br><h4>Algoritmo de Bernstein-Vazirani (Bernstein-Vazirani's problem):</h4>
            <p id="textoPost">Também chamado de problema de amostragem de Fourier, promete identificar string oculta via consulta única ao oráculo, ao invés de somente rótulos constante e balanceada.</p>
            <ol>
                <li>Recebe-se função caixa preta 'f(x)=s*x', para string 's' a ser descoberta;</li>
                <li>Aplica-se porta Hadamard em todos qubits de entrada, 1 porta NOT mais 1 Hadamard é aplicada ao qubit de saída;</li>
                <li>Aplica-se oráculo (porta Uf) em todos qubits, recebendo qubits de entrada (em superposição iguais), e aplicando função 'f(x)=s*x' ao qubit de saída, mantendo-o em estado inalterado, graças ao retrocesso de fase, mas invertendo alguns termos no estado;</li>
                <li>Aplica-se 2ª camada de portas Hadamard em todos qubits de entrada, seguida de medição, revelando string oculta 's', advinda do estado gerado nos qubits.</li>
            </ol>
<small><pre><code>
# pip3 install qiskit qiskit-ibm-runtime qiskit-aer matplotlib qiskit[visualization]
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit import QuantumCircuit, transpile
from qiskit_aer import Aer, AerSimulator
from qiskit.visualization import plot_histogram
from IPython.display import display
import matplotlib.pyplot as plt
QiskitRuntimeService.save_account(token="SEU_TOKEN_AQUI")

s = "1011" # String oculta 's'
n = len(s) # Quantidade de qubits de entrada

# Função oráculo Uf para Bernstein-Vazirani
def bernstein_vazirani_oracle(secret_string: str) -&gt; QuantumCircuit:
    n = len(secret_string)
    oracle = QuantumCircuit(n + 1) # n qubits de entrada + 1 qubit auxiliar

    for i, bit in enumerate(secret_string):
        if bit == "1":
            oracle.cx(i, n) # Aplica CNOT do qubit i de entrada para qubit auxiliar
    oracle.name = "U_f"
    return oracle

qc = QuantumCircuit(n + 1, n) # Circuito com n qubits de entrada, 1 qubit auxiliar e n bits clássicos

qc.x(n) # Aplica X (porta NOT) no qubit auxiliar, colocando-o em |1&gt;
qc.h(range(n + 1)) # Aplica Hadamard em todos qubits
oracle = bernstein_vazirani_oracle(s) # Aplica oráculo ao circuito
qc.append(oracle, range(n + 1)) # Aplica oráculo aos qubits do circuito
qc.h(range(n)) # Aplica Hadamard novamente nos qubits de entrada
qc.measure(range(n), range(n)) # Mede qubits de entrada nos bits clássicos
display(qc.draw(output="mpl"))

simulator = AerSimulator()
tqc = transpile(qc, simulator) # Transpila circuito para simulador
result = simulator.run(tqc, shots=1024).result() # Executa circuito no simulador

counts = result.get_counts() # Obtém resultados da medição
print("Resultados da medição:", counts) # Exibe resultados (se houver mais de um, o mais frequente é a string oculta 's')

measured = list(counts.keys())[0]
print("Resultado quântico:", measured[::-1]) # Inverte string para corresponder à ordem dos qubits (q0 é o bit menos significativo)
</code></pre></small>

            <br><h4>Algoritmo de Simon (Simon's problem):</h4>
            <p id="textoPost">Similar ao algoritmo de Bernstein-Vazirani, mas encontrar string oculta com propriedade de simetria específica, de forma indireta, via deduções a partir de restrições.</p>
            <ul>
                <li>Cadeia de caracteres totalmente 0 (exemplo: 0000): um-para-um (para cada cadeia de caracteres de saída possível de f, há exatamente 1 cadeia de caracteres de entrada que fazem com que f produza essa cadeia);</li>
                <li>Cadeia de caracteres não totalmente 0 (exemplo 0101): dois-para-um (para cada cadeia de caracteres de saída possível de f, há exatamente 2 cadeias de caracteres de entrada que fazem com que f produza essa cadeia);</li>
            </ul>
            <ol>
                <li>Aplica-se 1ª camada de portas Hadamard em todos qubits de entrada;</li>
                <li>Aplica-se oráculo (porta Uf) em todos qubits, onde saída da função f é XOR no estado totalmente zero dos qubits inferiores da m;</li>
                <li>Aplica-se 2ª camada de portas Hadamard em todos qubits de entrada, onde análise diverge dos demais algoritmos quânticos anteriores;</li>
                <li>Aplica-se medição, onde nos casos de cadeia de caracteres totalmente 0, função um-para-um é confirmada. Em cadeia de caracteres não totalmente 0, função dois-para-um é confirmada;</li>
                <li>Pós-processamento: algoritmo não retorna s diretamente. Ele retorna vetores z que são ortogonais a s (em aritmética binária). Após coletar n-1 vetores linearmente independentes, resolve-se sistema linear clássico para achar s;</li>
            </ol>
<small><pre><code>
# pip3 install qiskit qiskit-ibm-runtime qiskit-aer qiskit[visualization]
from qiskit_ibm_runtime import QiskitRuntimeService
from qiskit import QuantumCircuit, transpile
from qiskit_aer import AerSimulator
from qiskit.visualization import plot_histogram
from IPython.display import display
QiskitRuntimeService.save_account(token="SEU_TOKEN_AQUI")

s = '110' # String oculta
n = len(s)

# Função oráculo para Simon
def simon_oracle(s):
    s = s[::-1] # Inverte string para facilitar acesso aos bits
    n = len(s)
    qc = QuantumCircuit(n*2) # Criar circuito quântico com 2n qubits
    for q in range(n):
        qc.cx(q, q+n) # Aplica porta CNOT para criar superposição no segundo registro
    if '1' not in s: # Se s for string nula, retorna circuito sem alterações
        return qc
    i = s.find('1')
    for q in range(n):
        if s[q] == '1':
            qc.cx(i, (q)+n) # Se qubit de s for 1, aplica porta CNOT do qubit i para qubit q+n
    return qc

qc = QuantumCircuit(n*2, n) # Criar circuito quântico com 2n qubits e n bits clássicos para medição
qc.h(range(n)) # Aplica porta Hadamard (superposição) nos primeiros n qubits de entrada
qc.barrier()
qc = qc.compose(simon_oracle(s)) # Aplica oráculo de Simon ao circuito
qc.barrier()
qc.h(range(n)) # Aplica 2ª camada de portas Hadamard nos primeiros n qubits de entrada
qc.measure(range(n), range(n)) # Mede primeiros n qubits de entrada e armazena resultados nos bits clássicos
qc.draw('mpl')
display(qc.draw())
display(qc.draw(output='mpl'))

simulator = AerSimulator()
tqc = transpile(qc, simulator)
result = simulator.run(tqc, shots=1024).result() # Executa circuito no simulador e obtém resultados
counts = result.get_counts() # Conta ocorrências de cada resultado medido

display(plot_histogram(counts))
print(counts)
print("Resultado s:", s)
</code></pre></small>

            <br><h4>Teleportação Quântica (Quantum Teleportation):</h4>
            <p id="textoPost">Protocolo quântico para transferir estado quântico de qubit a outro, via comunicação clássica de 2 bits, resultante de emaranhamento quântico pós-medição de Bell AB. Matéria física não é teletransportada, apenas informação (estado quântico). Alice (remetente) possui qubit A, e Bob (receptor) possui qubit B emaranhado com Alice (Bell, par emaranhado AB), possibilitando transmitir estado quântico entre eles. Alice mede AB e passa a ter 3º qubit Q, com estado desconhecido, que deseja teletransportar ao Bob. Alice mede AB, obtendo 2 bits clássicos, e envia a Bob. Bob aplica correções em B com base nos bits recebidos, recuperando estado original de Q em B. Etapas do teletransporte quântico:</p>
            <ol>
                <li>Alice aplica porta CNOT (CX) no Bell AQ, onde Q é controle e A é alvo;</li>
                <li>Alice aplica porta Hadamard (H) em Q;</li>
                <li>Alice mede (interferência destrutiva) Bell AQ e transmite resultados, em 2 bits clássicos, ao Bob. Resultado da medição de A é a, e Q é b;</li>
                <li>Bob recebe a e b de Alice e transforma:
                    <ul>
                        <li>Se a=1, então Bob aplica porta Pauli X (NOT) em B;</li>
                        <li>Se b=1, então Bob aplica porta Pauli Z (inversão de fase) em B;</li>
                        <li>Exemplo: ab=[00,01,10,11], então Bob executa [I,Z,X,XZ] em B, sendo Q teletransportado para B.</li>
                    </ul>
                </li>
            </ol>
            <p id="textoPos">Após teletransporte, é impossível clonar estado quântico de Q, pois mudou-se do valor original. O estado de A também foi modificado, não estando mais emaranhado com B. Fluxo do teletransporte quântico:</p>
            <ol>
                <li>Qubit 0 (Q): estado desconhecido (a ser teleportado);</li>
                <li>Qubits 1 (A) e 2 (B): criam par de Bell AB (canal quântico);</li>
                <li>Alice opera em (0,1 ou seja QA) e mede ambos, obtendo bits clássicos a e b;</li>
                <li>Bob corrige qubit 2 (B) com base em a e b, recuperando estado original de Q em B.</li>
            </ol>
<!--FALTA VER (teletransporte quântico)
- https://en.wikipedia.org/wiki/Quantum_teleportation
- https://quantum.cloud.ibm.com/learning/en/modules/computer-science/quantum-teleportation
-->
        </div>
    </div>


<!--Rodapé-->
<div class="row">
    <div class="col-sm-12 text-center bg-black text-light pt-4 pb-3">
        <p>Elaborado por Mateus Schwede<br><small class="text-muted">ubsocial.github.io</small></p>
    </div>
</div>

</div>
</body>
</html>