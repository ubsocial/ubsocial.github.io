<!doctype html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" href="../icons/logoTit.png">
    <link rel="stylesheet" href="../estilo.css">
    <title>UB Social</title>
</head>
<body>
<div class="container-fluid">


    <div class="row">
        <div class="col-sm-12">
            <nav class="navbar rounded-bottom fixed-top navbar-expand-lg navbar-light bg-light shadow">
                <div class="container-fluid">
                    <a class="navbar-brand" href="../index.html"><img src="../icons/logo.png" class="d-inline-block align-text-top" width="11pt"> UB Social</a>
                    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
                    <div class="collapse navbar-collapse" id="navbarNav">
                        <ul class="navbar-nav">
                            <li class="nav-item"><a class="nav-link" href="../index.html">Home</a></li>
                            <li class="nav-item"><a class="nav-link" href="../sobre/sobre.html">Sobre</a></li>
                            <li class="nav-item"><a class="nav-link" href="../cursos.html">Cursos</a></li>
                            <li class="nav-item"><a class="nav-link" href="../livros/livros.html">Livros</a></li>
                        </ul>
                    </div>
                </div>
            </nav>
        </div>
    </div>

    <div class="row">
        <div class="col-sm-12 text-center" id="titulo">
            <h1>Computação Quântica</h1>
            <h6>Conceito, princípios e aplicações</h6>
            <a href="../index.html" class="btn btn-link text-decoration-none mb-3">Voltar</a>
        </div>

        <div class="col-sm-12">
            <p class="text-warning text-center">RESUMO EM CONSTRUÇÃO</p>
            <h4>Material complementar:</h4>
            <ul>
                <li>Conteúdo no YouTube: <a class="text-decoration-none">Acesse em breve</a></li>
                <li>Conteúdo no GitHub: <a href="https://github.com/mateusschwede/computacao_quantica" target="_blank" class="text-decoration-none">Acesse</a></li>
                <li>Curso gratuito com certificado na Workover Academy: <a class="text-decoration-none">Acesse em breve</a></li>
            </ul>

            <br><h4>Conceito:</h4>
            <ul>
                <li><b>Computação clássica</b>: baseada na física clássica (arquitetura de Von Neumann), onde processador (CPU) opera com bits 0 (desligado, sem eletricidade) ou 1 (ligado, com eletricidade);
                    <ul>
                        <li>Processamento sequencial: 1 item por vez (ex: explorará cada caminho do labirinto, por vez, até encontrar solução otimizada).</li>
                    </ul>
                </li>
                <li><b>Computação quântica</b>: baseada na física quântica (mecânica quântica - partícula quantum), onde processador (QPU) opera com partículas subatômicas qubits (bit quântico - qbit - qubit topológico) 0, 1 ou ambos simultaneamente resultante de superposição de estados, onde partículas podem existir em múltiplos estados simultaneamente (Gato de Schrödinger). Entrelaçamento quântico permite que qubits atuem de ambas formas simultaneamente (ser inverso ao outro qubit. Sendo 0, será 1 ao mesmo tempo, independentemente da distância entre ambos - ação fantasmagórica à distância, Einstein). NISQ (Noisy Intermediate-Scale Quantum), descreve era atual de computadores quânticos, com dezenas a centenas de qubits suscetíveis a ruído. Com 300 qubits, computador quântico poderia representar mais estados do que nº de átomos no universo observável.
                    <ul>
                        <li>Qubit: descrito por vetor de estado em sistema quântico de 2 níveis, o qual é matematicamente equivalente a vetor em espaço vetorial complexo de 2 dimensões, conhecido como espaço de Hilbert, via notação bra-ket de Paul Dirac;</li>
                        <li>Processamento paralelo: itens processados simultaneamente (ex: explorará todos caminhos do labirinto simultaneamente até encontrar solução otimizada instantaneamente);</li>
                        <li>Resfriamento dos elétrons (-273,5°C) os mantém aproximadamente emaranhados (emaranhamento quântico), diminuindo agitação térmica, formando pares (pares de Cooper) que saltam de um lado a outro no circuito, formando qubit supercondutor;</li>
                        <li>Supercondutividade: fios supercondutores transportam elétrons sem resistência, eliminando perdas de energia, possibilitando circuitos quânticos (circuitos com capacitores e junções Josephson). Teletransporte quântico é processo pelo qual estado quântico exato de qubit é transferido de local para outro, sem mover sua partícula física;</li>
                        <li>Portas lógicas quânticas: operam em qubits, permitindo manipulação de estados quânticos de qubits para processamento. Porta Hadamard (H) cria superposição, porta CNOT (controlled-NOT) gera entrelaçamento. Porta NOT Quântica (Pauli-X), no caso clássico, troca 1 por 0 e vice-versa. Generalização para caso quântico é dada por operador X que satisfaz X |0⟩=|1⟩ e X|1⟩=|0⟩;</li>
                        <li>Interferência quântica: ondas de qubits podem interferir entre si, gerando respostas em padrões de interferência de probabilidade aumentada a encontrar partícula (interferência construtiva) ou padrões de interferência de probabilidade diminuída/nula a encontrar partícula (interferência destrutiva);</li>
                        <li>Decoerência: processo onde sistema em estado quântico colapsa/perde para estado não quântico, ocasionado intencionalmente, ou por fatores ambientais;</li>
                        <li>Correção de erro quântico (QEC): técnica para manter qubits estáveis e confiáveis, codificando dados de qubit lógico (ideal) em muitos qubits físicos (reais e ruidosos);</li>
                        <li>Pontos quânticos ("átomos artificiais"): pequeno semicondutor capaz de capturar elétron único e usá-lo em Spin do elétron, ou carga confinada, como qubit. Qubits de pontos quânticos podem ser manipulados com uso de campos magnéticos. São altamente escaláveis e compatíveis com tecnologias de semicondutores atuais.</li>
                    </ul>
                </li>
            </ul>

            <br><h4>Necessidade da computação quântica:</h4>
            <p id="textoPost">Chips compõem-se bilhões de transistores (semicondutores microscópicos que controlam fluxo de elétrons binários - não passa energia é 0, passa energia é 1). Em 1975, Gordon Moore, cofundador da Intel, observou que quantidade de transistores em chip de circuito integrado dobra aproximadamente a cada 2 anos (Lei de Moore), resultando chips menores e mais rápidos. Atualmente, transistores de silício chegaram à escala de nanômetros, com dimensões próximas ao tamanho de átomos individuais (miniaturização extrema). Ocasionará problemas físicos em túnel quântico (tunelamento quântico - elétrons começam atravessar barreiras microscópicas, causando vazamentos de corrente), aquecimento (quanto mais transistores, mais calor, limitando desempenho), custo e energia. Computação clássica está chegando ao limite físico do silício (espaço físico para encolher e acelerar chips está fisicamente lotado - problema do caixeiro-viajante). Moore prevê tal limite em meados de 2025.</p>

            <br><h4>Hardware de suporte:</h4>
            <p id="textoPost">Chip de processamento quântico é minúsculo (muitas vezes menor que moeda), mas necessita de grande sistema de suporte para funcionamento íntegro, pois qubits são extremamente sensíveis (qualquer calor, luz, som ou vibração pode destruir o estado quântico). Planos que compõem hardware quântico:</p>
            <ol>
                <li>Plano de dados quânticos (área de hospedagem): essência do computador quântico, inclui qubits físicos e estruturas necessárias para mantê-los no lugar;</li>
                <li>Plano de controle e medição (método de transferência): converte sinais digitais em analógicos ou de controle de ondas. Esses sinais analógicos executam operações nos qubits do plano de dados quânticos;</li>
                <li>Plano de processador de controle e processador host (computação para controle): plano de processador de controle implementa algoritmo quântico ou sequência de operações. Processador host interage com software quântico e fornece sinal digital ou sequência de bits clássicos para plano de controle e medição. Geralmente computador clássico é usado para suportar hardware quântico.</li>
            </ol>
            <ul>
                <li>Blindagem térmica: isola chip de variações de temperatura, garantindo estabilidade do estado quântico. Resfriamento criogênico mantém chip a temperaturas próximas de -273,15°C (zero absoluto), garantindo estado de supercondutividade;</li>
                <li>Blindagem eletromagnética: protege chip de interferências externas, garantindo operação estável, evitando feixes eletromagnéticos indesejados. Ímãs supercondutores mantém estado da matéria estável, com elétrons emaranhados e controláveis;</li>
                <li>Proteção contra luz: materiais especiais bloqueiam feixes de luz visível, evitando interferência de agitação no estado quântico dos qubits;</li>
                <li>Isolamento vibracional e acústico: combina técnicas de isolamento para proteger chip de vibrações e ruídos indesejados;</li>
                <li>Proteção contra radiação: barreiras especiais protegem chip de radiações ionizantes, evitando decoerência;</li>
                <li>Vácuo e gaiolas ópticas: eliminam partículas do ar que poderiam causar decoerência (perda do estado quântico);</li>
                <li>Tecnologia fotônica: utiliza fótons (partículas de luz) como qubits fotônicos, alinhados e controlados por lasers, permitindo transmissão de dados quânticos (comunicação quântica). Chave quântica (QKD - Quantum Key Distribution) é transmitida via impulsão de laser por fótons (transporte via fibra óptica ou espaço livre) e, se interceptada, a própria luz denuncia tentativa de espionagem e dados são desmaterializados, tornando-a impossível de ser copiada sem detecção;</li>
                <li>Tecnologia de íons aprisionados (trapped ions - armadilhas de íons - IonQ): átomos neutros/frios (armadilhas de átomos neutros - neutral atom trap) carregados (íons) são presos em gaiola de luz para resfriamento e manipulados com lasers. Cada íon aquecido representa 1 qubit;</li>
                <li>Centros de Vacância em Diamante (NV Centers): defeito específico na estrutura cristalina do diamante, onde átomo de carbono é substituído por nitrogênio ao lado de lacuna (vacância), pode funcionar como qubit. Spin eletrônico do centro NV pode ser manipulado com micro-ondas e lido opticamente, e pode operar à temperatura ambiente, embora escalabilidade seja desafio.</li>
            </ul>

            <br><h4>Circuitos quânticos:</h4>
            <p id="textoPost">Sequência de portas quânticas usadas em cálculo.</p>
            <ol>
                <li>Entrada: qubits de entrada são preparados em estado inicial, geralmente '|0⟩' para cada qubit. Estado conjunto de múltiplos qubits é descrito matematicamente pelo que é chamado de seu produto tensorial;</li>
                <li>Linhas horizontais: cada linha representa evolução temporal de único qubit. Elas não são necessariamente fios físicos, podendo ser apenas passagem do tempo para íon aprisionado ou deslocamento espacial de fóton;</li>
                <li>Sentido: circuito é lido da esquerda para direita, descrevendo evolução do sistema quântico no tempo;</li>
                <li>Portas quânticas: blocos nas linhas representam portas quânticas, que são operações unitárias aplicadas aos qubits;</li>
                <li>Linhas verticais: segmento vertical conectando múltiplas linhas de qubits, como em uma porta CNOT, informa que porta atua simultaneamente nesses qubits. Linha vertical representa sincronismo da operação, e não o envio de informação;</li>
                <li>Controle: em porta controlada (como CNOT), um ponto sólido (●) em linha indica que qubit representado nessa linha é qubit de controle. Caso esteja no estado '|1⟩', porta realiza operação no qubit alvo; caso esteja no estado '|0⟩', porta não realiza operação alguma. Caso qubit de controle seja estado superposto ou ambos qubits estejam emaranhados, não é possível compreender comportamento individual do qubit de controle e do qubit alvo. Deve-se considerar ação do operador unitário, que representa todo circuito, atuando simultaneamente no estado conjunto dos qubits;</li>
                <li>Saída: no final do circuito, qubits que compõem saída podem ser medidos. Medição colapsa superposição de cada qubit para resultado clássico (0 ou 1).</li>
            </ol>

            <br><h4>Cotidiano com computação quântica:</h4>
            <p id="textoPost">Computação quântica complementará coexistência a computação clássica (integração híbrida), pois dispositivos computacionais ainda utilizam demais componentes de interpretação binária clássica. Computação quântica é utilizada em longos processamentos de dados, como descriptografia, pesquisas científicas, simulações moleculares, IAs avançadas, etc. Criptografia pós-quântica (PQC), novos algoritmos clássicos resistentes a ataques quânticos e clássicos, são desenvolvidos como resposta à ameaça da computação quântica. Distribuição quântica de chaves (QKD) é baseada em princípios quânticos para comunicação inviolável. Protocolo BB84 permite criar chave secreta entre 2 partes. Tentativas de espionagem alteram estados quânticos e são detectadas. Problemas de otimização em finanças e engenharia, onde computação quântica, via algoritmos QAOA ou recozimento quântico, pode encontrar soluções melhores e mais rápidas para problema do caixeiro-viajante, roteamento de veículos, e otimização de cadeias de suprimentos.</p>
            <ul>
                <li>Supremacia quântica (quantum supremacy): ponto em que computador quântico executa tarefa impossível para computador clássico em tempo viável;</li>
                <li>Utilidade quântica (quantum utility): cotidiano atual, em que computadores quânticos já executam tarefas úteis, ainda que sem superar métodos clássicos em todos casos;</li>
                <li>Vantagem quântica prática (practical quantum advantage): estágio futuro esperado, onde desempenho e custo-benefício superarão efetivamente métodos clássicos em aplicações reais.</li>
            </ul>

            <br><h4>Recozimento quântico:</h4>
            <p id="textoPost">Método alternativo ao modelo de portas, usado para resolver problemas de otimização e amostragem. Busca estado de energia mínima de sistema físico representando problema. Qubits evoluem de superposição inicial para configuração final, usando tunelamento quântico para atravessar barreiras de energia e evitar ótimos locais, aumentando chance de alcançar solução global. Aplicações incluem otimização combinatória, finanças, rotas e machine learning. Problema da não linearidade, na aprendizagem clássica, ocorre quando métodos lineares não captam relações complexas. No ML quântico, embora operações sejam lineares, feature maps introduzem não linearidades eficazes. Circuitos variacionais (VQC) com portas parametrizadas aprendem funções altamente não lineares, semelhantes a redes neurais profundas.</p>

            <br><h4>Processadores de átomos de Rydberg:</h4>
            <p id="textoPost">Átomo de Rydberg corresponde a átomo excitado que possui, em média, 1 ou mais elétrons distantes do núcleo. Átomos de Rydberg têm várias propriedades peculiares, incluindo resposta exagerada a campos elétricos e magnéticos, bem como vida longa. Quando usados como qubits, oferecem interações atômicas fortes e controláveis ajustáveis ao selecionar diferentes estados.</p>

            <br><h4>Processadores baseados em ressonância magnética nuclear (RMN):</h4>
            <p id="textoPost">Dado quântico armazenado nos spins nucleares dos átomos em moléculas, e portas lógicas manipulam essa informação via radiação eletromagnética. Pósitron ou elétron podem ter spin 'para cima', 'para baixo', ou ambos simultaneamente, representando estados do qubit. Momentos magnéticos nucleares fazem movimento natural de precessão na presença de campos magnéticos. Estados quânticos dos núcleos podem ser manipulados irradiando núcleos com pulsos de rádio frequência sintonizados na frequência de precessão dos mesmos.</p>

            <br><h4>Pilares dos algoritmos quânticos:</h4>
            <ul>
                <li>Transformada quântica de Fourier (QFT): versão quântica da Transformada Discreta de Fourier (DFT), base do algoritmo de Shor, que transforma amplitudes em espaço de frequências com ganho exponencial;</li>
                <li>Amplificação de amplitude: aumenta probabilidade do estado solução. Usada no algoritmo de Grover, aplicando rotações iterativas no vetor de estado;</li>
                <li>Interferência quântica: cancela estados incorretos (interferência destrutiva) e reforça corretos (construtiva), sendo base da eficiência quântica;</li>
                <li>Simulação hamiltoniana: simula sistemas quânticos via portas lógicas, mapeando Hamiltoniana (operador matemático que descreve energia total de sistema quântico) do sistema físico. Origem em Feynman;</li>
                <li>Princípio da incerteza: resultados são probabilísticos, requerindo múltiplas execuções e análise estatística para inferir solução.</li>
            </ul>

            <br><h4>Algoritmos quânticos:</h4>
            <ul>
                <li>Algoritmo de Shor (Peter Shor - 1994): resolve fatoração de nºs inteiros em tempo polinomial. Usa Transformada Quântica de Fourier para encontrar período de função. Permite deduzir fatores primos de N. Ameaça criptografia de chave pública baseada em fatoração, como RSA (Rivest - Shamir - Adleman);</li>
                <li>Algoritmo de Grover (Lov Grover - 1996): aceleração quadrática em busca não estruturada. Reduz tempo de busca de O(N) para O(√N). Aplicável a problemas de otimização e busca geral;</li>
                <li>Algoritmo Adiabático e Computação Quântica Adiabática (adiabatic quantum computing): baseado no teorema adiabático da física, onde sistema inicia no estado fundamental e evolui lentamente, mantendo-o. Usado em computadores quânticos adiabáticos como D-Wave, e voltado para problemas de otimização, como rotas logísticas. Processo envolve Hamiltoniana inicial simples evoluída para final complexa, em que estado final representa solução do problema. Computação adiabática é polinomialmente equivalente ao modelo de circuito, mas com aplicações distintas;</li>
                <li>Algoritmo HHL (Harrow, Hassidim e Lloyd): resolve sistemas de equações lineares e oferece aceleração exponencial em situações com aplicações potenciais em diversas áreas da ciência e engenharia;</li>
                <li>Algoritmos de simulação quântica: simulam sistemas quânticos complexos, como interações moleculares e materiais novos. Utilizam portas lógicas para modelar dinâmica quântica;</li>
                <li>Algoritmos de otimização quântica: resolvem problemas de otimização combinatória, como problema do caixeiro-viajante. Exemplos incluem QAOA (Quantum Approximate Optimization Algorithm) e VQE (Variational Quantum Eigensolver);</li>
                <li>Algoritmos de aprendizado de máquina quântica (QML): exploram paralelismo quântico para acelerar tarefas de aprendizado de máquina (Machine Learning), como classificação e clustering. Exemplos incluem QSVM (Quantum Support Vector Machine) e QNN (Quantum Neural Networks);</li>
                <li>Algoritmos de criptografia quântica: utilizam princípios quânticos para comunicação segura. Exemplo é QKD (Quantum Key Distribution), que permite troca segura de chaves criptográficas, detectando qualquer tentativa de interceptação;</li>
                <li>Algoritmos híbridos quântico-clássicos: combinam computação quântica e clássica para resolver problemas complexos. Exemplos incluem VQE e QAOA, onde parte do processamento é feito em computador clássico e parte em computador quântico;</li>
                <li>Algoritmos de otimização quântica baseados em annealing quântico: utilizam processos de resfriamento para encontrar soluções aproximadas para problemas de otimização. Exemplos incluem Quantum Annealing e algoritmos implementados em computadores quânticos adiabáticos;</li>
                <li>Algoritmos de simulação de materiais quânticos: modelam propriedades de materiais em nível quântico, permitindo estudo de novos materiais com propriedades desejadas. Exemplos incluem simulações de moléculas e materiais usando técnicas como VQE;</li>
                <li>Algoritmos de busca quântica em grafos: exploram estruturas de grafos para resolver problemas de busca e otimização. Exemplos incluem algoritmos baseados em caminhada quântica;</li>
                <li>Algoritmos de fatoração quântica além de Shor: exploram variações e melhorias no algoritmo de Shor para fatoração de nºs inteiros, visando maior eficiência e robustez;</li>
                <li>Algoritmos de simulação quântica de sistemas físicos: modelam sistemas físicos complexos, como dinâmica de partículas e interações quânticas, utilizando técnicas avançadas de simulação;</li>
                <li>Algoritmos de otimização quântica para logística e planejamento: aplicam computação quântica para resolver problemas práticos em logística, como roteirização e alocação de recursos;</li>
                <li>Algoritmos de aprendizado profundo quântico: combinam redes neurais profundas (Deep Learning Neural Networks) com computação quântica para melhorar desempenho em tarefas complexas de aprendizado de máquina;</li>
                <li>Algoritmos de criptografia pós-quântica: desenvolvem métodos criptográficos resistentes a ataques de computadores quânticos, garantindo segurança futura na comunicação;</li>
                <li>Algoritmos de simulação quântica para química computacional: modelam reações químicas e propriedades moleculares, facilitando descobertas em química e farmacologia;</li>
                <li>Algoritmos de otimização quântica para finanças: aplicam computação quântica para resolver problemas financeiros, como otimização de portfólios e precificação de derivativos;</li>
                <li>Algoritmos de aprendizado de máquina quântica para análise de dados: utilizam computação quântica para acelerar análise de grandes volumes de dados (Big Data), melhorando eficiência em tarefas como mineração de dados (Data Mining) e análise preditiva (Predictive Analytics).</li>
            </ul>

            <br><h4>Medições quânticas:</h4>
            <p id="textoPost">Ato de transformar possibilidade (superposição) em realidade (0 ou 1). Qubits estão constantemente em superposição (probabilidades % de estar em 0 à 1), e tornam-se definidos (0 ou 1) após medição. Exemplo, em superposição, um qubit pode estar 70% em 0 e 30% em 1, mas após medição será 0 ou 1.</p>
            <ul>
                <li>Computação clássica: bit possui estado definido (0 ou 1, contendo 2 combinações distintas). 2 bits combinados, formam-se 4 combinações distintas (00, 01, 10 e 11). n bits = 2ⁿ estados distintos;
                    <ul>
                        <li>1 bit: 2 estados possíveis (1 por vez);</li>
                        <li>2 bits: 4 estados possíveis (1 por vez);</li>
                        <li>3 bits: 8 estados possíveis (1 por vez).</li>
                    </ul>
                </li>
                <li>Computação quântica: qubit possui estado indefinido (superposição, contendo 2 combinações simultâneas, cada uma com respectiva probabilidade - combinação linear de estados básicos sob coeficientes de probabilidades para estados possíveis de 0 e 1). 2 qubits combinados, formam-se superposição de 4 combinações simultaneamente (00, 01, 10 e 11). n qubits = 2ⁿ estados simultaneamente.
                    <ul>
                        <li>1 qubit: 2 estados possíveis (2 simultaneamente (percentuais de cada));</li>
                        <li>2 qubits: 4 estados possíveis (4 simultaneamente (percentuais de cada));</li>
                        <li>3 qubits: 8 estados possíveis (8 simultaneamente (percentuais de cada)).</li>
                    </ul>
                </li>
            </ul>
            <p>Esparçador Pauli (Sparse Pauli) adventa matrizes de Pauli, onde são aplicadas 3 matrizes X, Y e Z em, além de I (identidade I), em um qubit, para medir seu estado.</p>
            <ul>
                <li>X = inverte qubit (como inverter 0/1)</li>
                <li>Z = muda fase (como mudar a "cor" invisível do estado)</li>
                <li>Y = combinação de X e Z</li>
                <li>I = não faz nada</li>
            </ul>
            <p id="textoPost">Em 3 qubits, operação X ⊗ Z ⊗ I (ou "XZI" - Pauli String, sequência de Paulis) aplica X no qubit 1, Z no qubit 2, e I (nada) no qubit 3. SparsePauliOp (Sparse Pauli Operator) é forma compacta (esparsa) de guardar combinações sem ocupar tanta memória. Estado quântico é "como sistema está", SparsePauli é "tipo de óculos com que você observa". Você escolhe "conjunto de lentes" (matrizes Pauli) para olhar seu sistema e obter informações (medições). Pauli noise (ruído de Pauli) é um modelo de ruído quântico que descreve erros aleatórios aplicados a qubits usando matrizes de Pauli (X, Y, Z). Usadas para simular imperfeições reais nas transformações de qubits, em computadores quânticos. X-error inverte estado (Bit-flip noise), Z-error muda fase (Phase-flip noise), e Y-error combina erros X e Z (inversão + mudança de fase, Bit-phase-flip noise). Depolarizing noise destaca forma simétrica de Pauli noise na aplicação de X, Y ou Z com mesma probabilidade.</p>

            <br><h4>Benchmarks quânticos:</h4>
            <p id="textoPost">Avaliam desempenho e utilidade dos computadores quânticos, sem implicar vantagem comprovada sobre métodos clássicos. Fidelidade de camada mede capacidade geral do processador em executar circuitos, revelando detalhes sobre qubits, portas e interferências. CLOPS (operações de camada de circuito por segundo) mede velocidade de execução de circuitos de volume quântico, combinando desempenho quântico e clássico. Ambas permitem comparar sistemas e acompanhar ganhos de performance. Profundidade do circuito indica quantas operações paralelas podem ser executadas antes da decoerência, determinando complexidade dos circuitos possíveis.</p>

            <br><h4>Linguagens de programação:</h4>
            <p id="textoPost">Linguagens utilizadas especificamente para processamento quântico. Ambientes disponíveis para desenvolvimento são IBM Quantum Experience, Azure Quantum, Google Quantum AI e AWS Braket. Plataformas IBM Quantum Platform, Azure Quantum, Google Quantum AI e AWS Braket oferecem ferramentas e recursos para desenvolvimento quântico.</p>
            <ul>
                <li>Qiskit: principal stack de software da IBM para computação quântica, indo além do desenvolvimento de circuitos. Inclui SDK, middleware e serviços para escrever, otimizar e executar programas em sistemas IBM Quantum, com novas ferramentas de IA generativa para assistência de código;</li>
                <li>Q#: linguagem quântica desenvolvida pela Microsoft, baseada no C#, voltada para desenvolvimento de algoritmos quânticos, controlando comportamento dos qubits e explorando superposição e entrelaçamento quântico. Exemplo abaixo cria par de Bell (estado de entrelaçamento quântico entre 2 qubits):
<small><pre><code>
open Microsoft.Quantum.Intrinsic; // Importa operações quânticas básicas
open Microsoft.Quantum.Measurement; // Importa operações de medição
open Microsoft.Quantum.Canon; // Importa operações canônicas

operation CreateBellPair() : (Result, Result) &#123;
    use qubits = Qubit[2]; // Aloca array de 2 qubits
    
    H(qubits[0]); // Aplica porta quântica Hadamard no 1º qubit (superposição)
    CNOT(qubits[0], qubits[1]); // Aplica porta quântica CNOT (Controlled-NOT, entrelaçamento)

    let result1 = M(qubits[0]); // Mede 1º qubit
    let result2 = M(qubits[1]); // Mede 2º qubit

    Reset(qubits[0]); // Reseta 1º qubit
    Reset(qubits[1]); // Reseta 2º qubit

    return (result1, result2); // Retorna resultados das medições (sempre iguais, exemplo, ambos 0 ou ambos 1)
&#125;
</code></pre></small>
                </li>
            </ul>

            <br><h4>Qiskit</h4>
            <ol>
                <li>Instalação:
<small><pre><code>
pip3 install qiskit qiskit-ibm-runtime matplotlib qiskit[visualization] jupyter
</code></pre></small>
                </li>
                <li>Conexão:
<small><pre><code>
from qiskit_ibm_runtime import QiskitRuntimeService

QiskitRuntimeService.save_account(
    channel="ibm_quantum_platform",
    token="SEU-TOKEN-IBM-QUANTUM-AQUI",
    overwrite=True
) # Usar apenas 1 vez para salvar conta

service = QiskitRuntimeService() # Usar para conectar conta em cada script
print("Conta conectada com sucesso!")
</code></pre></small>
                </li>
            </ol>

            <br><hr><h4>Exemplos práticos (Qiskit):</h4>
            <ol>
                <li>Estado Bell (notebook Python):
<small><pre><code>
# Instalar runtime (via terminal): pip3 install qiskit qiskit-ibm-runtime matplotlib qiskit[visualization] jupyter

# Conexão com IBM Quantum (única vez)
from qiskit_ibm_runtime import QiskitRuntimeService
QiskitRuntimeService.save_account(token="SEU-TOKEN-IBM-QUANTUM-AQUI")

from qiskit import QuantumCircuit
from qiskit.quantum_info import SparsePauliOp
from qiskit.transpiler import generate_preset_pass_manager
from qiskit_ibm_runtime import EstimatorV2 as Estimator, QiskitRuntimeService
service = QiskitRuntimeService()

qc = QuantumCircuit(2) # Cria circuito quântico com 2 qubits
qc.h(0) # Aplica porta Hadamard no qubit 0 (superposição)
qc.cx(0, 1) # Aplica porta CNOT (CX) com qubit 0 controlando qubit 1 (entrelaçamento)
qc.measure_all() # Mede todos qubits
qc.draw("mpl") # Desenha circuito
print(qc)
</code></pre></small>
                </li>
            </ol>
        </div>
    </div>


<!--Rodapé-->
<div class="row">
    <div class="col-sm-12 text-center bg-black text-light pt-4 pb-3">
        <p>Elaborado por Mateus Schwede<br><small class="text-muted">ubsocial.github.io</small></p>
    </div>
</div>

</div>
</body>
</html>