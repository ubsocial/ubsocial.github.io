<!doctype html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" href="../../icons/logoTit.png">
    <link rel="stylesheet" href="../../estilo.css">
    <title>UB Social</title>
</head>
<body>
<div class="container-fluid">


    <div class="row">
        <div class="col-sm-12">
            <nav class="navbar rounded-bottom fixed-top navbar-expand-lg navbar-light bg-light shadow">
                <div class="container-fluid">
                    <a class="navbar-brand" href="../../index.html"><img src="../../icons/logo.png" class="d-inline-block align-text-top" width="11pt"> UB Social</a>
                    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
                    <div class="collapse navbar-collapse" id="navbarNav">
                        <ul class="navbar-nav">
                            <li class="nav-item"><a class="nav-link" href="../../index.html">Home</a></li>
                            <li class="nav-item"><a class="nav-link" href="../../sobre/sobre.html">Sobre</a></li>
                            <li class="nav-item"><a class="nav-link" href="../../cursos.html" id="navCursos">Cursos</a></li>
                            <li class="nav-item"><a class="nav-link" href="../../livros/livros.html">Livros</a></li>
                        </ul>
                    </div>
                </div>
            </nav>
        </div>
    </div>

    <div class="row">
        <div class="col-sm-12 text-center" id="titulo">
            <h1>Estrutura de dados</h1>
            <h6><strong>Modelos e exemplos de estruturas de dados<br><br><span class="badge bg-warning text-dark">Resumo em construção</span></strong><br><br>
            <a href="../../index.html" class="btn btn-link text-decoration-none mb-3">Voltar</a>
        </div>

        <div class="col-sm-12">
            <p id="textoPost">ED consiste na organização de dados na memória de um dispositivo. Dados estruturados da forma correta tendem a trazer melhor desempenho de processamento.</p>
        </div>

        <div class="col-sm-12">
            <hr><p class="text-muted">Vetor e Matriz (Array)</p>
            <p id="textoPost">Consiste em armazenar coleção de elementos do mesmo tipo, onde cada um desses elemenos pode ser identificado e acessado por um índice (<i>index</i>) ou chave (<i>key</i>) relacionado ao mesmo. Exemplos abaixo em Python. Existem outras operações em Arrays, além de CRUD e ordenações, como concatenações, operações matemáticas, entre outros. Porém, dependerá da linguagem de programação utilizada. O tamanho (<i>lenght</i> ou <i>size</i>) do Array é a quantidade total dos índices. O lenght do array pode ser previamente definido com quantidade limitada de índices: Nesse caso, se tentar inserir quantidade de elementos superior à do array, ocorrerá <i>overflow</i>, onde em Stack, denomina-se <i>Stack Overflow</i>.</p>
            <ul>
                <li><b>Vetor</b>: Array de estrutura unidimencional<br>
                    <img src="vetor.png" class="img-fluid rounded" width="230px">
                </li>
                <br>
                <li><b>Matriz</b>: Array de estrutura multidimencional<br>
                    <img src="matriz.jpg" class="img-fluid rounded" width="200px">
                </li>
            </ul>
<small><pre><code>
exemploVetor = ["leão","gato","zebra"]
exemploMatriz = [['Pedro',25],['Maria',19],['João',32]] <span class="text-muted">#Array tridimencional, pois tem 3 dimensões/colunas</span>

print(exemploVetor[2]) <span class="text-muted">#zebra - 3º elemento, pois os índices iniciam-se em 0</span>
print(exemploMatriz[1][0]) <span class="text-muted">#Maria - Linha 1, coluna 0</span>
</code></pre></small>
        </div>

        <div class="col-sm-12">
            <hr><p class="text-muted">Pilha (Stack)</p>
            <p id="textoPost">Coleção ordenada de dados (Estrutura linear), baseada em LIFO (Last In First Out), onde o último elemento que entra (Push) na pilha será o 1º a sair (Pop) do topo. Elementos na base serão os últimos a serem retirados. No exemplo Python abaixo, utilizou-se array para representação.</p>
            <img src="stack.png" class="img-fluid rounded" width="250px">
<small><pre><code>
stack = []

<span class="text-muted">#Simular Push</span>
stack.append('a')
stack.append('b')
stack.append('c')
print(stack)

<span class="text-muted">#Pop simulando LIFO</span>
print('\nElements popped from stack:')
print(stack.pop())
print(stack.pop())
print(stack.pop())
print(stack)
</code></pre></small>
        </div>

        <div class="col-sm-12">
            <hr><p class="text-muted">Fila (Queue)</p>
            <p id="textoPost">Coleção ordenada de dados, baseada em FIFO (First In First Out), onde o 1º elemento que entra (Push/Put/Enqueue) no início (Head ou Rear) será o 1º a sair (Pop/Get/Dequeue) no fim (Tail ou Front).</p>
            <img src="queue.jpg" class="img-fluid rounded" width="300px">
        </div>

        <div class="col-sm-12">
            <hr><p class="text-muted">Grafos (Graph)</p>
            <p id="textoPost">Estrutura de dados que visa trabalhar com relações entre elementos. Um exemplo de grafo, onde há conexão entre elementos, é um mapa de estações de metrô. Grafos consistem em <b>Vértice (nó)</b>, que são os pontos, e <b>Aresta (associação)</b>, que são os traços que ligam os nós. A notação matemática é <b>G = (V,A)</b>, onde G representa o grafo, V os vértices e A as arestas. A segunda imagem abaixo representa uma matriz de adjacência, no qual também pode-se representar, graficamente, um grafo: Os cabeçalhos das linhas e colunas representam os vértices, e as arestas representadas pelos índices internos na matriz (1 reprensenta que há aresta, 0 reprensenta que não há aresta).</p>
            <img src="grafo1.png" class="img-fluid rounded" width="350px">
            <img src="grafo2.png" class="img-fluid rounded" width="168px">

            <br><br>
            <ul>
                <li>
                    <b>Grafo direcionado/dirigido (dígrafo)</b>: Onde há direcionamento específico nas arestas, influenciando no conhecimento/acesso dos vértices (Aresta entre vértices 0 e 1, onde o 0 possui conhecimento/acesso ao 1, mas não o contrário).
                    <br><img src="grafoDirecionado.png" class="img-fluid rounded" width="100px">
                </li>
                <br>
                <li>
                    <b>Grafo não direcionado</b>: Onde não há direcionamento específico nas arestas, ou seja, há conhecimento/acesso de ambos os vértices relacionados (Aresta entre vértices 0 e 1, onde ambos relacionam-se, ou seja, podem ser acessados).
                    <br><img src="grafoNaoDirecionado.png" class="img-fluid rounded" width="100px">
                </li>
            </ul>

            <p id="textoPost"><b>Grau</b>: Quantidade de arestas que saem de um vértice (No grafo não direcionado acima, todos os vértices têm grau 2). Dígrafos diferenciam grau de saída (Arestas que saem do vértice) e grau de entrada (Arestas que chegam no vértice), onde o grau total é a soma de ambos.</p>
            <p id="textoPost"><b>Simetria (Dígrafos simétricos)</b>: Acontece em dígrafos onde, para cada aresta de entrada tem-se uma aresta de saída, além de não possuir autoloop. Ainda, todo grafo não direcionado é simétrico.</p>
            <img src="grafoSimetrico.png" class="img-fluid rounded" width="130px">

            <br><br>
            <ul>
                <li>
                    <b>Grafo simples</b>: Há somente 1 aresta para o mesmo par de vértices.
                    <br><img src="grafoSimples.png" class="img-fluid rounded" width="100px">
                </li>
                <br>
                <li>
                    <b>Multigrafo:</b> Quando há autoloop (Autoloop é aresta do vértice com ele mesmo) e/ou mais de uma aresta em um mesmo par de vértices.
                    <br><img src="multigrafo.png" class="img-fluid rounded" width="250px">
                </li>
                <br>
                <li>
                    <b>Grafo denso</b>: Quando a quantidade de arestas é o quadrado da quantidade de vértices (Exemplo: Grafo com 3 vértices e 9 arestas). Utilizam-se estruturas básicas, como arrays, para representá-los na prática, pois tendem a serem grafos grandes e, portanto, pesados.
                    <br><img src="grafoDenso.png" class="img-fluid rounded" width="150px">
                </li>
                <br>
                <li>
                    <b>Grafo esparso</b>: Quando não é grafo denso.
                    <br><img src="grafoEsparso.png" class="img-fluid rounded" width="130px">
                </li>
            </ul>

            <p id="textoPost"><b>Caminho</b>: Conjunto de arestas que conecta vértices. Quando há caminho entre vértices, denomina-se <b>vértices conexos</b> (Abaixo, A e B são conexos. B e C são desconexos).</p>
            <p id="textoPost"><b>Ciclo</b>: Quando há outro caminho de volta para o vértice de origem, que não retorne pelo mesmo caminho de ida, ou seja, sem repetir vértices utilizados previamente (Abaixo, A e B tem um caminho para ida, e outro de B e A para volta, sem realizar a mesma passagem da ida).</p>
            <img src="grafoCaminho.png" class="img-fluid rounded" width="140px">
            <br><small class="text-muted">* A linha vermelha acima, sob o grafo, é referente ao print da imagem, não tendo relações com o grafo em si.</small>

            <br><br>
            <p id="textoPost"><b><u>Exemplo</u></b>:<br>Implementação, em Java, de criação e busca/percorrimento em grafos, via algoritmo DFS (Deep First Search - Busca em profundidade) e BFS (Breadth First Search - Busca em largura).</p>
            <img src="grafoImplementacao.png" class="img-fluid rounded" width="250px">
            <br><small class="text-muted">* A linha vermelha acima, sob o grafo, é referente ao print da imagem, não tendo relações com o grafo em si.</small>
<small><pre><code>
<b><u>Amigo.java</u> (Classe)</b>:
<span class="text-muted"># O método 'fazerAmizade' relacionará os elementos (Objetos Amigo)</span>
package prod;
import java.util.ArrayList;

public class Amigo {

    private String nome;
    private int grau;
    private ArrayList&lt;Amigo&gt; amigos = new ArrayList&lt;Amigo&gt;();

    public Amigo(String nome) {
        this.nome = nome;
    }

    public void fazerAmizade (Amigo a) {
        if(!isAmigo(a)) {
            amigos.add(a);
            grau += 1;
        }
    }

    public boolean isAmigo (Amigo a) {
        for (Amigo amigo : this.amigos) {
            if (amigo == a)
                return true;
        }
        return false;
    }

    public ArrayList&lt;Amigo&gt; getAmigos(){return this.amigos;}
    public String toString(){return this.nome;}
}


<b><u>GrafoDeAmigos.java</u> (Classe)</b>:
<span class="text-muted"># Onde adiciona as adjacências ao vértice, criando suas arestas (criarAmizadeEntre) e estão os métodos de busca</span>
package prod;
import java.util.ArrayDeque;
import java.util.ArrayList;

public class GrafoDeAmigos {

    ArrayList&lt;Amigo&gt; visitados;

    public void criarAmizadeEntre(Amigo n, Amigo m) {
        n.fazerAmizade(m);
        m.fazerAmizade(n);
    }

    public void DFS (Amigo a) {
        System.out.println("&gt; Busca em Profundidade");
        visitados = new ArrayList&lt;Amigo&gt;();
        realDFS(a);
    }

    public void realDFS (Amigo a) {
        if (!visitados.contains(a)) {
            System.out.println(a.toString());
            visitados.add(a);
            for(Amigo amigo : a.getAmigos()) {
                realDFS(amigo);
            }
        }
    }

    public void BFS (Amigo a) {
        System.out.println("&gt; Busca em Largura");
        ArrayDeque&lt;Amigo&gt; fila = new ArrayDeque&lt;Amigo&gt;();
        visitados = new ArrayList&lt;Amigo&gt;();
        visitados.add(a);
        fila.addFirst(a);
        while(!fila.isEmpty()) {
            Amigo amigo = fila.removeLast();
            for (Amigo iterator : amigo.getAmigos()) {
                if(!visitados.contains(iterator)) {
                    System.out.println(iterator.toString());
                    fila.push(iterator);
                    visitados.add(iterator);
                }
            }
        }
    }
}


<b><u>Faculdade.java</u> (Classe Main)</b>:
<span class="text-muted"># Criação do grafo e, bem abaixo, as duas buscas</span>
package prod;
import javax.management.loading.ClassLoaderRepository;
import java.util.ArrayList;

public class Faculdade {
    public static void main(String[] args) {

        ArrayList&lt;Amigo&gt; amigos = new ArrayList&lt;Amigo&gt;();
        amigos.add(new Amigo("João"));  // 0
        amigos.add(new Amigo("Clarisse"));
        amigos.add(new Amigo("Edivaldo"));
        amigos.add(new Amigo("Maria"));
        amigos.add(new Amigo("Pedro"));
        amigos.add(new Amigo("Gabriella")); // 5
        amigos.add(new Amigo("Marcos"));
        amigos.add(new Amigo("Benedita"));
        amigos.add(new Amigo("Sara"));
        amigos.add(new Amigo("Fernando")); // 9

        GrafoDeAmigos gda = new GrafoDeAmigos();
        gda.criarAmizadeEntre(amigos.get(0), amigos.get(5));
        gda.criarAmizadeEntre(amigos.get(0), amigos.get(1));
        gda.criarAmizadeEntre(amigos.get(5), amigos.get(9));
        gda.criarAmizadeEntre(amigos.get(5), amigos.get(4));
        gda.criarAmizadeEntre(amigos.get(1), amigos.get(4));
        gda.criarAmizadeEntre(amigos.get(1), amigos.get(2));
        gda.criarAmizadeEntre(amigos.get(9), amigos.get(6));
        gda.criarAmizadeEntre(amigos.get(2), amigos.get(8));
        gda.criarAmizadeEntre(amigos.get(8), amigos.get(7));
        gda.criarAmizadeEntre(amigos.get(8), amigos.get(3));
        
        gda.DFS(amigos.get(0));
        gda.BFS(amigos.get(0));
    }
}


<b><u>Conclusão</u>:</b>
Percorrendo, a partir da aresta 0, listará os objetos conforme seus vértices vão sendo percorridos. Utilizando a aresta Edivaldo(2) como destaque de destino, os algoritmos apresentam a ordem de busca de formas diferentes.

&gt; Busca em Profundidade (DFS)
<span class="text-muted">Nesse método, entrará profundamente nos vértices, alcançado primeiramente as arestas nas pontas do grafo.</span>
João
Gabriella
Fernando
Marcos
Pedro
Clarisse
<i>- Edivaldo</i>
Sara
Benedita
Maria

&gt; Busca em Largura (BFS)
<span class="text-muted">Nesse método, geralmente é alcançada a aresta mais próxima do vértice percorrido, onde a busca ocorre por meio de camadas, onde as arestas próximas ao ponto de origem tendem a serem encontradas antes.</span>
Gabriella
Clarisse
Fernando
Pedro
<i>- Edivaldo</i>
Marcos
Sara
Benedita
Maria
</code></pre></small>
        </div>

        <div class="col-sm-12">
            <hr><p class="text-muted">Resumos</p>
            <img src="estr_dados1.jpg" class="img-fluid rounded" width="350px">
            <img src="estr_dados2.jpg" class="img-fluid rounded" width="350px">
        </div>
    </div>


<!--Rodapé-->
<div class="row">
    <div class="col-sm-12 text-center bg-black text-light pt-4 pb-3">
        <p>Elaborado por Mateus Schwede<br><small class="text-muted">ubsocial.github.io</small></p>
    </div>
</div>

</div>
</body>
</html>