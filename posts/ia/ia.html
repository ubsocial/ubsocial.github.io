<!doctype html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" href="../../icons/logoTit.png">
    <link rel="stylesheet" href="../../estilo.css">
    <title>UB Social</title>
</head>
<body>
<div class="container-fluid">


    <div class="row">
        <div class="col-sm-12">
            <nav class="navbar rounded-bottom fixed-top navbar-expand-lg navbar-light bg-light shadow">
                <div class="container-fluid">
                    <a class="navbar-brand" href="../../index.html"><img src="../../icons/logo.png" class="d-inline-block align-text-top" width="11pt"> UB Social</a>
                    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
                    <div class="collapse navbar-collapse" id="navbarNav">
                        <ul class="navbar-nav">
                            <li class="nav-item"><a class="nav-link" href="../../index.html">Home</a></li>
                            <li class="nav-item"><a class="nav-link" href="../../sobre/sobre.html">Sobre</a></li>
                            <li class="nav-item"><a class="nav-link" href="../../livros/livros.html">Livros</a></li>
                        </ul>
                    </div>
                </div>
            </nav>
        </div>
    </div>

    <div class="row">
        <div class="col-sm-12 text-center" id="titulo">
            <h1>Inteligência Artificial</h1>
            <h6><strong>Inteligência Artificial e Machine Learning</strong><br><br><span class="badge bg-warning text-dark">Resumo em construção</span></h6>
            <a href="../../index.html" class="btn btn-link text-decoration-none mb-3">Voltar</a>
        </div>

        <div class="col-sm-12 mb-3">
            <h4>Anexos</h4>
            <ul>
                <li><a class="text-decoration-none" href="https://github.com/mateusschwede/ia/tree/main/iaUdemy" target="_blank">Github do projeto</a></li>
                <li><a class="text-decoration-none" href="https://colab.research.google.com/drive/1SnsJEDRxizpwff6K0JFEFHoBtXR5NT9y?usp=sharing" target="_blank">Códigos (Colab)</a></li>
                <li><a class="text-decoration-none" href="https://www.kaggle.com/laotse/credit-risk-dataset" target="_blank">Dataset risco de crédito (credit data)</a></li>
                <li><a class="text-decoration-none" href="https://archive.ics.uci.edu/ml/datasets/adult" target="_blank">Dataset censo</a></li>
            </ul>
        </div>

        <div class="col-sm-12 mb-3">
            <h4>Sumário</h4>
            <ul>
                <li><a class="text-decoration-none" href="#contIntro">Introdução</a></li>
                <li><a class="text-decoration-none" href="#contClassificacao">Classificação</a>
                    <ul>
                        <li><a class="text-decoration-none" href="#contPreProcessamento">Pré-processamento de dados</a></li>
                        <li><a class="text-decoration-none" href="#contNaiveBayes">Naïve Bayes</a></li>
                        <li><a class="text-decoration-none" href="#contArvoreDecisao">Árvore de decisão (decision tree)</a></li>
                        <li><a class="text-decoration-none" href="#contAprendPorRegras">Aprendizagem por Regras</a></li>
                        <li><a class="text-decoration-none" href="#majorityLearner">Majority learner (ZeroR)</a></li>
                        <li><a class="text-decoration-none" href="#knn">KNN (k-nearest neighbors)</a></li>
                        <li class="text-warning">Sumário em construção</li>
                    </ul>
                </li>
            </ul>
            <img src="datascience_roadmap.jpg" class="img-fluid rounded" width="250px">
        </div>

        <div class="col-sm-12">
            <span class="text-success">
            <h4 id="contIntro">===== INTRODUÇÃO =====</h4>
            <p id="textoPost">Inteligência artificial é a área da ciência da computação responsável pelo desenvolvimento de sistemas que simulem a capacidade humana de resolver problemas. Os principais conceitos/áreas são:</p>
            <ul>
                <li>Inteligência computacional: Redes neurais, computação evolucionária, lógica nebulosa (fuzzy);</li>
                <li>Machine learning (ML, aprendizado de Máquina): Métodos matemáticos para treinar algoritmos;</li>
                <li>Data mining (mineração de dados): Extrair conhecimentos de base de dados, via métodos de machine learning;</li>
                <li>Neural network (rede neural): Tipo de ML, como um algoritmo;</li>
                <li>Deep learning (aprendizado profundo): Muito mais dados e processadores mais potentes (rede neural com muitas camadas);</li>
                <li>Big data: Imenso volume de dados (necessário algoritmos de ML para tratamento dos dados);</li>
                <li>Data analytics (análise de dados): Inspeção, transformação e modelagem de dados, a fim de obter informações e insights sobre;</li>
                <li>Data science (ciência de dados): Exploração e análise de dados (data analytics), envolvendo ciência da computação + estatística, além de ML.</li>
            </ul>
            <img src="areas_ia.jpg" class="img-fluid rounded" width="400px"><br>

            <br><h4>Machine learning</h4>
            Tipos de ML:
            <ul>
                <li><b>Supervisonada</b> (classificação e regressão);</li>
                <li><b>Não Supervisonada</b> (associação, agrupamento, detecção de outliers, padrões sequenciais e sumarização);</li>
                <li><b>Reforço</b>.</li>
            </ul>
            Métodos preditivos: Previsão resultante de conjunto de atributos.
            <ul>
                <li><b>Classificação</b>: Dividir atributos por determinadas classes (rótulos). Ex: pessoas que gostam de rock e pessoas que não gostam de rock;</li>
                <li><b>Regressão</b>: Previsão realizada através da análise de valores numéricos, como dados históricos. Ex: com base em valores climáticos, medir previsão do tempo.</li>
            </ul>
            Métodos descritivos:
            <ul>
                <li><b>Associação</b>: Dados em comum (ex: maior histórico de compra de item x nos sábados);</li>
                <li><b>Agrupamento</b>: Agrupar dados em comum (ex: grupo de games de ação, grupo de games de terror);</li>
                <li><b>Detecção de outliers</b> (desvios): Detectar anomalias em grupos de dados (ex: atletas em doping - desempenhando além do normal);</li>
                <li><b>Descoberta de padrões sequenciais</b>: Detectar relações entre grupos de dados (ex: leitor de Harry Potter tende a gostar de livros de Harry Potter);</li>
                <li><b>Sumarização</b>: Abstrair dados de um grupo maior, conforme atributos solicitados (ex: BD de clientes, exibir somente cliente maiores de 50 anos);</li>
            </ul>

            <p>Aprendizagem supervisionada: Classificar se foto refere-se ao Homer ou Bart Simpson. Fase 1 (treino), extraem-se as características de Homer e Bart (montagem do dataset - tabela com dados), após executa-se algoritmo ML (via supervisor), criando-se padrões de Homer e Bart, então tem-se modelo aprendido (distingue-se fotos de Homer e Bart). Fase 2 (teste), sumete-se foto desconhecida, para modelo distinguir se é Homer ou Bart. Fases treino/teste são denominados validação cruzada.</p>
            <p>Aprendizagem não supervisionada: Análise automática dos dados (associação, agrupamento), sem supervisão, nem treinamento prévio (predição). Necessita somente descrição dos dados (descritiva) e análise para determinar significado dos padrões encontrados (verificar se resultados são pertinentes). Ex: se pessoa que compra x também compra y, então pessoas que comprarão x também comprarão y.</p>
            <p>Aprendizagem por reforço: Aprender com interações do ambiente (causa e efeito), via experiência própria. Muito utilizada em SMA (sistema multiagente, com vários agentes interagindo no ambiente). Ex: robô automatizado bate em parede e danifica-se. Então, concluirá que deve evitar bater em paredes.</p>
            
            <br><u>Etapas modelo preditivo</u>:
            <ol>
                <li>Coleta de dados (via BD, CSV, big data, etc);</li>
                <li>Exploração e preparação dos dados (criação do algoritmo para tal);
                    <ol>
                        <li>Importar bibliotecas;</li>
                        <li>Upload do dataset e exploração dos dados brutos;</li>
                        <li>Visualização dos atributos ordenadamente e em gráficos, a fim de encontrar relações entre previsores;</li>
                        <li>Domain, separação entre previsores(x) e classes(y);</li>
                        <li>Tratamento dos dados (valores faltantes, valores inconsistentes(outliers, normalization, standardisation, tipos diferentes));</li>
                        <li>Divisão dados treinamento (x_train(previsores), y_train(classes)) e teste (x_test(previsoes) e y_test(classes));</li>
                        <li>Criação do algoritmo IA.</li>
                    </ol>
                </li>
                <li>Treinamento do modelo (submeter dados de treinamento (x_train e y_train) ao algoritmo IA);</li>
                <li>Avaliação do modelo (comparar dados submetidos de treinamento (x_train e y_train), com dados de teste (x_test e y_test), para identificar precisão de acerto do algoritmo IA);</li>
                <li>Otimização do modelo (otimizar algoritmo IA, com melhores dados de treinamento, re-verificar precisão do algoritmo IA).</li>
            </ol>
            </span>

            <br><u>Termos chave</u>:
            <ul>
                <li>Outliers: Dados com muita discrepância de valor (necessário tratamento);</li>
                <li>Normalization: Colocar dados entre intervalo de valores menor, como 0 e 1, ou -1 e 1 (caso haja valores negativos), sem distorcer diferenças nas faixas de valores (diminuir discrepância de valores). Não indicado para corrigir outliers. Ideal para aplicação quando distribuição não é Gaussiana ou desvio padrão é muito pequeno. Garante maior accuracy ao modelo;</li>
                <li>Standardisation: Colocar média dos dados em 0 e o desvio padrão em 1. Melhor utilizado em distribuição Gaussiana. Mais indicado para tratamento de outliers. Garante maior accuracy ao modelo;</li>
                <li>Gráficos, geralmente eixo y (vertical) e eixo x (horizontal). Normalization e standardisation achatam gráfico horizontalmente (eixo x). Remoção de outliers reduzem gráfico verticalmente (eixo y);</li>
                <li>Algoritmos que precisam dos dados na mesma escala: KNN (K-Nearest Neighbours), Redes Neurais, Regressão Linear, Regressão Logística e SVM;</li>
                <li>Algoritmos que não precisam dos dados na mesma escala: Árvores de Decisão, Random Forest, AdaBoost, Naïve Bayes, etc (porém, aconselhável testar a normalização ou padronização);</li>
                <li>Evaluation: Avaliação do algoritmo ML, nível de desempenho (acerto) do modelo;</li>
                <li>LabelLabelEncoder: Tratamento de valores categóricos (string), onde cada tipo de valor no registro será transformado em um número de referência. Problema de somente utilizar LabelEncoder são as inúmeras categorias e valores muito amplos (algoritmo de IA considerará atributo 20 mais importante que 3, pois 20 > 3);</li>
                <li>OneHotEncoder: Tratamento de valores categóricos (string), onde cada tipo de registro (category) receberá um nº identificador (do tipo Dummy), de acordo com a quantidade de tipos de registros neste atributo (Ex: carros Gol, Pálio e Uno: 3 tipos de registros do atributo 'carro', então Gol = 100, Pálio = 010 e Uno = 001).</li>
                <li>ConfusionMatrix: Matriz de confusão (matriz de erro) é tabela (contingência 2x2 especial) que permite visualização do desempenho do algoritmo de classificação. Bidimensional: 2 dimensões ("real" e "prevista"), onde linhas (eixo x) são instâncias de uma classe prevista, e colunas (eixo y) são instâncias da classe real;
                    <ul>
                        <li>Exemplo: sendo 0 não chove, e 1 chove, tem-se reais = [1,0,1,0,0,0,1,0,1,0] e preditos = [1,0,0,1,0,0,1,1,1,0];</li>
                        <li>Frequência verdadeiro positivo (true positive - TP): Classe buscada prevista corretamente no conjunto real. Ex: quando realmente chove e o modelo previu corretamente que chove;</li>
                        <li>Frequência falso positivo (false positive - FP): Classe buscada prevista incorretamente no conjunto real. Ex: quando realmente não chove, mas modelo previu que chove;</li>
                        <li>Frequência falso verdadeiro/Verdadeiro negativo (true negative - TN): Classe não buscada prevista corretamente no conjunto real. Ex: realmente não chove e o modelo previu corretamente que não chove;</li>
                        <li>Frequência falso negativo (false negative - FN): Classe não buscada prevista incorretamente no conjunto real. Ex: realmente chove e o modelo previu que não chove.</li>
                        <li>Exemplo 2: sendo 0 não chove, e 1 chove, tem-se eais = [1,0,1,0,0,0,1,0,1,0] e preditos = [1,0,0,1,0,0,1,1,1,0]
                            <ul>
                                <li>Previu chove 3 vezes corretamente;</li>
                                <li>Previu não chove 4 vezes corretamente;</li>
                                <li>Previu chove 1 vez incorretamente;</li>
                                <li>EM CONSTRUÇÃO</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>


            <br><hr><h4 id="contClassificacao">===== CLASSIFICAÇÃO =====</h4>
            <p id="textoPost" class="text-success">Conforme exemplo análise de risco de crédito. Cada registro (linha) possui atributos (colunas) previsores (características) e atributos classe (resultado). Na aprendizagem supervisionada, a classe sempre é conhecida.</p>
            <ul class="text-success">
                <li><b>Atributos previsores</b> (variáveis dependentes): Histórico de crédito (bom, ruim, desconhecido), dívida (baixa, alta), garantias (nenhuma, adequada), renda anual (menor que 15 mil, entre 15 mil e 35 mil, maior que 35 mil);</li>
                <li><b>Atributos meta/classe</b> (variáveis independentes): risco (baixo, moderado, alto).</li>
            </ul>
            <div class="table-responsive">
                <table class="table table-striped table-sm">
                    <thead>
                        <tr>
                            <th scope="col" class="table-primary">Histórico de crédito</th>
                            <th scope="col" class="table-primary">Dívida</th>
                            <th scope="col" class="table-primary">Garantias</th>
                            <th scope="col" class="table-primary">Renda anual</th>
                            <th scope="col" class="table-warning">Risco</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Ruim</td>
                            <td>Alta</td>
                            <td>Nenhuma</td>
                            <td>Menos de 15 mil</td>
                            <th>Alto</th>
                        </tr>
                        <tr>
                            <td>Desconhecido</td>
                            <td>Baixo</td>
                            <td>Nenhuma</td>
                            <td>Entre 15 mil e 35 mil</td>
                            <th>Moderado</th>
                        </tr>
                        <tr>
                            <td>Desconhecido</td>
                            <td>Baixo</td>
                            <td>Adequada</td>
                            <td>Maior que 35 mil</td>
                            <th>Baixo</th>
                        </tr>
                    </tbody>
                </table>
            </div>

            <br><h4 id="contPreProcessamento">----- Pré-processamento de dados -----</h4>
            <span class="text-success">Variáveis numéricas:
            <ul>
                <li>contínua: nºs reais (temperatura 30.2);</li>
                <li>discreta: conjunto finito, valores inteiros (preços [12,4,6], idade 25);</li>
            </ul>
            Variáveis categóricas:
            <ul>
                <li>nominal: dados não mensuráveis, sem ordenação (gênero);</li>
                <li>ordinal: dados ordenados categorizados (tamanhos p,m,g). Convertidas para discretas via categorias numéricas (p=1,m=2,g=3)</li>
            </ul></span>

            <b>1. Importar bibliotecas:</b>
<small><pre><code>
import pandas as pd #gerenciar csv
import numpy as np #computação científica
import seaborn as sns #gráficos
import matplotlib.pyplot as plt #gráficos
import plotly.express as px
</code></pre></small>

            <br><h5>Dataset risco de crédito (credit data)</h5>
            <p>Objetivo da IA é informar se cliente, conforme condições, pagará (default 0) ou não (default 1) o crédito.</p>
            <div class="table-responsive">
                <table class="table table-bordered table-sm">
                    <thead>
                        <tr>
                            <th scope="col" class="table-secondary"></th>
                            <th scope="col" class="table-secondary">clientid</th>
                            <th scope="col" class="table-secondary">income</th>
                            <th scope="col" class="table-secondary">age</th>
                            <th scope="col" class="table-secondary">loan</th>
                            <th scope="col" class="table-secondary">default</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <th>0</th>
                            <td>1</td>
                            <td>66155.925095</td>
                            <td>59.017015</td>
                            <td>8106.532131</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <th>4</th>
                            <td>5</td>
                            <td>66952.688845</td>
                            <td>18.584336</td>
                            <td>8770.099235</td>
                            <td>1</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <p><b>2. Exploração dos dados:</b></p>
<small><pre><code>
base_credit = pd.read_csv('/content/credit_data.csv') #upload do arquivo CSV (atente-se ao local do upload '/content/')
base_credit #ver dados
base_credit_head(10) #ver 10 primeiros dados
base_credit.tail(8) #ver 8 últimos dados
base_credit.describe() #mostrar, para cada atributo numérico: count (quantidade total), mean (média), sid (desvio padrão - variação/afastamento dos dados em relação ao valor da média), min/25%/50%/75%/max (quartis - valores mínimos/percentuais/máximos)
base_credit[base_credit['income'] == 1000.00] #mostrar pessoa com renda 1000.00
base_credit[base_credit['loan'] &gt;= 1.377] #mostrar pessoa com dívida menor ou igual a 1.377
</code></pre></small>
            
            <p><b>3. Visualização em gráficos:</b></p>
<small><pre><code>
np.unique(base_credit['default']) #mostrar tipos de valores do 'default'
np.unique(base_credit['default'], return_counts=True) #quantidades de valores do 'default'
sns.countplot(x = base_credit['default']); #gráfico de contagem (img1)
plt.hist(x = base_credit['age']); #histograma intervalos de 'age' (img2)
plt.hist(x = base_credit['income']); #histograma 'income' (img3)
plt.hist(x = base_credit['loan']); #histograma 'loan' (img4)

grafico = px.scatter_matrix(base_credit, dimensions=['age','income','loan'], color='default') #gráfico scatter (dispersão), combina atributos conforme 'default' (coloração interna)
grafico.show()
</code></pre></small>
            <img src="snsGrafico1.jpg" title="sns.countplot(x = base_credit['default'])" class="img-fluid rounded" width="230px">
            <img src="pltGrafico1.jpg" title="plt.hist(x = base_credit['age'])" class="img-fluid rounded" width="230px">
            <img src="pltGrafico2.jpg" title="plt.hist(x = base_credit['income'])" class="img-fluid rounded" width="230px">
            <img src="pltGrafico3.jpg" title="plt.hist(x = base_credit['loan'])" class="img-fluid rounded" width="230px">
            <br><img src="pxGrafico1.jpg" title="px.scatter_matrix" class="img-fluid rounded" width="800px">

            <p><b>4.1. Tratamento de valores inconsistentes:</b></p>
<small><pre><code>
base_credit.loc[base_credit['age'] &lt; 0] #ver dados com idades negativas

#apagar coluna inteira do dado inconsistente
base_credit2 = base_credit.drop('age', axis=1) #axis0 é linha e axis1 é coluna
base_credit2
base_credit.index #index é o id do dado
base_credit[base_credit['age'] &lt; 0].index</code>

#apagar células de dados inconsistentes
base_credit3 = base_credit.drop(base_credit[base_credit['age'] &lt; 0].index)
base_credit3
base_credit3.loc[base_credit3['age'] &lt; 0] #dados removidos

#preencher dados inconsistentes manualmente, com média
base_credit.mean() #localizar média de valores (ou base_credit['age'].mean())
base_credit['age'][base_credit['age'] &gt; 0].mean() #média não considerando negativos
base_credit.loc[base_credit['age'] &lt; 0, 'age'] = 40.92 #preencher idades negativas com média de idades
base_credit.loc[base_credit['age'] &lt; 0] #verificar se há idades negativas
</code></pre></small>

            <p><b>4.2. Tratamento de valores faltantes:</b></p>
<small><pre><code>
base_credit.isnull() #verificar se há dados faltantes (true é faltante)
base_credit.isnull().sum() #quantidade de dados faltantes
base_credit.loc[pd.isnull(base_credit['age'])] #linhas com idade faltante

#preencher valores faltantes com média
base_credit['age'].fillna(base_credit['age'].mean(), inplace=True) #preencher com média
base_credit.loc[pd.isnull(base_credit['age'])] #verificar se há idades faltantes
base_credit.loc[(base_credit['clientid']==29) | (base_credit['clientid']==31) | (base_credit['clientid']==32)]
base_credit.loc[base_credit['clientid'].isin([29,31,32])]
</code></pre></small>

            <p><b>5. Separação entre previsores e classes:</b></p>
            <p>x armazena previsores (income, age, loan) e y armazena classe (default). Geralmente id's são descartados.</p>
<small><pre><code>
X_credit = base_credit.iloc[:,1:4].values #':' seleciona todas linhas do dataset, '1:4' seleciona 1 até 3
y_credit = base_credit.iloc[:, 4].values #somente coluna 4
X_credit #ver conteúdo da variável ('y_credit' ver y, 'type(X_credit)' ver tipo)
</code></pre></small>

            <p><b>6. Escalonamento dos atributos:</b></p>
            <p>Quando discrepância de valores do dataset é muito grande, deve-se deixá-los na mesma escala, via padronização.</p>
            <ul>
                <li>Padronização(standardisation): <span style="color: red;">x = ((x-media(x)) / desvioPadrao(x))</span></li>
                <li>Normalização(normalization): <span style="color: red;">x = ((x-min(x)) / (max(x)-min(x)))</span></li>
            </ul>
<small><pre><code>
X_credit[:,0].min(), X_credit[:,1].min(), X_credit[:,2].min() #selecionar valores mínimos de cada atributo
X_credit[:,0].max(), X_credit[:,1].max(), X_credit[:,2].max() #Selecionar valores máximos de cada atributo

from sklearn.preprocessing import StandardScaler #library para ML, StandardScaler fará padronização
scaler_credit = StandardScaler()
X_credit = scaler_credit.fit_transform(X_credit)

X_credit[:,0].min(), X_credit[:,1].min(), X_credit[:,2].min() #valores padronizados (não há problema de valores negativos, pois considera-se uso da média e desvio padrão)
X_credit[:,0].max(), X_credit[:,1].max(), X_credit[:,2].max()
X_credit
</span>
</code></pre></small>
            
            <br><h5>Datacet censo</h5>
            <p>Objetivo da IA é informar se pessoa, conforme condições, ganhará ou não mais que 50mil por ano (income).</p>
            <div class="table-responsive">
                <table class="table table-bordered table-sm">
                    <thead>
                        <tr>
                            <th scope="col" class="table-secondary"></th>
                            <th scope="col" class="table-secondary">age</th>
                            <th scope="col" class="table-secondary">workclass</th>
                            <th scope="col" class="table-secondary">final-weight</th>
                            <th scope="col" class="table-secondary">education</th>
                            <th scope="col" class="table-secondary">education-num</th>
                            <th scope="col" class="table-secondary">marital-status</th>
                            <th scope="col" class="table-secondary">occupation</th>
                            <th scope="col" class="table-secondary">relationship</th>
                            <th scope="col" class="table-secondary">race</th>
                            <th scope="col" class="table-secondary">sex</th>
                            <th scope="col" class="table-secondary">capital-gain</th>
                            <th scope="col" class="table-secondary">capital-loos</th>
                            <th scope="col" class="table-secondary">hour-per-week</th>
                            <th scope="col" class="table-secondary">native-country</th>
                            <th scope="col" class="table-secondary">income</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <th>0</th>
                            <td>39</td>
                            <td>State-gov</td>
                            <td>77516</td>
                            <td>Bachelors</td>
                            <td>13</td>
                            <td>Never-married</td>
                            <td>Adm-clerical</td>
                            <td>Not-in-family</td>
                            <td>White</td>
                            <td>Male</td>
                            <td>2174</td>
                            <td>0</td>
                            <td>40</td>
                            <td>United-States</td>
                            <td>&lt;=50K</td>
                        </tr>
                        <tr>
                            <th>32556</th>
                            <td>27</td>
                            <td>Private</td>
                            <td>257302</td>
                            <td>Assoc-acdm</td>
                            <td>12</td>
                            <td>Married-civ-spouse</td>
                            <td>Tech-support</td>
                            <td>Wife</td>
                            <td>White</td>
                            <td>Female</td>
                            <td>0</td>
                            <td>0</td>
                            <td>38</td>
                            <td>United-States</td>
                            <td>&lt;=50K</td>
                        </tr>
                        <tr>
                            <th>32557</th>
                            <td>40</td>
                            <td>Private</td>
                            <td>154374</td>
                            <td>HS-grad</td>
                            <td>9</td>
                            <td>Married-civ-spouse</td>
                            <td>Machine-op-inspct</td>
                            <td>Husband</td>
                            <td>White</td>
                            <td>Male</td>
                            <td>0</td>
                            <td>0</td>
                            <td>40</td>
                            <td>United-States</td>
                            <td>&gt;50K</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <p><b>2. Exploração dos dados:</b></p>
<small><pre><code>
base_census = pd.read_csv('/content/census.csv')
base_census48.000000
base_census.describe()
base_census.isnull().sum() #verificar se há valores faltantes
</code></pre></small>

            <p><b>3. Visualização em gráficos:</b></p>
<small><pre><code>
np.unique(base_census['income'], return_counts=True)
sns.countplot(x = base_census['income']); #gráfico de barras (img1)
plt.hist(x = base_census['age']); #histograma de idades (img2)
plt.hist(x = base_census['education-num']); #histograma de anos estudados (img3)
plt.hist(x = base_census['hour-per-week']); #histograma de horas trabalhadas por semana (img4)

grafico = px.treemap(base_census, path=['workclass','age'])
grafico.show() #gráficos agrupamentos entre classe de trabalho e idade (img5)

grafico = px.treemap(base_census, path=['occupation','relationship','age'])
grafico.show() #gráficos agrupamentos entre ocupação, relacionamento e idade (img6)

grafico = px.parallel_categories(base_census, dimensions=['occupation','relationship'])
grafico.show() #gráfico categorias paralelas entre ocupação e relacionamento (img7)

grafico = px.parallel_categories(base_census, dimensions=['workclass','occupation','income'])
grafico.show() #gráfico categorias paralelas entre classe de trabalho, ocupação e renda (img8)

grafico = px.parallel_categories(base_census, dimensions=['education','income'])
grafico.show() #gráfico categorias paralelas entre educação e renda (img9)
</code></pre></small>
            <img src="snsGrafico2.jpg" title="sns.countplot(x = base_census['income'])" class="img-fluid rounded" width="230px">
            <img src="pltGrafico4.jpg" title="plt.hist(x = base_census['age'])" class="img-fluid rounded" width="230px">
            <img src="pltGrafico5.jpg" title="plt.hist(x = base_census['education-num'])" class="img-fluid rounded" width="230px">
            <img src="pltGrafico6.jpg" title="plt.hist(x = base_census['hour-per-week'])" class="img-fluid rounded" width="230px">
            <br><img src="pxGrafico2.jpg" title="px.treemap(base_census, path=['workclass','age'])" class="img-fluid rounded" width="700px">
            <br><img src="pxGrafico3.jpg" title="px.treemap(base_census, path=['occupation','relationship','age'])" class="img-fluid rounded" width="700px">
            <br><img src="pxGrafico4.jpg" title="px.parallel_categories(base_census, dimensions=['occupation','relationship'])" class="img-fluid rounded" width="700px">
            <br><img src="pxGrafico5.jpg" title="px.parallel_categories(base_census, dimensions=['workclass','occupation','income'])" class="img-fluid rounded" width="600px">
            <br><img src="pxGrafico6.jpg" title="px.parallel_categories(base_census, dimensions=['education','income'])" class="img-fluid rounded" width="600px">
            
            <p><b>4. Separação entre previsores e classes:</b></p>
<small><pre><code>
base_census.columns
X_census = base_census.iloc[:,0:14].values #criar variável previsores (age à native-country)
X_census #X_census[0]
y_census = base_census.iloc[:,14].values #criar variável classe (income)
y_census
</code></pre></small>

            <p><b>5.1. Tratamento de atributos categóricos (LabelEncoder):</b></p>
            <p>Transformar dados texto em numéricos. LabelEncoder transformará cada dado em nº de referência.</p>
<small><pre><code>
from sklearn.preprocessing import LabelEncoder
label_encoder_teste = LabelEncoder()
X_census[:,1]
teste = label_encoder_teste.fit_transform(X_census[:,1])
teste #cada tipo do workclass será nº de referência (private é 4, state-gov é 7, etc)
X_census[0]

#transformar cada atributo
label_encoder_workclass = LabelEncoder()
label_encoder_education = LabelEncoder()
label_encoder_marital = LabelEncoder()
label_encoder_occupation = LabelEncoder()
label_encoder_relationship = LabelEncoder()
label_encoder_race = LabelEncoder()
label_encoder_sex = LabelEncoder()
label_encoder_country = LabelEncoder()

#aplicar LabelEncoder em cada atributo categórico
X_census[:,1] = label_encoder_workclass.fit_transform(X_census[:,1])
X_census[:,3] = label_encoder_education.fit_transform(X_census[:,3])
X_census[:,5] = label_encoder_marital.fit_transform(X_census[:,5])
X_census[:,6] = label_encoder_occupation.fit_transform(X_census[:,6])
X_census[:,7] = label_encoder_relationship.fit_transform(X_census[:,7])
X_census[:,8] = label_encoder_race.fit_transform(X_census[:,8])
X_census[:,9] = label_encoder_sex.fit_transform(X_census[:,9])
X_census[:,13] = label_encoder_country.fit_transform(X_census[:,13])

X_census[0]
X_census
</code></pre></small>

            <p><b>5.2. Tratamento de atributos categóricos (OneHotEncoder):</b></p>
            <p>LabelEncoder pode criar inúmeras categorias amplas. OneHotEncoder cada registro (categoria) recebe id tipo Dummy, conforme quantidade de tipos específicos de registros.</p>
<small><pre><code>
len(np.unique(base_census['workclass'])) #9 categorias diferentes
len(np.unique(base_census['occupation'])) #15 categorias diferentes

from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer

onehotencoder_census = ColumnTransformer(transformers=[('OneHot', OneHotEncoder(), [1,3,5,6,7,8,9,13])], remainder='passthrough') #passthrough não exlcui demais atributos com categorias repetidas
X_census = onehotencoder_census.fit_transform(X_census).toarray() #recriar dataset tratado
X_census #X_census[0]
X_census.shape #resultante da soma das quantidades de colunas de cada categoria, de cada atributo
</code></pre></small>

            <p><b>6. Escalonamento dos atributos:</b></p>
<small><pre><code>
from sklearn.preprocessing import StandardScaler

scaler_census = StandardScaler()
X_census = scaler_census.fit_transform(X_census)
X_census[0] #converter atributos numéricos para mesmo formato
</code></pre></small>

            <!------------------>
            <br><h5>Introdução a avaliação de algoritmos</h5>
            <p id="textoPost">Levando em conta o exemplo da base de dados Risco de Crédito, o algoritmo de IA analisará os atributos previsores, juntamente com seus respectivos dados, gerando assim o <b>Modelo do Algoritmo</b>, como, por exemplo, um algoritmo Naïve Bayes criará uma tabela de probabilidade, para que, quando quiser classificar registros, utilizará estimativa da probabilidade de cada classe (<u>Ex</u>: Probabilidade da classe Risco alto, moderado e baixo). Um algoritmo de Árvore de Decisão, conforme dados analisados, construirá árvore de decisão, que será percorrida cada vez para identificar a decisão, onde tal nó final será a classe.</p>
            <p id="textoPost">Após isso, para fazer a classificação de novos registros à base de dados, submete-se o mesmo para o Modelo do Algoritmo e gerará, com isso, a resposta da classificação. Para sabe a classe que ao qual o registro será classificado, tem-se a <b>base de dados de treinamento</b> e a <b>base de dados de teste</b>, onde, em ambas, a classe de resultado já está informada e os registros são bem diferentes quando comparados uma a outra (Nunca pode testar o algoritmo com os mesmos registros de seu treinamento). Então, submete-se a base de dados do treinamento ao algoritmo (Base de dados de treinamento sempre é bem maior que a de teste), onde o algoritmo gerará o Modelo. Após isso, testa-se o algoritmo conferindo seus resultados com a base de dados de teste (Base bem diversificada, para a maioria de possibilidades em teste).</p>
            <p id="textoPost">Com o teste pronto, o supervisor saberá identificar, usando como base os registros de teste, quantos o algoritmo acertou e errou (<u>Ex</u>: O 1º registro está classificado na base de teste como alto, e o algoritmo identificou como Alto (<i>Acerto</i>). O 2º registro está classificado na base de teste como Moderado, e o algoritmo identificou como Baixo (<i>Erro</i>)). Assim, medindo acertos/erros em percentuais, tem-se a medição da eficiência do algoritmo de IA.</p>
            <p><b>7. Divisão das bases em treinamento e teste:</b></p>
<small><pre><code>
from sklearn.model_selection import train_test_split

<span class="text-muted">#Dividir base Risco de Crédito</span>
X_credit_treinamento, X_credit_teste, y_credit_treinamento, y_credit_teste = train_test_split(X_credit,y_credit,test_size = 0.25,random_state = 0) <span class="text-muted">#X: previsores e Y: classe. Tamanho da base de Teste será 0.25 (75% da base de dados para treinar, 25% para testar), random_state para manter registros de trainamento/teste e consguir compará-los</span>
X_credit_treinamento.shape <span class="text-muted">#1500 registros previsores para treinamento, 3 colunas (income,age,loan)</span>
y_credit_treinamento.shape <span class="text-muted">#1500 registros classe, somente coluna default</span>
X_credit_teste.shape, y_credit_teste.shape <span class="text-muted">#25% dos dados total para cada variável da base teste (X previsores, Y respostas/classe)</span>

<span class="text-muted">#Dividir base Censo</span>
X_census_treinamento, X_census_teste, y_census_treinamento, y_census_teste = train_test_split(X_census,y_census,test_size = 0.15,random_state = 0) <span class="text-muted">#85% dos registros para base Treinamento, 15% para base Teste</span>
X_census_treinamento.shape, y_census_treinamento.shape <span class="text-muted">#27676 registros previsores, 108 colunas. 27676 registros de resposta/classe</span>
X_census_teste.shape, y_census_teste.shape <span class="text-muted">#4855 registros previsores, 108 colunas. 4855 registros de resposta/classe</span>
</code></pre></small>

            <p><b>Salvar bases:</b></p>
<small><pre><code>
import pickle

<span class="text-muted">#Salvar em disco, wb (Write): Criará arquivos 'credit.pkl' e 'census.pkl'</span>
with open('credit.pkl', mode='wb') as f:
    pickle.dump([X_credit_treinamento, y_credit_treinamento, X_credit_teste, y_credit_teste], f)

with open('census.pkl', mode='wb') as f:
    pickle.dump([X_census_treinamento, y_census_treinamento, X_census_teste, y_census_teste], f)
</code></pre></small>

            <br>
            <h4 id="contNaiveBayes">----- Naïve Bayes -----</h4>
            <p id="textoPost">Algoritmo bastante utilizado em mineração de texto (Filtragem de spam, emoção do narrador com relação à sua frase, separação de documentos, etc), baseado em probabilidade (Teorema de Bayes). Usando o exemplo da Base de Crédito, o algoritmo criará a tabela de probabilidade (Conforme abaixo), baseado no histórico de dados. Na tabela, o Risco de Crédito é o atributo Classe. A cada nova submissão para descobrir qual o risco de crédito, os atributos previsores deverão ser submetidos à essa tabela</p>
            <p><b>Montagem da tabela de probabilidade:</b></p>
            <p id="textoPost">Para tal, precisa-se fazer a contagem do risco, onde a classe (Risco de Crédito) fica à esquerda superior, seguida de seus atributos. Conforme histórico de 14 ítens, tem-se 6 considerados 'Alto' (6/14), 3 'Moderado' e 5 'Baixo'. Baseando-se no Risco de Crédito, tem-se 5 'Boa', 5 'Desconhecida' e 4 'Ruim'. Com isso, intercalando os valores nas intersecções, analisa-se quantas vezes tem-se História de crédito 'Boa' e Risco 'Alto' (1/6, onde 1 é 'Boa' e 'Alto', e 6 o valor total de 'Altos'), seguindo respectivamente, para os demais atributos nessa mesma lógica. Então, a soma de todos os numeradores preenchidos deve ser igual ao valor total no valor da classe na situação em questão (5 'Boa', conforme tabela). Na mesma lógica, a soma dos numeradores para cada valor do atributo da classe, com relação ao seu valor total naquela situação, deve ser a mesma com seu valor total (6 'Alto', conforme tabela).</p>
            <div class="table-responsive">
                <table class="table table-striped table-sm table-bordered text-center align-middle">
                    <thead>
                        <tr>
                            <th scope="col" class="table-primary"></th>
                            <th scope="col" class="table-primary" colspan="3">História do Crédito</th>
                            <th scope="col" class="table-primary" colspan="2">Dívida</th>
                            <th scope="col" class="table-primary" colspan="2">Garantias</th>
                            <th scope="col" class="table-primary" colspan="3">Renda anual</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <th scope="col" class="table-primary">Risco de crédito<br><span class="text-muted">14</span></th>
                            <td>Boa<br><span class="text-muted">5</span></td>
                            <td>Desconhecida<br><span class="text-muted">5</span></td>
                            <td>Ruim<br><span class="text-muted">4</span></td>
                            <td>Alta<br><span class="text-muted">7</span></td>
                            <td>Baixa<br><span class="text-muted">7</span></td>
                            <td>Nenhuma<br><span class="text-muted">11</span></td>
                            <td>Adequada<br><span class="text-muted">3</span></td>
                            <td>&lt;15000<br><span class="text-muted">3</span></td>
                            <td>&gt;=15000 a &lt;=35000<br><span class="text-muted">4</span></td>
                            <td>&gt;35000<br><span class="text-muted">7</span></td>
                        </tr>
                        <tr>
                            <td scope="col" class="table-secondary">Alto<br><span class="text-muted">6/14</span></td>
                            <td>1/6</td>
                            <td>2/6</td>
                            <td>3/6</td>
                            <td>4/6</td>
                            <td>2/6</td>
                            <td>6/6</td>
                            <td>0/6</td>
                            <td>3/6</td>
                            <td>2/6</td>
                            <td>1/6</td>
                        </tr>
                        <tr>
                            <td scope="col" class="table-secondary">Moderado<br><span class="text-muted">3/14</span></td>
                            <td>1/3</td>
                            <td>1/3</td>
                            <td>1/3</td>
                            <td>1/3</td>
                            <td>2/3</td>
                            <td>2/3</td>
                            <td>1/3</td>
                            <td>0/3</td>
                            <td>2/3</td>
                            <td>1/3</td>
                        </tr>
                        <tr>
                            <td scope="col" class="table-secondary">Baixo<br><span class="text-muted">5/14</span></td>
                            <td>3/5</td>
                            <td>2/5</td>
                            <td>0/5</td>
                            <td>2/5</td>
                            <td>3/5</td>
                            <td>3/5</td>
                            <td>2/5</td>
                            <td>0/5</td>
                            <td>0/5</td>
                            <td>5/5</td>
                        </tr>
                    </tbody>
                </table>
                <table class="table table-striped table-sm table-bordered text-center" id="tabRiscoCredito">
                    <thead>
                        <tr>
                            <th scope="col" class="table-primary">História do Crédito</th>
                            <th scope="col" class="table-primary">Dívida</th>
                            <th scope="col" class="table-primary">Garantias</th>
                            <th scope="col" class="table-primary">Renda anual</th>
                            <th scope="col" class="table-warning">Risco</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Ruim</td>
                            <td>Alta</td>
                            <td>Nenhuma</td>
                            <td>&lt;15000</td>
                            <td>Alto</td>
                        </tr>
                        <tr>
                            <td>Desconhecida</td>
                            <td>Alta</td>
                            <td>Nenhuma</td>
                            <td>&gt;=15000 a &lt;=35000</td>
                            <td>Alto</td>
                        </tr>
                        <tr>
                            <td>Desconhecida</td>
                            <td>Baixa</td>
                            <td>Nenhuma</td>
                            <td>&gt;=15000 a &lt;=35000</td>
                            <td>Moderado</td>
                        </tr>
                        <tr>
                            <td>Desconhecida</td>
                            <td>Baixa</td>
                            <td>Nenhuma</td>
                            <td>&gt;35000</td>
                            <td>Alto</td>
                        </tr>
                        <tr>
                            <td>Desconhecida</td>
                            <td>Baixa</td>
                            <td>Nenhuma</td>
                            <td>&gt;35000</td>
                            <td>Baixo</td>
                        </tr>
                        <tr>
                            <td>Desconhecida</td>
                            <td>Baixa</td>
                            <td>Adequada</td>
                            <td>&gt;35000</td>
                            <td>Baixo</td>
                        </tr>
                        <tr>
                            <td>Ruim</td>
                            <td>Baixa</td>
                            <td>Nenhuma</td>
                            <td>&lt;15000</td>
                            <td>Alto</td>
                        </tr>
                        <tr>
                            <td>Ruim</td>
                            <td>Baixa</td>
                            <td>Adequada</td>
                            <td>&gt;35000</td>
                            <td>Moderado</td>
                        </tr>
                        <tr>
                            <td>Boa</td>
                            <td>Baixa</td>
                            <td>Nenhuma</td>
                            <td>&gt;35000</td>
                            <td>Baixo</td>
                        </tr>
                        <tr>
                            <td>Boa</td>
                            <td>Alta</td>
                            <td>Adequada</td>
                            <td>&gt;35000</td>
                            <td>Baixo</td>
                        </tr>
                        <tr>
                            <td>Boa</td>
                            <td>Alta</td>
                            <td>Nenhuma</td>
                            <td>&lt;15000</td>
                            <td>Alto</td>
                        </tr>
                        <tr>
                            <td>Boa</td>
                            <td>Alta</td>
                            <td>Nenhuma</td>
                            <td>&gt;=15000 a &gt;= 35000</td>
                            <td>Moderado</td>
                        </tr>
                        <tr>
                            <td>Boa</td>
                            <td>Alta</td>
                            <td>Nenhuma</td>
                            <td>&gt;35000</td>
                            <td>Baixo</td>
                        </tr>
                        <tr>
                            <td>Ruim</td>
                            <td>Alta</td>
                            <td>Nenhuma</td>
                            <td>&gt;=15000 a &lt;=35000</td>
                            <td>Alto</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <p><b>Na prática:</b></p>
            <p id="textoPost">Análise de risco de crédito para novo cliente com os dados (História de crédito: Boa, Dívida: Alta, Garantias: Nenhuma, Renda: &gt;35000). Nesse caso, usa-se, do histórico na tabela, somente as colunas pertinentes ao exemplo atual (História de crédito somente 'boa' - descarta-se Desconhecida e Ruim, Dívida somente 'alta', Garantias somente 'nenhuma' e Renda Anual somente '&gt;35000'). Para o cálculo da probabilidade em cada classe, usa-se a fórmula: 'Multiplicar, nas células pertinentes, todas as frações na mesma linha'.</p>
            <ul>
                <li><b>Probabilidade risco de crédito Alto</b>: 6/14 * 1/6 * 4/6 * 6/6 * 1/6 = 0,0079</li>
                <li><b>Probabilidade risco de crédito Moderado</b>: 3/14 * 1/3 * 1/3 * 2/3 * 1/3 = 0,0052</li>
                <li><b>Probabilidade risco de crédito Baixo</b>: 5/14 * 3/5 * 2/5 * 3/5 * 5/5 = 0,0514</li>
                <li><b>Percentual Alto</b>: (0,0079 / (0,0079+0,0052+0,0514)) * 100 = 12,24 %</li>
                <li><b>Percentual Moderado</b>: (0,0052 / (0,0079+0,0052+0,0514)) * 100 = 8,06 %</li>
                <li><b>Percentual Baixo</b>: (0,0514 / (0,0079+0,0052+0,0514)) * 100 = 79,68 %</li>
                <li><b>Conclusão</b>: Risco de crédito Baixo</li>
            </ul>

            <br><p><b>Correção Laplaciana:</b></p>
            <p id="textoPost">Para possibilitar cálculos de probabilidades, como acima, onde possuam fatores 0 para a multiplicação (Exemplo 0/6), adiciona-se 1 ao numerador zerado (1/6), +1 ao total e, portanto, +1 ao denominador em todas as células da tabela com esse caso (0/6 -&gt; 1/7). Além disso, aumenta-se 1 no total do valor do atributo da classe (Antes total de Ruim eram 4, agora Ruim serão 5). Portanto, o ideal nesses casos é realizar a modificação antes da criação da tabela de probabilidades, para facilitação futura dos cálculos. Exemplo de nova submissão de Risco de Crédito (História de Crédito: Ruim, Dívida: Alta, Garantias: Adequada, Renda: &lt;15000).</p>
            <ol>
                <li><b>Probabilidade risco de crédito Baixo</b>: 5/14 * 0/5 * 2/5 * 2/5 * 0/5</li>
                <li>A partir de agora, serão no Total 5 'História de Crédito Ruim' (Antes 4), 4 'Garantias Adequada' (Antes 3) e 4 'Renda Anual &lt;15000 (Antes 3)'. O total de registros passa a ser 15 (Antes 14). Risco de Crédito Alto passa a ser 7/15 (Antes 6/14). Risco de Crédito Moderado passa a ser 4/15 (Antes 3/14). Risco de Crédito Ruim passa a ser 6/15 (Antes 5/14). Todos os demais denominadores nestas linhas são acrescidos em 1.</li>
                <li><b>Probabilidade risco de crédito Baixo (Laplaciana)</b>: 6/15 * 1/6 * 2/6 * 2/6 * 1/6</li>
            </ol>

            <br><p><b>Probabilidades Apriori / Posteori:</b></p>
            <p id="textoPost">Supondo-se que hajam 12 ítens (Exemplo dados de histórico de crédito), sendo 5 de classe azul (5/12) e 7 de classe vermelha (7/12) - Probabilidade Apriori. Ao submeter novo ítem em meio aos demais, para descobrir sua provável classe, é realizado, ao seu redor próximo, uma circunferência com um raio traçado (Radius), onde será estimada essa probabilidade inicial do mesmo. Exemplo: Novo ítem dentro de circunferência está entre 3 vermelhas e 1 azul. A probabilidade do ítem ser vermelho é 3/7 e de ser azul é 1/5 (Também Probabilidade Apriori). Neste caso, para verificar a probabilidade final (Probabilidade Posteori):</p>
            <ul>
                <li><b>Probabilidade vermelha</b>: 7/12 * 3/7 = 0,25</li>
                <li><b>Probabilidade azul</b>: 5/12 * 1/5 = 0,08</li>
            </ul>

            <br><p><b>Vantagens e Desvantagens:</b></p>
            <p id="textoPost">Entre as vantagens ao escolher o cálculo Bayes ao invés dos demais, tem-se rapidez, simplicidade de interpretação, trabalha com altas dimensões (Muitos atributos), boas previsões em bases pequenas (Bases em torno de 400 registros). Como desvantagem, os casos trabalham com combinação de características (Atributos independentes), onde cada par de características são independentes (Atributos não se relacionam), o que nem sempre é verdade.</p>

            <br><h5>Base de Dados (Risco de Crédito - Pequena)</h5>
            <p class="text-muted" id="textoPost">Aplicação de Naïve Bayes para classificação de Risco de Crédito - Modelo teste.</p>
            <p><b>8. Aplicar algoritmo ML:</b></p>
<small><pre><code>
from sklearn.naive_bayes import GaussianNB <span class="text-muted">#Importar library Naïve Bayes</span>
<span class="text-muted">A library sklearn deixou de mostrar a tabela de probabilidades construída automaticamente. Mas linguagens como R há a possibilidade.</span>

base_risco_credito = pd.read_csv('/content/risco_credito.csv') <span class="text-muted">#Upload do arquivo CSV com 14 registros de exemplo</span>
base_risco_credito

X_risco_credito = base_risco_credito.iloc[:, 0:4].values <span class="text-muted">#Armazenará atributos previsores (História, dívida, garantias e renda)</span>
X_risco_credito

y_risco_credito = base_risco_credito.iloc[:, 4].values <span class="text-muted">#Armazenará a classe (Risco)</span>
y_risco_credito

<span class="text-muted">#Converter os atributos categóricos String para numéricos:</span>
from sklearn.preprocessing import LabelEncoder
label_encoder_historia = LabelEncoder()
label_encoder_divida = LabelEncoder()
label_encoder_garantia = LabelEncoder()
label_encoder_renda = LabelEncoder()
X_risco_credito[:,0] = label_encoder_historia.fit_transform(X_risco_credito[:,0])
X_risco_credito[:,1] = label_encoder_divida.fit_transform(X_risco_credito[:,1])
X_risco_credito[:,2] = label_encoder_garantia.fit_transform(X_risco_credito[:,2])
X_risco_credito[:,3] = label_encoder_renda.fit_transform(X_risco_credito[:,3])
X_risco_credito
<span class="text-muted">#Para essa base específica, a fim de teste, não será aplicado OneHotEncoder</span>

<span class="text-muted">#Salvar dados em arquivo 'risco_credito.pkl':</span>
import pickle
with open('risco_credito.pkl', 'wb') as f:
    pickle.dump([X_risco_credito, y_risco_credito], f)

<span class="text-muted">#Criar e treinar Naïve Bayes para classificação:</span>
naive_risco_credito = GaussianNB()
naive_risco_credito.fit(X_risco_credito, y_risco_credito) <span class="text-muted">#Gerará tabela de probabilidades</span>

<span class="text-muted">#Testar previsão com 2 novos dados:</span>
<span class="text-muted">DADO 1, conforme subtítulo 'Na prática' acima: história boa(0), dívida alta(0), garantias nenhuma(1), renda &gt; 35(2) = Risco de crédito Baixo(79,68 %)</span>
<span class="text-muted">DADO 2, conforme subtítulo 'Laplaciana' acima: história ruim(2), dívida alta(0), garantias adequada(0), renda &lt; 15(0)</span>
previsao = naive_risco_credito.predict([[0,0,1,2],[2,0,0,0]])
previsao <span class="text-muted">#Retornará o resultado das previsões (Baixo e Moderado)</span>

<span class="text-muted">#Informações adicionais:</span>
naive_risco_credito.classes_ <span class="text-muted">#Mostrar tipos de valores da classe</span>
naive_risco_credito.class_count_ <span class="text-muted">#Quantidade de cada tipo de valor</span>
naive_risco_credito.class_prior_ <span class="text-muted">#Mostrar probabilidades Apriori</span>
</code></pre></small>

            <br><h5>Base de Dados (Risco de Crédito - credit data)</h5>
            <p class="text-muted" id="textoPost">Aplicação de Naïve Bayes para classificação de Risco de Crédito.</p>
<small><pre><code>
<span class="text-muted">#Importar library e fazer upload do arquivo 'credit.pkl' com os dados:</span>
import pickle
with open('credit.pkl', 'rb') as f:
    X_credit_treinamento, y_credit_treinamento, X_credit_teste, y_credit_teste = pickle.load(f)

X_credit_treinamento.shape, y_credit_treinamento.shape <span class="text-muted">#Mostrar registros do histórico</span>
X_credit_teste.shape, y_credit_teste.shape <span class="text-muted">#Mostrar registros que serão submetidos após treinamento</span>

<span class="text-muted">#Criar e treinar Naïve Bayes para classificação:</span>
naive_credit_data = GaussianNB()
naive_credit_data.fit(X_credit_treinamento, y_credit_treinamento)

<span class="text-muted">Testar previsão com valores para teste:</span>
previsoes = naive_credit_data.predict(X_credit_teste)
previsoes <span class="text-muted">#Previsões do algoritmo (0 para Pagou e 1 para Não Pagou)</span>
y_credit_teste <span class="text-muted">#Resposta reais e corretas (Para comparar se as do algoritmo ficarão idênticas, precisão das previsões do algoritmo)</span>

<span class="text-muted">Comparar respostas do algoritmo com reais (Precisão de acertos nas previsões):</span>
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
accuracy_score(y_credit_teste, previsoes) <span class="text-muted">#1º parâmetro são as respostas reais, 2º são as previsões do algoritmo. Mostrará percentual de acertos (0,938 - 93,8%)</span>
confusion_matrix(y_credit_teste, previsoes) <span class="text-muted">#Mostrará matriz de acertos classe por classe ([Linha zero(clientes que pagam classificados como 0 - corretamente),(clientes que pagam classificados como 1 - incorretamente)].[Linha 1(clientes que não pagam classificados como 0 - incorretamente),(clientes que não pagam classificados como 1 - corretamente)])</span>
<span class="text-muted">Graficamente, a matrix de confusão mostra Eixo Y(vertical) o valor real, e no Eixo X(horizontal) o valor da previsão</span>

<span class="text-muted">#Preparo, treinamento e verificação com outra library:</span>
from yellowbrick.classifier import ConfusionMatrix
cm = ConfusionMatrix(naive_credit_data)
cm.fit(X_credit_treinamento, y_credit_treinamento)
cm.score(X_credit_teste, y_credit_teste) <span class="text-muted">#Mostrará a mesma matriz de acertos citada acima, mais organizada visualmente</span>

<span class="text-muted">#Mostrar outros detalhes extras:</span>
print(classification_report(y_credit_teste, previsoes))
<span class="text-muted">Recall: Percentual de acerto das previsões do algoritmo após dados reais</span>
<span class="text-muted">Precision: Percentual de acerto das previsões do algoritmo antes das mesmas ocorrerem na realidade</span>
<span class="text-muted">Como conclusão, teve-se muitos clientes não pagadores classificados, pelo algoritmo, como pagadores (Erroneamente). Os 93,8% de precisão devem-se devido ao alto número de acertos em clientes pagadores classificados como pagadores</span>
</code></pre></small>

            <br><h5>Base de Dados (Censo)</h5>
            <p class="text-muted" id="textoPost">Aplicação de Naïve Bayes para classificação de valor salarial.</p>
<small><pre><code>
<span class="text-muted">#Upload do arquivo com dados</span>
with open('census.pkl', 'rb') as f:
    X_census_treinamento, y_census_treinamento, X_census_teste, y_census_teste = pickle.load(f)

<span class="text-muted">#Ver qtde de registros e atributos, e respostas (Base treino e teste)</span>
X_census_treinamento.shape, y_census_treinamento.shape
X_census_teste.shape, y_census_teste.shape

<span class="text-muted">#Criar e treinar Naïve Bayes para classificação:</span>
naive_census = GaussianNB()
naive_census.fit(X_census_treinamento, y_census_treinamento)
previsoes = naive_census.predict(X_census_teste)
previsoes

<span class="text-muted">#Comparar previsões com respostas reais:</span>
y_census_teste <span class="text-muted">#Várias previsões erradas (Accuracy de 47%, pois são somente 2 classes no algoritmo, proporcionando maior probabilidade de erro: 50%-50%)</span>
accuracy_score(y_census_teste, previsoes)
cm = ConfusionMatrix(naive_census)
cm.fit(X_census_treinamento, y_census_treinamento)
cm.score(X_census_teste, y_census_teste)
print(classification_report(y_census_teste, previsoes))
<span class="text-muted">Não executar o escalonamento no início do tratamento dos dados proporcionará, nesse caso, maior accuracy</span>
</code></pre></small>

            <br>
            <h4 id="contArvoreDecisao">----- Árvore de decisão (decision tree) -----</h4>
            <p id="textoPost">Também conhecida como CART (Classification and Regression Trees), consiste em gerar, recursivamente, árvore de possibilidades (IF's), onde a classificação de submissões traça o caminho na árvore, até chegar à conclusão (Nó folha), ou seja, o atributo classe de resposta previsto. Em alguns casos, o próprio algoritmo dispensa alguns atributos, considerados não pertinentes para a previsão. Serão elencados, ordenadamente, os atributos com maior importância até os de menor importância, sendo esse ordenamento a conclusão gerada através dos treinamentos do algoritmo. Entre as vantagens de utilizar Árvore de Decisão, tem-se a dispensa de normalização e padronização dos atributos. Como desvantagens, tem-se casos de geração de Árvores muito complexas (Ramos muito específicos - overfitting), problema NP-completo (Complexo) para construir a Árvore, e tal algoritmo é bastante antigo (Usado nos anos 90. Com o passar dos anos, foram aplicadas melhorias, como Random Forest (Florestas Randômicas) para melhor desempenho).</p>
            <img src="arvoreDecisao.png" class="img-fluid rounded" width="500px">
            <p id="textoPost">A construção da árvore é baseada nas fórmulas da Entropy (Entropia) e Gain (Ganho de informação), ou seja, é através desses 2 cálculos define-se a pertinência dos atributos para posterior ordenamento na árvore. Utilizando como exemplo os dados da base de risco de crédito (<a href="#tabRiscoCredito" class="text-decoration-none">Aqui</a>). Nela tem-se (Alto=6/14), (Moderado=3/14) e (Baixo=5/14). Tais dados são colocados na fórmula da Entropia, a fim de medir o quão organizados/desorganizados os dados estão na sua respectiva base de dados. No caso, a Entropia Geral é de 1,53. Com isso, calcula-se os Ganhos de Informação (G) de todos atributos envolvidos, onde o resultado será o nível de pertinência dos mesmos. Quanto menor o valor da Entropia do atributo, melhor será a distribuição dos dados, ou seja, mais fácil/claro, estatisticamente, para classificar o registro. Atributos com valor de Ganho de Informação baixo tendem a serem excluídos da árvore (Como, no exemplo em questão, a dívida). Abaixo dos cálculos, segue imagem com exemplo visual da construção parcial da árvore.</p>
            <ul>
                <b><u>Entropia</u>:</b>
                <li><b>Entropia Geral:</b> E(s) = -6/14 * log(6/14;2) -3/14 * log(3/14;2) -5/14 * log(5/14;2) = 1,53
                    <ul>
                        <li class="text-muted"><b>História do crédito:</b> 14 é quantidade de registros (Boa=5/14 (Alto=1/5;Moderado=1/5;Baixo=3/5)), (Desconhecida=5/14 (Alto=2/5;Moderado=1/5;Baixo=2/5)), (Ruim=4/14 (Alto=3/4;Moderado=1/4;Baixo=0/4))</li>
                        <li class="text-muted"><b>Dívida:</b> 14 é a quantidade de registros (Alto=7/14 (Alto=4/7;Moderado=1/7;Baixo=2/7)), (Baixa=7/14 (Alto=2/7;Moderado=2/7;Baixo=3/7))</li>
                        <li class="text-muted"><b>Garantias:</b> 14 é a quantidade de registros (Nenhuma=11/14 (Alto=6/11;Moderado=2/11;Baixo=3/11)), (Adequada=3/14 (Alto=0/3;Moderado=1/3;Baixo=2/3))</li>
                        <li class="text-muted"><b>Renda anual:</b> 14 é a quantidade de registros (&lt;15000=3/14 (Alto=3/3;Moderado=0/3;Baixo=0/3)), (&gt;=15000 e &lt;35000=4/14 (Alto=2/4;Moderado=2/4;Baixo=0/4)), (&gt;35000=7/14 (Alto=1/7;Moderado=1/7;Baixo=5/7))</li>
                    </ul>
                </li>
                <li><b>Entropia (História do crédito Boa):</b> E(s) = -1/5 * log(1/5;2) -1/5 * log(1/5;2) -3/5 * log(3/5;2) = 1,37</li>
                <li><b>Entropia (História do crédito Desconhecida):</b> E(s) = -2/5 * log(2/5;2) -1/5 * log(1/5;2) -2/5 * log(2/5;2) = 1,52</li>
                <li><b>Entropia (História do crédito Ruim):</b> E(s) = -3/4 * log(3/4;2) -1/4 * log(1/4;2) -0/4 * log(0/4;2) = 0,81</li>
                <li><b>Entropia (Dívida Alta):</b> E(s) = -4/7 * log(4/7;2) -1/7 * log(1/7;2) -2/7 * log(2/7;2) = 1,38</li>
                <li><b>Entropia (Dívida Baixa):</b> E(s) = -2/7 * log(2/7;2) -2/7 * log(2/7;2) -3/7 * log(3/7;2) = 1,56</li>
                <li><b>Entropia (Garantias Nenhuma):</b> E(s) = -6/11 * log(6/11;2) -2/11 * log(2/11;2) -3/11 * log(3/11;2) = 1,44</li>
                <li><b>Entropia (Garantias Adequada):</b> E(s) = -0/3 * log(0/3;2) -1/3 * log(1/3;2) -2/3 * log(2/3;2) = 0,92</li>
                <li><b>Entropia (Renda anual &lt;15000):</b> E(s) = -3/3 * log(3/3;2) -0/3 * log(0/3;2) -0/3 * log(0/3;2) = 0,00</li>
                <li><b>Entropia (Renda anual &gt;=15000 e &lt;35000):</b> E(s) = -2/4 * log(2/4;2) -2/4 * log(2/4;2) -0/4 * log(0/2;2) = 1,00</li>
                <li><b>Entropia (Renda anual &gt;35000):</b> E(s) = -1/7 * log(1/7;2) -1/7 * log(1/7;2) -5/7 * log(5/7;2) = 1,15</li>
                
                <br><b><u>Ganho</u>:</b>
                <li><b>Ganho (História do crédito):</b> G = 1,53 - (5/14*1,37) - (5/14*1,52) - (4/14*0,81) = 0,26</li>
                <li><b>Ganho (Dívida):</b> G = 1,53 - (7/14*1,38) - (7/14*1,56) = 0,06</li>
                <li><b>Ganho (Garantias):</b> G = 1,53 - (11/14*1,44) - (3/14*0,92) = 0,20</li>
                <li><b>Ganho (Renda anual):</b> G = 1,53 - (3/14*0,00) - (4/14*1,00) - (7/14*1,15) = 0,66</li>
            </ul>
            <br><b><u>Conclusão (Prioridades)</u>:</b>
            <ol>
                <span class="text-muted">Tal conclusão é mostrada visualmente na imagem acima, no ordenamento visual da Árvore de Decisão.</span>
                <li>Renda anual (0,66)</li>
                <li>História de crédito (0,26)</li>
                <li>Garantias (0,20)</li>
                <li>Dívida (0,06)</li>
            </ol>
            <img src="arvoreDecisaoCriacao.png" class="img-fluid rounded" width="700px">
            
            <br><br>
            <p><b>Representação alternativa:</b></p>
            <p id="textoPost">Outra forma de geração de Árvore de Decisão é através da utilização de Splits (Divisão): Parâmetros ação da Árvore de Decisão, utilizados para dividir conjuntos de registros, a fim de identificar tipos de atributos dos mesmos. Posteriormente, tais Splits tornam-se regras (IF's).</p>
            <img src="arvoreDecisaoCriacaoAlternativa.png" class="img-fluid rounded" width="500px">

            <br><br><h5>Podas</h5>
            <p id="textoPost">Após a Árvore de Decisão estar completa, pode-se realizar podas em atributos da Árvore de Decisão com pouco ganho de informação. Raramente, em alguns casos, pode-se que, após a poda, o algoritmo da Árvore acabe errando em algumas situações, pois algumas informações foram removidas da mesma. Utiliza-se podas em cenários que encontram-se:</p>
            <ul>
                <li><b>Bias (Viés):</b> Erros por classificação errada;</li>
                <li><b>Variância:</b> Erros por sensibilidade pequena a mudanças na base de treinamento, onde haverão ramos muito específicos/amarrados à determinadas situações no último nível da Árvore. Pode levar a overfitting (Algoritmo se adapta excessivamente aos dados do treinamento, ficando amarrado aos mesmos, ou seja, decorar ao invés de aprender);</li>
            </ul>

            <br><h5>Base de Dados (Risco de Crédito - Pequena)</h5>
            <p class="text-muted" id="textoPost">Aplicação de Árvore de Decisão para classificação de Risco de Crédito - Modelo teste.</p>
<small><pre><code>
<span class="text-muted">#Importar libraries e upload do arquivo 'credit.pkl' com os dados e LabelEncoder aplicado:</span>
from sklearn.tree import DecisionTreeClassifier
import pickle
with open('risco_credito.pkl', 'rb') as f:
    X_risco_credito, y_risco_credito = pickle.load(f)
X_risco_credito
y_risco_credito

<span class="text-muted">#Criar Árvore de Decisão e treiná-la:</span>
arvore_risco_credito = DecisionTreeClassifier(criterion='entropy') <span class="text-muted">#Por padrão, o criterion usa Gini (Cálculo de impureza de Gini), mas fora alterado para entropy (Cálculo da Entropia)</span>
arvore_risco_credito.fit(X_risco_credito, y_risco_credito)

arvore_risco_credito.feature_importances_ <span class="text-muted">#Ver valor do Ganho de Informação de cada atributo da Árvore</span>
arvore_risco_credito.classes_ <span class="text-muted">#Ver classes</span>

<span class="text-muted">#Visualizar Árvore de Decisão:</span>
from sklearn import tree
tree.plot_tree(arvore_risco_credito) <span class="text-muted">#Modo texto</span>
previsores = ['história', 'dívida', 'garantias', 'renda']
figura, eixos = plt.subplots(nrows=1, ncols=1, figsize=(10,10))
tree.plot_tree(arvore_risco_credito, feature_names=previsores, class_names = arvore_risco_credito.classes_, filled=True);tree.plot_tree(arvore_risco_credito) <span class="text-muted">#Modo gráfico (Imagem abaixo)</span>

<span class="text-muted">#Testar previsao com valores para teste:</span>
<span class="text-muted">#1. história boa, dívida alta, garantias nenhuma, renda &gt; 35</span>
<span class="text-muted">#2. história ruim, dívida alta, garantias adequada, renda &lt; 15</span>
previsoes = arvore_risco_credito.predict([[0,0,1,2],[2,0,0,0]])
previsoes <span class="text-muted">#Retornará, respectivamente, Baixo e Alto</span>
</code></pre></small>
            <img src="arvoreDecisaoResultadoBaseCreditoBasica.png" class="img-fluid" width="350px">
            
            <br><br><h5>Base de Dados (Risco de Crédito - credit data)</h5>
            <p class="text-muted" id="textoPost">Aplicação de Árvore de Decisão para classificação de Risco de Crédito.</p>
<small><pre><code>
<span class="text-muted">#Upload do arquivo 'credit.pkl' do credit data com dados e padronização aplicada:</span>
with open('credit.pkl', 'rb') as f:  
    X_credit_treinamento, y_credit_treinamento, X_credit_teste, y_credit_teste = pickle.load(f)

<span class="text-muted">#Visualizar números de quantidades (Registros, colunas):</span>
X_credit_treinamento.shape, y_credit_treinamento.shape
X_credit_teste.shape, y_credit_teste.shape

<span class="text-muted">#Criar Árvore de Decisão e treiná-la:</span>
arvore_credit = DecisionTreeClassifier(criterion='entropy', random_state = 0) <span class="text-muted">#Random State 0 o algoritmo sempre executará no mesmo ordenamento, facilitando comparações</span>
arvore_credit.fit(X_credit_treinamento, y_credit_treinamento)

<span class="text-muted">#Testar previsao com base para teste:</span>
previsoes = arvore_credit.predict(X_credit_teste)
previsoes <span class="text-muted">#0 indica pagador, 1 indica não pagador</span>
y_credit_teste <span class="text-muted">#Comparar previsões com respostas reais:</span>

<span class="text-muted">#Visualizar métricas de comparação:</span>
from sklearn.metrics import accuracy_score, classification_report
accuracy_score(y_credit_teste, previsoes) <span class="text-muted">#Precisão de 0,982 (98,2%)</span>

<span class="text-muted">#Gerar matriz de confusão (Eixo y (Vertical) é a resposta real, eixo x (Horizontal) é a resposta de previsão):</span>
from yellowbrick.classifier import ConfusionMatrix
cm = ConfusionMatrix(arvore_credit)
cm.fit(X_credit_treinamento, y_credit_treinamento)
cm.score(X_credit_teste, y_credit_teste)

<span class="text-muted">#Gerar classification_report:</span>
print(classification_report(y_credit_teste, previsoes)) <span class="text-muted">#Recall: O algoritmo consegue identificar x% corretamente. Precision: Quando o algoritmo acerta a previsão, o mesmo está correto em x% dos casos.</span>

<span class="text-muted">#Visualizar Árvore de Decisão:</span>
arvore_credit.classes_ <span class="text-muted">#Classes, que serão convertidas em String para a visuazação na Árvore abaixo</span>
from sklearn import tree
previsores = ['income', 'age', 'loan']
fig, axes = plt.subplots(nrows = 1,ncols = 1,figsize = (20,20))
tree.plot_tree(arvore_credit, feature_names=previsores, class_names=['0','1'], filled=True);
fig.savefig('arvore_credit.png') <span class="text-muted">#Salvar imagem da Árvore em arquivo</span>
</code></pre></small>

            <br><h5>Base de Dados (Censo)</h5>
            <p class="text-muted" id="textoPost">Aplicação de Árvore de Decisão para classificação de valor salarial.</p>
<small><pre><code>
<span class="text-muted">#Upload do arquivo 'census.pkl' do credit data com dados e OneHotEncoder aplicado:</span>
with open('census.pkl', 'rb') as f:  
    X_census_treinamento, y_census_treinamento, X_census_teste, y_census_teste = pickle.load(f)

<span class="text-muted">#Visualizar números de quantidades (Registros, colunas):</span>
X_census_treinamento.shape, y_census_treinamento.shape
X_census_teste.shape, y_census_teste.shape

<span class="text-muted">#Criar Árvore de Decisão e treiná-la:</span>
arvore_census = DecisionTreeClassifier(criterion='entropy', random_state=0)
arvore_census.fit(X_census_treinamento, y_census_treinamento)
previsoes = arvore_census.predict(X_census_teste)
previsoes
y_census_teste <span class="text-muted">#Comparar previsões com respostas reais:</span>

<span class="text-muted">#Visualizar métricas de comparação:</span>
accuracy_score(y_census_teste, previsoes) <span class="text-muted">#Precisão de 0,810 (81%)</span>

<span class="text-muted">#Gerar matriz de confusão:</span>
from yellowbrick.classifier import ConfusionMatrix
cm = ConfusionMatrix(arvore_census)
cm.fit(X_census_treinamento, y_census_treinamento)
cm.score(X_census_teste, y_census_teste)

<span class="text-muted">#Gerar classification_report:</span>
print(classification_report(y_census_teste, previsoes))
</code></pre></small>

            <br><p><b>Random Forest:</b></p>
            <p id="textoPost">São melhorias no processo de Árvore de Decisão, para adquirir melhor desempenho. Neste processo, utilizam-se várias Árvores de Decisão (Ensemble learning), escolhendo aleatoriamente K atributos para comparação da métrica pureza/impureza (impureza de gini/entropia), combinando cada conclusão final de Árvore de acordo com a média (Regressão) ou votos da maioria (Classificação) a fim de chegar em conclusão geral final. A quantidade de K atributos pode ser escolhida manualmente ou automaticamente (Algoritmo faz raíz quadrada do total de atributos da base). Supondo que hajam 3 Árvores para calcular Risco de Crédito e 3 atributos (K=3) diferentes entre si: a 1ª conclui 'Alto', a 2ª 'Baixo' e a 3ª 'Baixo'. Então, prevalece a conclusão 'Baixo'. Entretanto, quanto mais Árvores haverem no algoritmo, mais provável sera a chance de overfitting.</p>

            <br><h5>Base de Dados (Risco de Crédito - credit data)</h5>
            <p class="text-muted" id="textoPost">Aplicação de Árvore de Decisão, com Random Forest, para classificação de Risco de Crédito.</p>
<small><pre><code>
<span class="text-muted">#Importar libraries:</span>
from sklearn.ensemble import RandomForestClassifier
import pickle

<span class="text-muted">#Upload do arquivo 'credit.pkl' do credit data com dados e padronização aplicada:</span>
with open('credit.pkl', 'rb') as f:
    X_credit_treinamento, y_credit_treinamento, X_credit_teste, y_credit_teste = pickle.load(f)

<span class="text-muted">#Visualizar números de quantidades (Registros, colunas):</span>
X_credit_treinamento.shape, y_credit_treinamento.shape
X_credit_teste.shape, y_credit_teste.shape

<span class="text-muted">#Criar treinamento Random Forest (40 Árvores), gerar previsões:</span>
random_forest_credit = RandomForestClassifier(n_estimators=40, criterion='entropy', random_state = 0)
random_forest_credit.fit(X_credit_treinamento, y_credit_treinamento)
previsoes = random_forest_credit.predict(X_credit_teste)
previsoes
y_credit_teste <span class="text-muted">#Comparar 'previsoes' com respostas reais (0 paga, 1 não paga empréstimo)</span>

<span class="text-muted">#Visualizar métricas de comparação:</span>
from sklearn.metrics import accuracy_score, classification_report
accuracy_score(y_credit_teste, previsoes) <span class="text-muted">#Precisão de 0,984 (98,4%)</span>

<span class="text-muted">#Gerar matriz de confusão:</span>
from yellowbrick.classifier import ConfusionMatrix
cm = ConfusionMatrix(random_forest_credit)
cm.fit(X_credit_treinamento, y_credit_treinamento)
cm.score(X_credit_teste, y_credit_teste)

<span class="text-muted">#Gerar classification_report:</span>
print(classification_report(y_credit_teste, previsoes)) <span class="text-muted">#O algoritmo consegue identificar corretamente 99% dos elementos da classe 0 (Recall). Quando identifica, 99% das vezes está correto (Precision)</span>
</code></pre></small>

            <br><h5>Base de Dados (Censo)</h5>
            <p class="text-muted" id="textoPost">Aplicação de Árvore de Decisão, com Random Forest, para classificação de valor salarial.</p>
<small><pre><code>
<span class="text-muted">#Importar libraries:</span>
from sklearn.ensemble import RandomForestClassifier
import pickle

<span class="text-muted">#Upload do arquivo 'census.pkl' do credit data com dados e OneHotEncoder aplicado:</span>
with open('census.pkl', 'rb') as f:
    X_census_treinamento, y_census_treinamento, X_census_teste, y_census_teste = pickle.load(f)

<span class="text-muted">#Visualizar números de quantidades (Registros, colunas):</span>
X_census_treinamento.shape, y_census_treinamento.shape
X_census_teste.shape, y_census_teste.shape
y_census_treinamento <span class="text-muted">#Ver classes</span>

<span class="text-muted">#Criar treinamento Random Forest (100 Árvores - padrão), gerar previsões:</span>
random_forest_census = RandomForestClassifier(n_estimators=100, criterion='entropy', random_state = 0)
random_forest_census.fit(X_census_treinamento, y_census_treinamento)
previsoes = random_forest_census.predict(X_census_teste)
previsoes
y_census_teste <span class="text-muted">#Comparar 'previsoes' com respostas reais</span>

<span class="text-muted">Verificar accuracy:</span>
from sklearn.metrics import accuracy_score, classification_report
accuracy_score(y_census_teste, previsoes) <span class="text-muted">#0.8507676560900717 (85%)</span>

<span class="text-muted">#Gerar matriz de confusão:</span>
from yellowbrick.classifier import ConfusionMatrix
cm = ConfusionMatrix(random_forest_census)
cm.fit(X_census_treinamento, y_census_treinamento)
cm.score(X_census_teste, y_census_teste)

<span class="text-muted">#Gerar classification_report:</span>
print(classification_report(y_census_teste, previsoes))
</code></pre></small>

            <br>
            <h4 id="contAprendPorRegras">----- Aprendizagem por Regras -----</h4>
            <p id="texto-post">Geração de regras (IF..THEN) e, após isso, novos registros serão submetido às mesmas (Todos atributos envolvidos True, então usa-se tal regra e tem-se a previsão). No geral, algoritmos de regras tendem a serem mais lentos do que de Árvores, não havendo diferença de melhores resultados de previsões quando ambos comparados. Utilizou-se, como exemplo, os dados da base de risco de crédito (<a href="#tabRiscoCredito" class="text-decoration-none">Aqui</a>).</p>
            <ul>
                <li>Se renda =&gt;35000 E história de crédito = boa, ENTÃO risco = baixo</li>
                <li>Se renda =&gt;35000 E história de crédito = desconhecida, ENTÃO risco = baixo</li>
                <li>Default (Padrão), ENTÃO risco = alto</li>
            </ul>

            <br><h5>OneR</h5>
            <p id="textoPost">OneRules, gerará 1 regra baseada em 1 atributo mais importante. Submetendo tal algoritmo na base Risco de Crédito, gerará a seguinte tabela, onde o atributo 'Renda' foi escolhido como principal, pois há menor chance de erro (Total erro). Esse mesmo algoritmo pode ser testado no software Weka.</p>
            <div class="table-responsive">
                <table class="table table-striped table-sm table-bordered text-center align-middle">
                    <thead>
                        <tr>
                            <th scope="col" class="table-primary">Atributo</th>
                            <th scope="col" class="table-primary">Quantidade</th>
                            <th scope="col" class="table-primary">Regras</th>
                            <th scope="col" class="table-primary">Erro</th>
                            <th scope="col" class="table-primary">Total erro</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td class="table-primary" rowspan="3">História de Crédito</td>
                            <td>Boa <span class="text-muted">5</span></td>
                            <td>SE boa ENTÃO baixo</td>
                            <td>2/5</td>
                            <td rowspan="3">6/14</td>
                        </tr>
                        <tr>
                            <td>Desconhecida <span class="text-muted">5</span></td>
                            <td>SE desconhecida ENTÃO alto</td>
                            <td>3/5</td>
                        </tr>
                        <tr>
                            <td>Ruim <span class="text-muted">4</span></td>
                            <td>SE ruim ENTÃO alto</td>
                            <td>1/4</td>
                        </tr>
                        <tr>
                            <td class="table-primary" rowspan="2">Dívida</td>
                            <td>Alta <span class="text-muted">7</span></td>
                            <td>SE alta ENTÃO alto</td>
                            <td>3/7</td>
                            <td rowspan="2">7/14</td>
                        </tr>
                        <tr>
                            <td>Baixa <span class="text-muted">7</span></td>
                            <td>SE baixa ENTÃO baixo</td>
                            <td>4/7</td>
                        </tr>
                        <tr>
                            <td class="table-primary" rowspan="2">Garantias</td>
                            <td>Nenhuma <span class="text-muted">11</span></td>
                            <td>SE nenhuma ENTÃO alto</td>
                            <td>5/11</td>
                            <td rowspan="2">6/14</td>
                        </tr>
                        <tr>
                            <td>Adequada <span class="text-muted">3</span></td>
                            <td>SE adequada ENTÃO baixo</td>
                            <td>1/3</td>
                        </tr>
                        <tr>
                            <td class="table-warning" rowspan="3"><b>Renda</b></td>
                            <td>&lt;15000 <span class="text-muted">3</span></td>
                            <td>SE &lt;15000 ENTÃO alto</td>
                            <td>0</td>
                            <td rowspan="3">4/14</td>
                        </tr>
                        <tr>
                            <td>&gt;=15000 a &lt;=35000 <span class="text-muted">4</span></td>
                            <td>SE &gt;=15000 a &lt;=35000 ENTÃO alto</td>
                            <td>2/4</td>
                        </tr>
                        <tr>
                            <td>&gt;35000 <span class="text-muted">7</span></td>
                            <td>SE &gt;35000 ENTÃO baixo</td>
                            <td>2/7</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p id="textoPost">Para a montagem das regras acima, contabilizam-se as possibilidades de cada regra/atributo. O exemplo abaixo fora utilizado somente 'História de Crédito' (Deve ser feito com todos), pois para as demais segue a mesma lógica:</p>
            <ul>
                <b><u>História de Crédito</u>:</b>
                <li>SE boa ENTÃO alto <span class="text-muted">(1)</span></li>
                <li>SE boa ENTÃO moderado <span class="text-muted">(1)</span></li>
                <li>SE boa ENTÃO baixo <span class="text-muted">(3) - Escolhida</span>
                    <ul>
                        <li>ERRO: Para cada 5 <span class="text-muted">(Total)</span>, 2 podem ser errados <span class="text-muted">(2 fora da regra escolhida)</span> = 2/5</li>
                    </ul>
                </li>
                <br>
                <li>SE desconhecida ENTÃO alto <span class="text-muted">(2) - Escolhida (Não há critério em empates, aparece primeiro)</span>
                    <ul>
                        <li>ERRO: Para cada 5, 3 podem ser errados = 3/5</li>
                    </ul>
                </li>
                <li>SE desconhecida ENTÃO moderado <span class="text-muted">(1)</span></li>
                <li>SE desconhecida ENTÃO baixo <span class="text-muted">(2)</span></li>
                <br>
                <li>SE ruim ENTÃO alto <span class="text-muted">(3) - Escolhida</span>
                    <ul>
                        <li>ERRO: Para cada 4, 1 pode ser errado = 1/4</li>
                    </ul>
                </li>
                <li>SE ruim ENTÃO moderado <span class="text-muted">(1)</span></li>
                <li>SE ruim ENTÃO baixo <span class="text-muted">(0)</span></li>
                <br>
                <li>TOTAL ERRO: (2+3+1)/(5+5+4) = 6/14</li>
            </ul>
            <img src="weka.png" class="img-fluid rounded" width="900px">
            <br><small class="text-muted">*Weka (Arquivo risco_credito.arff submetido ao OneR)</small><br>
            
            <br><h5>PRISM</h5>
            <p id="textoPost">Gerar 1 regra específica com vários atributos, identificando-os via maior abrangência, que classificará os registros conforme resposta esperada. Exemplo, passo a passo, da montagem da regra:</p>
            <ol>
                <li>SE <b style="color: red;">?</b> ENTÃO risco = alto
                    <ul>
                        <li>SE <i>garantias = nenhuma</i> ENTÃO risco = alto</li>
                    </ul>
                </li>
            </ol>
            <div class="table-responsive">
                <table class="table table-striped table-sm table-bordered text-center align-middle">
                    <thead>
                        <tr>
                            <th scope="col" class="table-primary">Atributo/Valor</th>
                            <th scope="col" class="table-primary">Abrangência</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>História de crédito = Boa</td>
                            <td>1/1 <span class="text-muted">(História de crédito boa E risco alto)</span></td>
                        </tr>
                        <tr>
                            <td>História de crédito = Desconhecida</td>
                            <td>2/2</td>
                        </tr>
                        <tr>
                            <td>História de crédito = Ruim</td>
                            <td>3/3</td>
                        </tr>
                        <tr>
                            <td>Dívida = Alta</td>
                            <td>4/4</td>
                        </tr>
                        <tr>
                            <td>Dívida = Baixa</td>
                            <td>2/2</td>
                        </tr>
                        <tr class="table-warning">
                            <td>Garantias = Nenhuma <span class="text-muted">(Mais abrangente)</span></td>
                            <td>6/6</td>
                        </tr>
                        <tr>
                            <td>Garantias = Adequada</td>
                            <td>0/3 <span class="text-muted">(3 Garantias adequadas, mas nenhuma com risco alto)</span></td>
                        </tr>
                        <tr>
                            <td>Renda = &lt;15000</td>
                            <td>3/3</td>
                        </tr>
                        <tr>
                            <td>Renda = 15000-35000</td>
                            <td>2/2</td>
                        </tr>
                        <tr>
                            <td>Renda = &gt;35000</td>
                            <td>1/1</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <ol start="2">
                <li>SE garantias = nenhuma E <b style="color: red;">?</b> ENTÃO risco = alto
                    <ul>
                        <li>SE garantias = nenhuma E <i>dívida = alta</i> ENTÃO risco = alto</li>
                    </ul>
                </li>
            </ol>
            <div class="table-responsive">
                <table class="table table-striped table-sm table-bordered text-center align-middle">
                    <thead>
                        <tr>
                            <th scope="col" class="table-primary">Atributo/Valor</th>
                            <th scope="col" class="table-primary">Abrangência</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>História de crédito = Boa</td>
                            <td>1/1 <span class="text-muted">(História de crédito boa E garantias nenhuma E risco alto)</span></td>
                        </tr>
                        <tr>
                            <td>História de crédito = Desconhecida</td>
                            <td>2/2</td>
                        </tr>
                        <tr>
                            <td>História de crédito = Ruim</td>
                            <td>3/3</td>
                        </tr>
                        <tr class="table-warning">
                            <td>Dívida = Alta <span class="text-muted">(Mais abrangente)</span></td>
                            <td>4/4</td>
                        </tr>
                        <tr>
                            <td>Dívida = Baixa</td>
                            <td>2/2</td>
                        </tr>
                        <tr>
                            <td>Renda = &lt;15000</td>
                            <td>3/3</td>
                        </tr>
                        <tr>
                            <td>Renda = 15000-35000</td>
                            <td>2/2</td>
                        </tr>
                        <tr>
                            <td>Renda = &gt;35000</td>
                            <td>1/1</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <ol start="3">
                <li>SE garantias = nenhuma E dívida = alta E <b style="color: red;">?</b> ENTÃO risco = alto
                    <ul>
                        <li>SE garantias = nenhuma E dívida = alta E <i>história = ruim</i> ENTÃO risco = alto</li>
                    </ul>
                </li>
            </ol>
            <div class="table-responsive">
                <table class="table  table-striped table-sm table-bordered text-center align-middle">
                    <thead>
                        <tr>
                            <th scope="col" class="table-primary">Atributo/Valor</th>
                            <th scope="col" class="table-primary">Abrangência</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>História de crédito = Boa</td>
                            <td>1/1 <span class="text-muted">(História de crédito boa E garantias nenhuma E dívida alta E risco alto)</span></td>
                        </tr>
                        <tr>
                            <td>História de crédito = Desconhecida</td>
                            <td>1/1</td>
                        </tr>
                        <tr class="table-warning">
                            <td>História de crédito = Ruim <span class="text-muted">(Mais abrangente)</span></td>
                            <td>2/2</td>
                        </tr>
                        <tr>
                            <td>Renda = &lt;15000</td>
                            <td>2/2</td>
                        </tr>
                        <tr>
                            <td>Renda = 15000-35000</td>
                            <td>2/2</td>
                        </tr>
                        <tr>
                            <td>Renda = &gt;35000</td>
                            <td>0</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <ol start="4">
                <li>SE garantias = nenhuma E dívida = alta E história = ruim E <b style="color: red;">?</b> ENTÃO risco = alto
                    <ul>
                        <li>SE garantias = nenhuma E dívida = alta E história = ruim E <i>renda &lt;15000</i> ENTÃO risco = alto</li>
                    </ul>
                </li>
            </ol>
            <div class="table-responsive">
                <table class="table table-striped table-sm table-bordered text-center align-middle">
                    <thead>
                        <tr>
                            <th scope="col" class="table-primary">Atributo/Valor</th>
                            <th scope="col" class="table-primary">Abrangência</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="table-warning">
                            <td>Renda = &lt;15000 <span class="text-muted">(Mais abrangente)</span></td>
                            <td>1/1</td>
                        </tr>
                        <tr>
                            <td>Renda = 15000-35000</td>
                            <td>1/1</td>
                        </tr>
                        <tr>
                            <td>Renda = &gt;35000</td>
                            <td>0</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <ol start="5">
                <li>Após isso, o mesmo deverá ser feito para 'risco = médio' e 'risco = baixo'</li>
            </ol>
            <p id="textoPost"><u>OBSERVAÇÃO</u>: Como os registros acima foram bastante específicos (Ex: 1/1), pode-se ocorrer overfitting! Para evitar isso, pode-se utilizar 'poda' de tais atributos muito específicos, ou seja, com poucos dados envolvidos.</p>
            
            <br><h5>Base de Dados (Risco de Crédito - Pequena)</h5>
            <p class="text-muted" id="textoPost">Aplicação de Indução de Regras para classificação de Risco de Crédito - Modelo teste.</p>
<small><pre><code>
<span class="text-muted">#Importar libraries e upload do arquivo com dados, LabelEncoder aplicado e organizado para Orange, com 'c#risco' para atributo classe:</span>
!pip install Orange3
import Orange

base_risco_credito = Orange.data.Table('risco_credito_regras.csv')
base_risco_credito
base_risco_credito.domain <span class="text-muted">#Mostrar cabeçalho/domínio</span>

<span class="text-muted">#(Treinamento) Criar regras, submetendo os dados ao algoritmo de regras 'cn2':</span>
cn2 = Orange.classification.rules.CN2Learner()
regras_risco_credito = cn2(base_risco_credito)

for regras in regras_risco_credito.rule_list:
    print(regras)

<span class="text-muted">#Testar previsão com valores para teste:</span>
previsoes = regras_risco_credito([['boa', 'alta', 'nenhuma', 'acima_35'], ['ruim', 'alta', 'adequada', '0_15']])
previsoes <span class="text-muted">#Obteve-se 1 e 0</span>
base_risco_credito.domain.class_var.values <span class="text-muted">#0 é alto, 1 é baixo, 2 é moderado</span>
for i in previsoes:
    #print(i)
    print(base_risco_credito.domain.class_var.values[i])
</code></pre></small>

            <br><h5>Base de Dados (Risco de Crédito - credit data)</h5>
            <p class="text-muted" id="textoPost">Aplicação de Indução de Regras para classificação de Risco de Crédito.</p>
<small><pre><code>
<span class="text-muted">#Importar libraries e upload do arquivo com dados e padronização aplicada, com 'i#clientid' para ser ignorado, e 'c#default' para atributo classe:</span>
!pip install Orange3
import Orange
base_credit.domain <span class="text-muted">#Mostrar cabeçalho/domínio</span>

<span class="text-muted">Dividir base de dados treinamento-teste:</span>
base_dividida = Orange.evaluation.testing.sample(base_credit, n = 0.25) <span class="text-muted">#25% para teste, 75% para treino</span>
base_dividida
base_dividida[0]
base_dividida[1]
base_teste = base_dividida[0]
base_treinamento = base_dividida[1]
len(base_teste), len(base_treinamento)

<span class="text-muted">#(Treinamento) Criar regras, submetendo os dados ao algoritmo de regras 'cn2':</span>
cn2 = Orange.classification.rules.CN2Learner()
regras_credit = cn2(base_treinamento)
for regras in regras_credit.rule_list:
    print(regras)

<span class="text-muted">#Testar previsão com valores para teste:</span>
previsoes = Orange.evaluation.testing.TestOnTestData(base_treinamento, base_teste, [lambda testdata: regras_credit])
Orange.evaluation.CA(previsoes) <span class="text-muted">#(97,4%) CA para 'Classification Accuracy', ou F1 para 'F1 Score'</span>
</code></pre></small>

            <br><h5>Base de Dados (Censo) - Orange GUI</h5>
            <p class="text-muted" id="textoPost">Aplicação de Indução de Regras, via Orange GUI, para classificação de valor salarial. Instalar Orange via '<i>pip3 install orange3</i>'.</p>
            <p id="textoPost">Seguindo o passo a passo da modelagem, tem-se 80,7% de accuracy.</p>
            <img src="orange1.png" class="img-fluid rounded" width="600px"><br><br>
            <img src="orange2.png" class="img-fluid rounded" width="600px"><br><br>
            <img src="orange3.png" class="img-fluid rounded" width="600px"><br><br>
            <img src="orange4.png" class="img-fluid rounded" width="600px"><br><br>
            <img src="orange5.png" class="img-fluid rounded" width="600px"><br>

            <br><h5>Base de Dados (Risco de Crédito - credit data)</h5>
            <p class="text-muted" id="textoPost">Aplicação de Indução de Regras, via Orange GUI, para classificação de Risco de Crédito.</p>
            <p id="textoPost">Seguindo o passo a passo da modelagem, tem-se 96,2% de accuracy.</p>
            <img src="orange6.png" class="img-fluid rounded" width="600px"><br><br>
            <img src="orange7.png" class="img-fluid rounded" width="600px"><br><br>
            <img src="orange8.png" class="img-fluid rounded" width="600px"><br><br>
            <img src="orange9.png" class="img-fluid rounded" width="600px"><br><br>
            <img src="orange10.png" class="img-fluid rounded" width="600px"><br><br>
            
            <br>
            <h4 id="majorityLearner">----- Majority learner (ZeroR) -----</h4>
            <p id="textoPost">Classificar dados conforme histórico de treino. Exemplo, maioria dos clientes do banco x pagam empréstimo, então novo cliente do banco x será classificado como pagador. Algoritmo muito utilizado para avaliar outros algoritmos ML.</p>
            <br><h5>Base de Dados (Risco de Crédito - credit data)</h5>
<small><pre><code>
base_credit = Orange.data.Table('credit_data_regras.csv') #via biblioteca orange
base_credit.domain
majority = Orange.classification.MajorityLearner() #criar algoritmo ML
previsoes = Orange.evaluation.testing.TestOnTestData(base_credit, base_credit, [majority]) #treinar e testar mesma base_credit, via majority (dispensará treinamento)
Orange.evaluation.CA(previsoes) #avaliação de aprox 86%

for registro in base_credit: #valores da classe
    print(registro.get_class())

from collections import Counter
Counter(str(registro.get_class()) for registro in base_credit) #contagem de tipos de valores da classe (valContagemMaioria/valTotal=evaluationModelo)
#Nesse dataset, se algoritmo ML acertar menos que 85%, deve ser descartado. Do contrário, pode ser mantido
</code></pre></small>

            <br><h5>Base de Dados (Censo)</h5>
<small><pre><code>
base_census = Orange.data.Table('census_regras.csv')
base_census.domain
majority = Orange.classification.MajorityLearner()
previsoes = Orange.evaluation.testing.TestOnTestData(base_census, base_census, [majority])
Orange.evaluation.CA(previsoes) #avaliação de aprox 76%

Counter(str(registro.get_class()) for registro in base_census)
</code></pre></small>

            <br>
            <h4 id="knn">----- KNN (k-nearest neighbors) -----</h4>
            <p id="textoPost">Algoritmo de aprendizagem baseada em instâncias (k-ésimo vizinho mais próximo). Classificará dado x conforme outro dado y já classificado no dataset, que possui previsores de valores mais próximos aos do dado x, via menor valor de cálculo de distância euclidiana. Parâmetro k indica quantidade de vizinhos mais próximos para determinar classificação no algoritmo. Se dado x, com k=2, onde os vizinhos mais próximos são diferentes, então há possibilidade de x ser um dos dois (empate, pode ser resolvido escolhendo vizinho mais próximo). Se dado x, em k=3, onde vizinhos 2 e 3 são iguais, então x será como 2 e 3, pois há mais vizinhos próximos com essa classificação. Valor k muito elevado, tende a diminuir a accuracy de classificação. Algoritmo KNN não constrói modelo para classificar (lazy), somente realiza cálculo de distância euclidiana. Quanto menor a distância euclidiana, maior a proximidade (similaridade) entre elementos. KNN é usado em sistemas de recomendações, como filtragem colaborativa.</p>
            <p>Distância euclidiana calcula proximidade entre vetores, como x e y.</p>
            <ol>Exemplo x=5,7,9 e y=5,5,5 onde p é valor inicial, ou seja, quantidade de registros (3 registros) e i é valor final, posição (xi é valor na mesma posição que yi).
                <li>Subtração dos valores (5-5=0 e 7-5=2 e 9-5=4)</li>
                <li>Elevação ao quadrado (0²=0 e 2²=4 e 4²=16)</li>
                <li>Somatório (0+4+16=20)</li>
                <li>Raíz quadrada (raíz(20)=4,47) é a distância euclidiana</li>
            </ol>
            <!-- Ver udemy70 -->
        </div>
    </div>


<!--Rodapé-->
<div class="row">
    <div class="col-sm-12 text-center bg-black text-light pt-4 pb-3">
        <p>Elaborado por Mateus Schwede<br><small class="text-muted">ubsocial.github.io</small></p>
    </div>
</div>

</div>
</body>
</html>


<!-- EXEMPLO TABLE
<div class="table-responsive">
    <table class="table table-striped table-sm table-bordered text-center align-middle">
        <thead>
            <tr>
                <th scope="col" class="table-primary"></th>
                <th scope="col" class="table-primary" colspan="3">História do Crédito</th>
                <th scope="col" class="table-primary" colspan="2">Dívida</th>
                <th scope="col" class="table-primary" colspan="2">Garantias</th>
                <th scope="col" class="table-primary" colspan="3">Renda anual</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <th scope="col" class="table-primary">Risco de crédito<br><span class="text-muted">14</span></th>
                <td>Boa<br><span class="text-muted">5</span></td>
                <td>Desconhecida<br><span class="text-muted">5</span></td>
                <td>Ruim<br><span class="text-muted">4</span></td>
                <td>Alta<br><span class="text-muted">7</span></td>
                <td>Baixa<br><span class="text-muted">7</span></td>
                <td>Nenhuma<br><span class="text-muted">11</span></td>
                <td>Adequada<br><span class="text-muted">3</span></td>
                <td>&lt;15000<br><span class="text-muted">3</span></td>
                <td>&gt;=15000 a &lt;=35000<br><span class="text-muted">4</span></td>
                <td>&gt;35000<br><span class="text-muted">7</span></td>
            </tr>
            <tr>
                <td scope="col" class="table-primary">Alto<br><span class="text-muted">6/14</span></td>
                <td>1/6</td>
                <td>2/6</td>
                <td>3/6</td>
                <td>4/6</td>
                <td>2/6</td>
                <td>6/6</td>
                <td>0/6</td>
                <td>3/6</td>
                <td>2/6</td>
                <td>1/6</td>
            </tr>
        </tbody>
    </table>
</div>
-->