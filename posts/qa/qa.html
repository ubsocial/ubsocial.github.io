<!doctype html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" href="../../icons/logoTit.png">
    <link rel="stylesheet" href="../../estilo.css">
    <title>UB Social</title>
</head>
<body>
<div class="container-fluid">


    <div class="row">
        <div class="col-sm-12">
            <nav class="navbar rounded-bottom fixed-top navbar-expand-lg navbar-light bg-light shadow">
                <div class="container-fluid">
                    <a class="navbar-brand" href="../../index.html"><img src="../../icons/logo.png" class="d-inline-block align-text-top" width="11pt"> UB Social</a>
                    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
                    <div class="collapse navbar-collapse" id="navbarNav">
                        <ul class="navbar-nav">
                            <li class="nav-item"><a class="nav-link" href="../../index.html">Home</a></li>
                            <li class="nav-item"><a class="nav-link" href="../../sobre/sobre.html">Sobre</a></li>
                            <li class="nav-item"><a class="nav-link" href="../../cursos.html">Cursos</a></li>
                            <li class="nav-item"><a class="nav-link" href="../../livros/livros.html">Livros</a></li>
                        </ul>
                    </div>
                </div>
            </nav>
        </div>
    </div>

    <div class="row">
        <div class="col-sm-12 text-center" id="titulo">
            <h1>QA e Testes de software</h1>
            <h6>Conceito, princípios e aplicações</h6>
            <a href="../../index.html" class="btn btn-link text-decoration-none mb-3">Voltar</a>
        </div>

        <div class="col-sm-12">
            <p class="text-warning text-center">RESUMO EM CONSTRUÇÃO</p>
            <h4>Material complementar:</h4>
            <ul>
                <li>Conteúdo no GitHub: <a class="text-decoration-none">Acesse em breve</a></li>
                <li>Curso com certificado na Workover Academy: <a class="text-decoration-none">Acesse em breve</a></li>
            </ul>

            <br><hr><h4>Aula 1- Introdução à qualidade de software e QA:</h4>
            <p id="textoPost">QA (Quality Assurance ou Garantia da Qualidade) é conjunto de processos e práticas para prevenir defeitos (bugs) e garantir que software atenda padrões de qualidade esperados (requisitos do sistema, critérios de aceitação, normas e modelos de qualidade, padrões técnicos e boas práticas, contratos e SLAs, definição de pronto - Definition of Done), em todas fases do desenvolvimento. Profissionais de QA identificam falhas, otimizam processos e asseguram que software seja robusto e confiável, atuando de forma preventiva.</p>
            <p id="textoPost">No cotidiano, QA participa da análise de requisitos, validando regras de negócio, identificando ambiguidades e antecipando cenários de erro. Durante desenvolvimento, QA valida se features estão conforme esperado e, após entrega, contribui para estabilidade do sistema em produção. Em times ágeis, QA trabalha integradamente com desenvolvedores, POs e designers.</p>
            <p id="textoPost">Testes manuais são executados por pessoa, seguindo cenários definidos ou explorando sistema de forma livre. São essenciais em testes exploratórios, validação visual, usabilidade e testes iniciais de novas funcionalidades. Testes automatizados utilizam ferramentas e scripts para executar cenários repetitivos de forma rápida e confiável. Em ambiente de produção, são usados para validar regressões, fluxos críticos e integrações sempre que nova versão é entregue. Testes repetitivos, regressões, fluxos críticos e cenários que precisam ser executados com frequência são fortes candidatos à automação. Testes exploratórios, validações visuais e funcionalidades em constante mudança geralmente são melhores executados de forma manual, especialmente em fases iniciais do desenvolvimento. Automação permite execuções rápidas, redução de erros humanos, maior cobertura de testes e integração com pipelines de CI/CD, possibilitando validar aplicação inteira a cada deploy.</p>
<small><pre><code>
Teste manual, cenário Login de usuário:
Abrir aplicação no navegador
Informar e-mail válido e senha válida
Clicar em Entrar
Verificar se sistema redireciona para página inicial e exibe nome do usuário

Teste automatizado, cenário Login de usuário (exemplo em pseudocódigo Python):
def test_senha_com_tamanho_minimo():
    senha = "123456"
    resultado = validar_senha(senha)
    assert resultado is True
</code></pre></small>
            <ul>
                <li>Testes unitários (unit tests): validam pequenas partes do código, como funções ou métodos isolados. Exemplo: testar se função de cálculo de desconto retorna valor correto para diferentes entradas;
<small><pre><code>
Loja online aplica 10% de desconto para compras acima de R$ 100,00. Função responsável por calcular valor final da compra.

Regra de negócio:
Valor a menor ou igual a 100 = não aplica desconto
Valor maior que 100 = aplica 10% de desconto

Teste unitário (exemplo prático)
def test_calcular_desconto():
    assert calcular_desconto(80) == 80
    assert calcular_desconto(100) == 100
    assert calcular_desconto(200) == 180
</code></pre></small>
                </li>
                <li>Testes de integração (integration tests): validam comunicação entre componentes, serviços ou APIs. Exemplo: verificar se API de pedidos consegue se comunicar corretamente com API de pagamentos;
<small><pre><code>
Sistema de e-commerce possui API de Pedidos, que cria pedidos, e API de Pagamentos, que processa pagamentos. Quando pedido é criado, API de Pedidos chama API de Pagamentos para cobrar cliente.

Regra de negócio:
Se pagamento for aprovado, pedido fica com status "PAGO"
Se pagamento falhar, pedido fica com status "RECUSADO"

def test_criar_pedido_com_pagamento_aprovado(client):
    response = client.post("/api/pedidos/", json=&#123;
        "produto_id": 1,
        "quantidade": 2,
        "cartao": "4111111111111111"
    &#125;)

    assert response.status_code == 201
    assert response.json()["status"] == "PAGO"
</code></pre></small>
                </li>
                <li>Testes de sistema (system tests): validam sistema como todo, considerando todas integrações e fluxos principais, verificando se comportamento geral da aplicação atende ao esperado, segundo critérios de aceitação;
<small><pre><code>
Sistema: E-commerce web
Objetivo do sistema: permitir que usuário compre produto do início ao fim.

Critério de aceitação:
Usuário consegue comprar produto com sucesso
Pagamento é aprovado
Pedido aparece no histórico do usuário
Teste de sistema (exemplo prático)

Fluxo executado:
Usuário acessa site
Realiza login
Adiciona produto ao carrinho
Finaliza compra
Sistema processa pagamento
Pedido é confirmado e exibido no histórico

Validações:
Tela de confirmação exibida
Status do pedido: "Confirmado"
Pagamento registrado no sistema
Pedido visível no histórico
</code></pre></small>
                </li>
                <li>Testes de aceitação: validam se sistema atende às regras de negócio definidas pelo cliente ou usuário final. Exemplo: validar se aluno consegue acessar suas notas após realizar login em sistema escolar.
<small><pre><code>
Sistema: Sistema escolar online

Regra de negócio (definida pelo cliente):
Apenas alunos autenticados podem visualizar suas próprias notas
Notas devem corresponder ao aluno logado

Teste de aceitação (exemplo prático):
Cenário: Aluno acessa suas notas após login
Dado que aluno possui cadastro ativo no sistema
Quando aluno realiza login com usuário e senha válidos
E acessa opção "Minhas Notas"
Sistema exibe apenas notas daquele aluno da sessão
</code></pre></small>
                </li>
            </ul>
            <p id="textoPost">Testes funcionais verificam se funcionalidades do sistema funcionam conforme esperado, como login, cadastro, busca e envio de formulários. Testes não funcionais avaliam características como desempenho, segurança, usabilidade e compatibilidade, inclui testar quantos usuários simultâneos o sistema suporta ou se dados sensíveis estão protegidos adequadamente.
<small><pre><code>
TESTE FUNCIONAL:
Sistema: Aplicativo bancário
Cenário: Pix entre contas

Usuário realiza login
Informa Pix de destino e valor de R$ 500,00
Confirma Pix

Resultado esperado:
Valor é debitado da conta de origem
Valor é creditado na conta de destino
Sistema exibe mensagem de sucesso

TESTE NÃO FUNCIONAL:
Sistema: API bancária
Cenário: Tempo de resposta da API de Pix
Realizar 1.000 requisições simultâneas de Pix
Medir tempo de resposta

Resultado esperado:
95% das requisições respondem em até 2 segundos
Nenhuma requisição retorna erro 5xx
</code></pre></small>
            </p>
            <p id="textoPost">Pirâmide de testes é modelo de distribuição dos tipos de testes (E2E Tests, Service Tests, Unit Tests). Na base estão testes unitários, em maior quantidade e com execução rápida. No meio, testes de integração. No topo, testes de sistema e End-to-End, em menor quantidade, sendo mais lentos e complexos. Pirâmide ajuda reduzir custos, acelerar feedbacks e manter estabilidade do desenvolvimento do sistema.</p>
            <p id="textoPost">Artefatos de QA são documentos e registros utilizados para planejar, executar e acompanhar testes, garantindo rastreabilidade, organização e comunicação entre time.
<small><pre><code>
1. Plano de Testes: documento que define o que será testado, como, quando e por quem. Exemplo:
Plano descrevendo que:
Testes unitários serão feitos com pytest
Testes de integração cobrem APIs de pedidos e pagamentos
Ambiente de homologação será usado antes da produção

2. Casos de Teste: descrição passo a passo de como validar funcionalidade. Exemplo:
Caso de teste: Login com senha válida
Entrada: e-mail e senha corretos
Ação: clicar em "Entrar"
Resultado esperado: redirecionamento para dashboard

3. Cenários de Teste: visão mais alto nível, focada no fluxo. Exemplo:
Cenário: Compra de produto com pagamento aprovado

4. Relatório de Bugs (Defect Report): registro formal de erro encontrado. Exemplo:
Título: Erro ao finalizar pagamento com cartão
Ambiente: Homologação
Resultado esperado: pagamento aprovado
Resultado obtido: erro 500

5. Checklist de Testes: lista rápida para validação básica. Exemplo:
Login funciona
API retorna status 200
Campos obrigatórios validados

6. Relatório de Execução de Testes: mostra status dos testes executados. Exemplo:
Total de testes: 120
Passaram: 110
Falharam: 10

7. Matriz de Rastreabilidade: relaciona requisitos aos testes. Exemplo:
Requisito RF-01: Caso de Teste CT-05

8. Evidências de Teste: comprovação da execução do teste. Exemplo:
Screenshot da tela de confirmação
Log de execução de teste automatizado
</code></pre></small>
            </p>
            <p id="textoPost">Casos de teste descrevem passo a passo como validar funcionalidade, incluindo pré-condições, dados de entrada, ações e resultados esperados. Exemplo: descrever todo fluxo de login de usuário, desde inserção de credenciais até acesso ao sistema.
<small><pre><code>
Caso de Teste Completo - Login de Usuário
ID: CT-AUTH-LOGIN-001
Título: Login com credenciais válidas
Módulo: Autenticação
Tipo de teste: Funcional / Sistema
Prioridade: Alta
Autor: QA Team
Data: 15/01/2026

Objetivo: validar se o usuário consegue acessar sistema, informando credenciais válidas, conforme regras de negócio definidas.

Pré-condições:
Usuário cadastrado e ativo no sistema
Usuário não está logado
Sistema disponível
Navegador Google Chrome atualizado

Ambiente: Homologação

Dados de teste (campo, valor):
E-mail: usuario@exemplo.com
Senha: Senha@123

Passos de execução:
Acessar URL do sistema
Clicar na opção Login
Informar e-mail no campo correspondente
Informar senha no campo correspondente
Clicar no botão Entrar

Resultado esperado:
Sistema valida credenciais
Usuário é autenticado com sucesso
Redirecionamento para página inicial
Nome do usuário exibido no topo da tela
Token de sessão criado

Resultado obtido: (Preenchido durante a execução)

Status: (Aprovado / Reprovado)

Evidências: Screenshot da tela inicial após login

Log da requisição de autenticação

Observações:
Caso de teste pode ser reutilizado para automação
Base para cenários negativos (senha inválida, usuário inativo)
</code></pre></small>
            </p>
            <p id="textoPost">Checklists são listas simples de verificações que devem ser realizadas durante teste. Muito usados em testes exploratórios, revisões rápidas ou validações antes de entrega em produção.
<small><pre><code>
Checklist de Testes - Liberação para Produção

Sistema: Plataforma Web de E-commerce
Módulo: Autenticação e Compra
Ambiente: Homologação
Responsável: QA
Data: 15/01/2026

1. Autenticação:
[] Login com credenciais válidas
[] Bloqueio após tentativas inválidas
[] Logout funcionando corretamente
[] Sessão expira após tempo de inatividade

2. Funcionalidades principais:
[] Listagem de produtos carregando corretamente
[] Produto pode ser adicionado ao carrinho
[] Atualização de quantidade no carrinho
[] Finalização de compra com sucesso

3. Pagamentos:
[] Pagamento aprovado atualiza status do pedido
[] Pagamento recusado exibe mensagem adequada
[] Nenhum pagamento duplicado gerado

4. Validações de campos:
[] Campos obrigatórios validados
[] Mensagens de erro claras para usuário
[] Dados inválidos não são aceitos

5. Segurança:
[] URLs protegidas exigem autenticação
[] Dados sensíveis não expostos em tela ou logs
[] HTTPS ativo

6. Performance básica:
[] Páginas principais carregam em até 3 segundos
[] API responde sem erros 5xx

7. Experiência do usuário:
[] Layout consistente em telas principais
[] Botões e links funcionam corretamente
[] Mensagens de sucesso e erro visíveis

8. Evidências:
[] Screenshots coletados
[] Logs salvos, se aplicável

Status final:
[] Apto para produção
[] Não apto para produção
</code></pre></small>
            </p>
            <p id="textoPost">Relatórios de bugs registram defeitos encontrados durante testes. Contém descrição clara do problema, passos para reprodução, resultado esperado, resultado obtido e evidências, como screenshots ou logs.
<small><pre><code>
Relatório de Bug:
ID: BUG-PAG-014
Título: Erro 500 ao finalizar pagamento com cartão de crédito
Projeto: E-commerce Web
Módulo: Pagamentos
Tipo: Defeito funcional
Severidade: Alta
Prioridade: Alta
Status: Aberto
Responsável: Time de Desenvolvimento
Reportado por: QA
Data: 15/01/2026

Ambiente:
Ambiente: Homologação
Navegador: Google Chrome 120
Sistema Operacional: Windows 11

Descrição do problema:
Ao tentar finalizar compra utilizando cartão de crédito válido, sistema retorna erro interno (HTTP 500) e não conclui pagamento.

Pré-condições:
Usuário autenticado no sistema
Produto adicionado ao carrinho
Cartão de crédito válido disponível para teste

Passos para reprodução:
Acessar sistema
Realizar login com usuário válido
Adicionar produto ao carrinho
Clicar em Finalizar compra
Selecionar pagamento via cartão de crédito
Informar dados válidos do cartão
Confirmar pagamento

Resultado esperado:
Pagamento processado com sucesso
Pedido criado com status "Pago"
Tela de confirmação exibida ao usuário

Resultado obtido:
Sistema retorna erro HTTP 500
Tela genérica de erro exibida
Pedido não é criado

Evidências:
Screenshot da tela de erro
Log da API de pagamento mostrando exceção
Request e response da requisição (HTTP 500)

Impacto:
Usuários não conseguem finalizar compras utilizando cartão de crédito, bloqueando vendas.

Observações:
Erro ocorre de forma consistente ao usar cartão Visa em ambiente de homologação.
</code></pre></small>
            </p>

            <br><hr><h4>Aula 2- SRS e design de testes:</h4>
            <ul class="text-warning">
                <li><b>Design de testes</b></li>
                <li><b>Criação de cenários de teste</b></li>
                <li><b>Escrita de casos de teste</b></li>
                <li><b>Documentação de testes</b></li>
                <li><b>Rastreabilidade entre requisitos e testes</b></li>
            </ul>
            <p id="textoPost">Documento SRS (Software Requirements Specification) descreve, de forma detalhada e estruturada, o que sistema deve fazer, quais suas restrições, regras de negócio, e requisitos funcionais e não funcionais. Requisitos funcionais descrevem o que o sistema faz (features). Exemplo: RF-01 Aluno deve realizar login com e-mail e senha. Requisitos não funcionais descrevem como sistema deve se comportar (ambiente, especificações técnicas e ferramentas). Exemplo: Sistema deve responder em até 2 segundos, Dados do aluno devem ser protegidos por autenticação JWT. Requisitos funcionais geram testes funcionais e requisitos não funcionais geram testes não funcionais. <a href="srs.pdf" class="text-decoration-none" target="_blank">Exemplo de SRS</a>.</p>
            
            <br><h4>Técnicas de análise e levantamento (elicitação) de requisitos:</h4>
            <ul>
                <li>Leitura de documentação: QA analisa documentação oficial do projeto para entender o que deve ser desenvolvido, quais são regras de negócio, restrições, e fluxos principais e alternativos;
<small><pre><code>
<b>História de Usuário</b>:
Como aluno,
Quero acessar minhas notas
Para acompanhar meu desempenho escolar.

Informações extraídas pelo QA:
Apenas alunos autenticados acessam notas
Notas são individuais
Existe tela específica de consulta

Impacto direto nos testes:
Criar teste para acesso com login válido
Criar teste para acesso sem login (bloqueio)
Criar teste para tentativa de acesso a notas de outro aluno

<b>Documento SRS</b>:
SRS Requisitos Funcionais:
RF-01: Sistema deve permitir que aluno autenticado visualize suas notas
RF-02: Sistema deve garantir que aluno visualize apenas suas próprias notas
RF-03: Acesso às notas deve ser restrito a usuários autenticados

SRS Requisitos Não Funcionais:
RNF-01: Tempo de resposta da tela de notas deve ser inferior a 2 segundos
RNF-02: Informações exibidas devem estar protegidas por autenticação.

O que QA extrai do SRS:
Login é obrigatório
Existe controle de permissão
Há requisito de desempenho
Há requisito de segurança

Impacto direto nos testes
Teste de acesso com login válido
Teste de acesso sem login (bloqueio)
Teste de tentativa de acesso a dados de outro aluno
Teste de tempo de resposta da funcionalidade

<b>Documentos funcionais</b>:
Funcionalidade: Consulta de Notas
Aluno deve acessar sistema utilizando login e senha.
Após autenticação, aluno poderá acessar o menu "Minhas Notas".
Sistema deve exibir apenas notas do aluno autenticado.
Notas devem ser exibidas por disciplina e período letivo.
Aluno não poderá editar ou excluir notas.

O que o QA identifica na leitura:
Fluxo principal de acesso
Regra de permissão
Restrições de edição
Organização das informações

Impacto direto nos testes
Teste de login obrigatório
Teste de acesso ao menu "Minhas Notas"
Teste de exibição correta por disciplina
Teste garantindo que campos são somente leitura

<b>Reuniões com PO / Cliente (baseadas no SRS)</b>:
Dúvida do QA:
"No RF-01, o sistema deve mostrar notas parciais ou apenas notas finais?"

Resposta do cliente:
"O sistema deve exibir notas parciais e finais, separadas por disciplina."

Ajuste no SRS:
Inclusão de novo requisito: RF-04 - Sistema deve exibir notas parciais e finais separadamente

Impacto nos testes:
Novo cenário de consulta por disciplina
Casos de teste para notas parciais e finais
</code></pre></small>
                </li>
                <li>Entrevistas: Conversas estruturadas ou semiestruturadas com stakeholders;
<small><pre><code>
Sistema: Sistema Escolar Web
Funcionalidade: Consulta de notas e faltas
Fase do projeto: Início do desenvolvimento

Participantes:
QA
PO (representando cliente)
Coordenador pedagógico (stakeholder)

Objetivo da entrevista:
Entender regras de negócio, permissões e exceções relacionadas à visualização de notas e faltas dos alunos.

Perguntas do QA (com raciocínio real):

QA: "Quem pode acessar as notas no sistema?"
Stakeholder: "Apenas alunos e responsáveis."
Insight: existe mais de um perfil - novos cenários de permissão.

QA: "O aluno consegue ver notas de outros alunos?"
Stakeholder: "Não, somente as próprias notas."
Insight: requisito claro de segurança e autorização.

QA: "As notas são parciais ou apenas finais?"
Stakeholder: "As duas. Durante o semestre são parciais, no final ficam consolidadas."
Insight: necessidade de testes por tipo de nota.

QA: "O responsável vê as mesmas informações que o aluno?"
Stakeholder: "Sim, mas não pode ver dados pessoais do aluno."
Insight: regra específica por perfil.

QA: "Existe algum período em que as notas ficam indisponíveis?"
Stakeholder: "Sim, durante o fechamento do semestre."
Insight: cenário de indisponibilidade - testes negativos.

Informações consolidadas após a entrevista

Requisitos funcionais levantados:
Alunos veem apenas suas notas
Responsáveis veem notas do aluno vinculado
Notas parciais e finais devem ser exibidas
Acesso bloqueado durante fechamento do semestre

Requisitos não funcionais:
Controle de acesso por perfil
Mensagem clara quando notas estiverem indisponíveis

Impacto direto no design de testes:

Cenários criados a partir da entrevista
Aluno acessa notas durante o semestre
Aluno acessa notas após fechamento
Responsável acessa notas do aluno
Tentativa de acesso indevido a notas de outro aluno

Registro da entrevista (artefato real de QA)
Ata de reunião / Registro de entrevista:
Data
Participantes
Perguntas realizadas
Decisões tomadas
Ações pendentes
Conclusão prática
</code></pre></small>
                </li>
                <li>Reuniões e Workshops (Refinamento / Grooming): encontros colaborativos entre PO, time de desenvolvimento, QA e stakeholders para detalhar, esclarecer, priorizar requisitos e alinhar entendimento, garantindo que itens estejam prontos para implementação e testes;
<small><pre><code>
Sistema: Sistema Escolar Web
Funcionalidade em refinamento: Consulta de notas
Sprint: Planejamento da Sprint 5

Participantes:
Product Owner (PO)
QA
Desenvolvedor Backend
Desenvolvedor Frontend
Scrum Master

Objetivo da reunião:
Detalhar requisitos
Quebrar a funcionalidade em cenários testáveis
Definir critérios de aceite claros
Identificar riscos antes do desenvolvimento

Simulação real da reunião:
PO apresenta a funcionalidade
PO: "O aluno precisa acessar suas notas pelo sistema."
QA inicia o refinamento com perguntas
QA: "O aluno pode ver notas de períodos anteriores?"
PO: "Sim, através de um filtro por período."
Impacto: necessidade de testes de filtro.

QA: "Se o aluno não tiver notas lançadas, o que o sistema deve mostrar?"
PO: "Uma mensagem informando que não há notas disponíveis."
Impacto: cenário negativo e validação de mensagem.

QA: "Durante o fechamento do semestre, as notas ficam disponíveis?"
PO: "Não, o acesso deve ser bloqueado temporariamente."
Impacto: novo cenário de exceção.

Desenvolvedor complementa:
Dev: "O backend vai retornar status 403 quando o acesso estiver bloqueado."
Impacto: QA define validação de status e mensagem.

Definição de critérios de aceite (resultado do grooming):
Aluno autenticado acessa suas notas
Aluno pode filtrar por período
Sistema exibe mensagem quando não houver notas
Acesso bloqueado durante fechamento do semestre
Mensagem clara para o usuário

Resultado prático da reunião:
Cenários criados
Consulta de notas com período atual
Consulta de notas com período anterior
Consulta sem notas cadastradas
Tentativa de acesso durante bloqueio

Ajustes na documentação:
Documento funcional atualizado
Critérios de aceite formalizados
Itens prontos para virar casos de teste

Artefatos gerados:
Ata de refinamento
Lista de cenários
Critérios de aceite
Pendências técnicas
Conclusão prática
</code></pre></small>
                </li>
                <li>Observação do Usuário (Shadowing): técnica onde analista ou QA acompanha usuário em seu trabalho real, observando como ele executa tarefas no dia a dia para identificar necessidades, regras implícitas, exceções e problemas que não aparecem na documentação ou nas reuniões;
<small><pre><code>
Sistema: Sistema de Gestão de Clínicas
Módulo analisado: Agendamento de consultas
Objetivo: Entender como recepcionistas realmente trabalham no dia a dia

Shadowing (na prática): Profissional (QA/Analista) acompanha, sem interferência usuário no ambiente real, observando:
Ações
Atalhos
Dificuldades
Gambiarras
Comportamentos não documentados

Usuário observado:
Recepcionista da clínica

Situação 1 - Agendamento comum
Recepcionista recebe ligação.

Observação do QA:
Abre sistema
Não usa botão "Novo Agendamento"
Vai direto na agenda do médico e clica no horário
Insight: fluxo real é diferente do fluxo desenhado.

Situação 2 - Cliente atrasado
Paciente chega atrasado.

Observação do QA:
Recepcionista apaga agendamento antigo
Cria outro manualmente
Não usa opção "Reagendar"
Insight: Funcionalidade existe, mas não é intuitiva.

Situação 3 - Falha do sistema
Sistema demora para carregar.

Observação do QA:
Recepcionista anota nome do paciente em papel
Lança no sistema depois
Insight crítico: sistema precisa suportar operação posterior (offline ou rascunho).

Perguntas feitas após observação:
QA: "Por que você não usa o botão de reagendamento?"
Usuária: "É muito demorado, prefiro apagar e refazer."
Confirma problema de usabilidade.

Problemas identificados (que ninguém tinha contado):
Fluxo real ≠ fluxo projetado
Funcionalidades pouco usadas
Dependência de papel em caso de lentidão
Risco de perda de informação

Resultados práticos do shadowing:
Requisitos descobertos:
Agendamento direto pelo calendário
Reagendamento em menos cliques
Salvamento temporário (rascunho)
Melhor feedback de carregamento

Impacto para QA:
Criação de casos de teste baseados no uso real
Testes de usabilidade
Testes de performance percebida
Testes de recuperação de falha

Artefatos gerados:
Relatório de observação
Lista de problemas reais
Sugestões de melhoria
Novos cenários de teste
Conclusão prática
</code></pre></small>
                </li>
                <li>Questionários: técnica onde perguntas estruturadas são enviadas a grupo de usuários ou stakeholders para coletar informações de forma padronizada, rápida e em escala, ajudando a identificar necessidades, expectativas, problemas recorrentes e prioridades do sistema;
<small><pre><code>
Sistema: Portal Escolar Online
Objetivo: Permitir que alunos consultem notas, faltas, calendário acadêmico e avisos
Fase do projeto: Levantamento e refinamento de requisitos
Técnica utilizada: Questionário
Público-alvo: Alunos e professores da escola

Muitos usuários
Pouco tempo para entrevistas individuais
Necessidade de dados quantitativos + qualitativos

Questionário com objetivo de melhorar Portal Escolar Online.

Seção 1 - Perfil do Usuário

1. Qual é o seu perfil?
() Aluno
() Professor
() Coordenador

2. Com que frequência você acessa o portal escolar atualmente?
() Todos os dias
() 2 a 3 vezes por semana
() Raramente
() Nunca

Seção 2 - Uso Atual do Sistema

3. Quais funcionalidades você mais utiliza?
(Marque todas que se aplicam)
[] Consulta de notas
[] Consulta de faltas
[] Calendário acadêmico
[] Avisos da escola
[] Não utilizo o sistema

4. Em qual dispositivo você mais acessa o portal?
() Computador
() Celular
() Tablet

Seção 3 - Problemas e Dores (requisitos não funcionais)

5. Você já teve dificuldades para acessar suas notas?
() Sim
() Não

Se sim, quais?
✏️ Campo aberto

6. Avalie a velocidade do sistema:
() Muito lenta
() Lenta
() Adequada
() Rápida

7. O sistema costuma apresentar erros ou instabilidade?
() Frequentemente
() Às vezes
() Raramente
() Nunca

Seção 4 - Expectativas e Requisitos Funcionais

8. Quais funcionalidades você considera essenciais?
(Marque até 3)
[] Ver notas por disciplina
[] Histórico de notas anteriores
[] Detalhamento de avaliações
[] Exportar boletim em PDF
[] Notificações de novas notas

9. Você gostaria de receber notificações quando novas notas forem lançadas?
() Sim, por e-mail
() Sim, pelo aplicativo
() Não

Seção 5 - Segurança e Privacidade

10. Você acredita que suas informações estão seguras no portal?
() Sim
() Não
() Não sei

11. Quem você acredita que pode visualizar suas notas?
(Marque todas que achar correto)
[] Apenas o aluno
[] Professores
[] Coordenação
[] Outros alunos (resposta importante para validação de regra de negócio)

Seção 6 - Pergunta Aberta (ouro do levantamento)

12. Na sua opinião, o que poderia melhorar no portal escolar?
Campo aberto

Análise dos Resultados
Após coletar respostas, time de QA / Produto percebe:
- Muitos alunos querem notificação de novas notas
- Reclamações sobre lentidão em horários de pico
- Dúvidas sobre quem pode visualizar notas (requisito de segurança)
- Forte uso via dispositivos móveis

Transformando Questionário em Requisitos e Testes
RF-01: O sistema deve permitir a visualização de notas por disciplina
RF-02: O sistema deve enviar notificações quando novas notas forem lançadas
RNF-01: O sistema deve responder em até 3 segundos em horários de pico
RNF-02: Um aluno não pode visualizar notas de outros alunos
</code></pre></small>
                </li>
                <li>Análise de Sistemas Existentes (Benchmarking): técnica que consiste em estudar sistemas similares do mercado para identificar boas práticas, funcionalidades, padrões e oportunidades de melhoria que possam ser aplicadas ao sistema em desenvolvimento;
<small><pre><code>
Empresa desenvolvendosistema escolar online para alunos e professores, com foco em consulta de notas, faltas e boletins.

Contexto do trabalho (dia a dia):
Antes de definir requisitos finais, QA e PO decidem analisar sistemas já consolidados no mercado para evitar retrabalho e alinhar produto às expectativas reais dos usuários.

Sistemas analisados (benchmark):
Google Classroom
Sistema Escolar Estadual já utilizado por outras escolas
Plataforma privada de gestão escolar (ex.: Sponte ou similar)

Atividades realizadas:
QA cria lista de funcionalidades-chave:
Login e recuperação de senha
Visualização de notas por disciplina
Histórico de boletins
Controle de faltas
Acesso por perfil (aluno, professor, coordenador)

QA navega nos sistemas benchmark e observa:
Como notas são apresentadas (tabela, gráfico, média final)
Se aluno consegue ver apenas suas próprias informações
Se há exportação de boletim em PDF
Como funciona filtro por período letivo

QA registra boas práticas encontradas:
Uso de cores para indicar aprovação/reprovação
Exibição clara do professor responsável pela disciplina
Histórico separado por ano letivo

Resultado prático gerado (requisito refinado):
"Sistema deve permitir que aluno visualize suas notas organizadas por ano letivo, com indicação visual de aprovação ou reprovação, semelhante ao padrão encontrado em sistemas escolares amplamente utilizados."

Valor para QA e testes:
Ajuda a criar cenários de teste mais realistas
Reduz risco de requisitos incompletos
Garante que sistema siga padrões já aceitos pelo mercado
Facilita validações de usabilidade e experiência do usuário
</code></pre></small>
                </li>
                <li>Prototipação: técnica que consiste em criar representações visuais ou interativas do sistema para facilitar entendimento, coletar feedback rápido dos usuários e ajustar requisitos antes do desenvolvimento;
<small><pre><code>
Equipe está desenvolvendo sistema escolar e precisa validar como será tela de consulta de notas do aluno antes de iniciar desenvolvimento.

Contexto do trabalho (dia a dia):
PO cria protótipo de baixa fidelidade (wireframe) no Figma para representar tela de "Minhas Notas". QA, desenvolvedores e grupo de alunos participam da validação.

O que protótipo contém:
Campo para seleção do ano letivo
Lista de disciplinas
Nota parcial, nota final e média
Indicador visual de aprovação/reprovação
Botão "Exportar boletim em PDF"

Atividades realizadas:
PO apresenta protótipo aos alunos e professores
Usuários navegam no protótipo simulando o uso real
QA observa dúvidas e dificuldades dos usuários

Feedback coletado:
Alunos pedem para visualizar faltas junto das notas
Professores solicitam identificação clara do peso das avaliações
Usuários confundem nota parcial com nota final

Ajustes feitos antes do desenvolvimento:
Inclusão da coluna "Faltas"
Diferenciação visual entre nota parcial e final
Tooltip explicativo sobre cálculo da média

Resultado prático para QA:
Requisitos ficaram mais claros e completos
Casos de teste puderam ser escritos antes do código existir
Redução de retrabalho e defeitos em produção
</code></pre></small>
                </li>
                <li>Análise de Critérios de Aceite: critérios objetivos que definem sucesso;
<small><pre><code>
QA analisa critérios que dizem quando funcionalidade está pronta (done).

Dado que o aluno esteja autenticado
Quando acessar a tela "Minhas Notas"
Então sistema deve exibir apenas suas notas
E não permitir acesso a notas de outros alunos

Impacto direto nos testes:
Cada critério vira, no mínimo, um caso de teste:
Teste positivo: aluno vê suas notas
Teste negativo: aluno tenta ver notas de outro aluno
</code></pre></small>
                </li>
                <li>Perguntas de Esclarecimento (Questionamento Ativo): explorar ambiguidades e riscos.
<small><pre><code>
QA questiona pontos não claros ou riscos do requisito.

"Aluno pode acessar notas sem login?"
"Aluno pode ver notas de anos anteriores?"
"Existe perfil de responsável com acesso às notas?"

Respostas e impacto nos testes:
Sem login - acesso bloqueado - teste de segurança
Anos anteriores - filtro por período - teste de filtro
Perfil responsável - novos cenários de permissão
</code></pre></small>
                </li>
            </ul>

            <br><h4>Design de Testes:</h4>
            <p>AQUI...</p>
        </div>
    </div>


<!--Rodapé-->
<div class="row">
    <div class="col-sm-12 text-center bg-black text-light pt-4 pb-3">
        <p>Elaborado por Mateus Schwede<br><small class="text-muted">ubsocial.github.io</small></p>
    </div>
</div>

</div>
</body>
</html>


<!-- ANOTAÇÕES:

-->