<!doctype html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" href="../../icons/logoTit.png">
    <link rel="stylesheet" href="../../estilo.css">
    <title>UB Social</title>
</head>
<body>
<div class="container-fluid">


    <div class="row">
        <div class="col-sm-12">
            <nav class="navbar rounded-bottom fixed-top navbar-expand-lg navbar-light bg-light shadow">
                <div class="container-fluid">
                    <a class="navbar-brand" href="../../index.html"><img src="../../icons/logo.png" class="d-inline-block align-text-top" width="11pt"> UB Social</a>
                    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
                    <div class="collapse navbar-collapse" id="navbarNav">
                        <ul class="navbar-nav">
                            <li class="nav-item"><a class="nav-link" href="../../index.html">Home</a></li>
                            <li class="nav-item"><a class="nav-link" href="../../sobre/sobre.html">Sobre</a></li>
                            <li class="nav-item"><a class="nav-link" href="../../cursos.html">Cursos</a></li>
                            <li class="nav-item"><a class="nav-link" href="../../livros/livros.html">Livros</a></li>
                        </ul>
                    </div>
                </div>
            </nav>
        </div>
    </div>

    <div class="row">
        <div class="col-sm-12 text-center" id="titulo">
            <h1>QA e Testes de software</h1>
            <h6>Conceito, princípios e aplicações</h6>
            <a href="../../index.html" class="btn btn-link text-decoration-none mb-3">Voltar</a>
        </div>

        <div class="col-sm-12">
            <p class="text-warning text-center">RESUMO EM CONSTRUÇÃO</p>
            <h4>Material complementar:</h4>
            <ul>
                <li>Conteúdo no GitHub: <a class="text-decoration-none">Acesse em breve</a></li>
                <li>Curso com certificado na Workover Academy: <a class="text-decoration-none">Acesse em breve</a></li>
            </ul>

            <br><hr><h4>Aula 1- Introdução à qualidade de software e QA:</h4>
            <p id="textoPost">QA (Quality Assurance ou Garantia da Qualidade) é conjunto de processos e práticas para prevenir defeitos (bugs) e garantir que software atenda padrões de qualidade esperados (requisitos do sistema, critérios de aceitação, normas e modelos de qualidade, padrões técnicos e boas práticas, contratos e SLAs, definição de pronto - Definition of Done), em todas fases do desenvolvimento. Profissionais de QA identificam falhas, otimizam processos e asseguram que software seja robusto e confiável, atuando de forma preventiva.</p>
            <p id="textoPost">No cotidiano, QA participa da análise de requisitos, validando regras de negócio, identificando ambiguidades e antecipando cenários de erro. Durante desenvolvimento, QA valida se features estão conforme esperado e, após entrega, contribui para estabilidade do sistema em produção. Em times ágeis, QA trabalha integradamente com desenvolvedores, POs e designers.</p>
            <p id="textoPost">Testes manuais são executados por pessoa, seguindo cenários definidos ou explorando sistema de forma livre. São essenciais em testes exploratórios, validação visual, usabilidade e testes iniciais de novas funcionalidades. Testes automatizados utilizam ferramentas e scripts para executar cenários repetitivos de forma rápida e confiável. Em ambiente de produção, são usados para validar regressões, fluxos críticos e integrações sempre que nova versão é entregue. Testes repetitivos, regressões, fluxos críticos e cenários que precisam ser executados com frequência são fortes candidatos à automação. Testes exploratórios, validações visuais e funcionalidades em constante mudança geralmente são melhores executados de forma manual, especialmente em fases iniciais do desenvolvimento. Automação permite execuções rápidas, redução de erros humanos, maior cobertura de testes e integração com pipelines de CI/CD, possibilitando validar aplicação inteira a cada deploy.</p>
<small><pre><code>
Teste manual, cenário Login de usuário:
Abrir aplicação no navegador
Informar e-mail válido e senha válida
Clicar em Entrar
Verificar se sistema redireciona para página inicial e exibe nome do usuário

Teste automatizado, cenário Login de usuário (exemplo em pseudocódigo Python):
def test_senha_com_tamanho_minimo():
    senha = "123456"
    resultado = validar_senha(senha)
    assert resultado is True
</code></pre></small>
            <ul>
                <li>Testes unitários (unit tests): validam pequenas partes do código, como funções ou métodos isolados. Exemplo: testar se função de cálculo de desconto retorna valor correto para diferentes entradas;
<small><pre><code>
Loja online aplica 10% de desconto para compras acima de R$ 100,00. Função responsável por calcular valor final da compra.

Regra de negócio:
Valor a menor ou igual a 100 = não aplica desconto
Valor maior que 100 = aplica 10% de desconto

Teste unitário (exemplo prático)
def test_calcular_desconto():
    assert calcular_desconto(80) == 80
    assert calcular_desconto(100) == 100
    assert calcular_desconto(200) == 180
</code></pre></small>
                </li>
                <li>Testes de integração (integration tests): validam comunicação entre componentes, serviços ou APIs. Exemplo: verificar se API de pedidos consegue se comunicar corretamente com API de pagamentos;
<small><pre><code>
Sistema de e-commerce possui API de Pedidos, que cria pedidos, e API de Pagamentos, que processa pagamentos. Quando pedido é criado, API de Pedidos chama API de Pagamentos para cobrar cliente.

Regra de negócio:
Se pagamento for aprovado, pedido fica com status "PAGO"
Se pagamento falhar, pedido fica com status "RECUSADO"

def test_criar_pedido_com_pagamento_aprovado(client):
    response = client.post("/api/pedidos/", json=&#123;
        "produto_id": 1,
        "quantidade": 2,
        "cartao": "4111111111111111"
    &#125;)

    assert response.status_code == 201
    assert response.json()["status"] == "PAGO"
</code></pre></small>
                </li>
                <li>Testes de sistema (system tests): validam sistema como todo, considerando todas integrações e fluxos principais, verificando se comportamento geral da aplicação atende ao esperado, segundo critérios de aceitação;
<small><pre><code>
Sistema: E-commerce web
Objetivo do sistema: permitir que usuário compre produto do início ao fim.

Critério de aceitação:
Usuário consegue comprar produto com sucesso
Pagamento é aprovado
Pedido aparece no histórico do usuário
Teste de sistema (exemplo prático)

Fluxo executado:
Usuário acessa site
Realiza login
Adiciona produto ao carrinho
Finaliza compra
Sistema processa pagamento
Pedido é confirmado e exibido no histórico

Validações:
Tela de confirmação exibida
Status do pedido: "Confirmado"
Pagamento registrado no sistema
Pedido visível no histórico
</code></pre></small>
                </li>
                <li>Testes de aceitação: validam se sistema atende às regras de negócio definidas pelo cliente ou usuário final. Exemplo: validar se aluno consegue acessar suas notas após realizar login em sistema escolar.
<small><pre><code>
Sistema: Sistema escolar online

Regra de negócio (definida pelo cliente):
Apenas alunos autenticados podem visualizar suas próprias notas
Notas devem corresponder ao aluno logado

Teste de aceitação (exemplo prático):
Cenário: Aluno acessa suas notas após login
Dado que aluno possui cadastro ativo no sistema
Quando aluno realiza login com usuário e senha válidos
E acessa opção "Minhas Notas"
Sistema exibe apenas notas daquele aluno da sessão
</code></pre></small>
                </li>
            </ul>
            <p id="textoPost">Testes funcionais verificam se funcionalidades do sistema funcionam conforme esperado, como login, cadastro, busca e envio de formulários. Testes não funcionais avaliam características como desempenho, segurança, usabilidade e compatibilidade, inclui testar quantos usuários simultâneos o sistema suporta ou se dados sensíveis estão protegidos adequadamente.
<small><pre><code>
TESTE FUNCIONAL:
Sistema: Aplicativo bancário
Cenário: Pix entre contas

Usuário realiza login
Informa Pix de destino e valor de R$ 500,00
Confirma Pix

Resultado esperado:
Valor é debitado da conta de origem
Valor é creditado na conta de destino
Sistema exibe mensagem de sucesso

TESTE NÃO FUNCIONAL:
Sistema: API bancária
Cenário: Tempo de resposta da API de Pix
Realizar 1.000 requisições simultâneas de Pix
Medir tempo de resposta

Resultado esperado:
95% das requisições respondem em até 2 segundos
Nenhuma requisição retorna erro 5xx
</code></pre></small>
            </p>
            <p id="textoPost">Pirâmide de testes é modelo de distribuição dos tipos de testes (E2E Tests, Service Tests, Unit Tests). Na base estão testes unitários, em maior quantidade e com execução rápida. No meio, testes de integração. No topo, testes de sistema e End-to-End, em menor quantidade, sendo mais lentos e complexos. Pirâmide ajuda reduzir custos, acelerar feedbacks e manter estabilidade do desenvolvimento do sistema.</p>
            <p id="textoPost">Artefatos de QA são documentos e registros utilizados para planejar, executar e acompanhar testes, garantindo rastreabilidade, organização e comunicação entre time.
<small><pre><code>
1. Plano de Testes: documento que define o que será testado, como, quando e por quem. Exemplo:
Plano descrevendo que:
Testes unitários serão feitos com pytest
Testes de integração cobrem APIs de pedidos e pagamentos
Ambiente de homologação será usado antes da produção

2. Casos de Teste: descrição passo a passo de como validar funcionalidade. Exemplo:
Caso de teste: Login com senha válida
Entrada: e-mail e senha corretos
Ação: clicar em "Entrar"
Resultado esperado: redirecionamento para dashboard

3. Cenários de Teste: visão mais alto nível, focada no fluxo. Exemplo:
Cenário: Compra de produto com pagamento aprovado

4. Relatório de Bugs (Defect Report): registro formal de erro encontrado. Exemplo:
Título: Erro ao finalizar pagamento com cartão
Ambiente: Homologação
Resultado esperado: pagamento aprovado
Resultado obtido: erro 500

5. Checklist de Testes: lista rápida para validação básica. Exemplo:
Login funciona
API retorna status 200
Campos obrigatórios validados

6. Relatório de Execução de Testes: mostra status dos testes executados. Exemplo:
Total de testes: 120
Passaram: 110
Falharam: 10

7. Matriz de Rastreabilidade: relaciona requisitos aos testes. Exemplo:
Requisito RF-01: Caso de Teste CT-05

8. Evidências de Teste: comprovação da execução do teste. Exemplo:
Screenshot da tela de confirmação
Log de execução de teste automatizado
</code></pre></small>
            </p>
            <p id="textoPost">Casos de teste descrevem passo a passo como validar funcionalidade, incluindo pré-condições, dados de entrada, ações e resultados esperados. Exemplo: descrever todo fluxo de login de usuário, desde inserção de credenciais até acesso ao sistema.
<small><pre><code>
Caso de Teste Completo - Login de Usuário
ID: CT-AUTH-LOGIN-001
Título: Login com credenciais válidas
Módulo: Autenticação
Tipo de teste: Funcional / Sistema
Prioridade: Alta
Autor: QA Team
Data: 15/01/2026

Objetivo: validar se o usuário consegue acessar sistema, informando credenciais válidas, conforme regras de negócio definidas.

Pré-condições:
Usuário cadastrado e ativo no sistema
Usuário não está logado
Sistema disponível
Navegador Google Chrome atualizado

Ambiente: Homologação

Dados de teste (campo, valor):
E-mail: usuario@exemplo.com
Senha: Senha@123

Passos de execução:
Acessar URL do sistema
Clicar na opção Login
Informar e-mail no campo correspondente
Informar senha no campo correspondente
Clicar no botão Entrar

Resultado esperado:
Sistema valida credenciais
Usuário é autenticado com sucesso
Redirecionamento para página inicial
Nome do usuário exibido no topo da tela
Token de sessão criado

Resultado obtido: (Preenchido durante a execução)

Status: (Aprovado / Reprovado)

Evidências: Screenshot da tela inicial após login

Log da requisição de autenticação

Observações:
Caso de teste pode ser reutilizado para automação
Base para cenários negativos (senha inválida, usuário inativo)
</code></pre></small>
            </p>
            <p id="textoPost">Checklists são listas simples de verificações que devem ser realizadas durante teste. Muito usados em testes exploratórios, revisões rápidas ou validações antes de entrega em produção.
<small><pre><code>
Checklist de Testes - Liberação para Produção

Sistema: Plataforma Web de E-commerce
Módulo: Autenticação e Compra
Ambiente: Homologação
Responsável: QA
Data: 15/01/2026

1. Autenticação:
[] Login com credenciais válidas
[] Bloqueio após tentativas inválidas
[] Logout funcionando corretamente
[] Sessão expira após tempo de inatividade

2. Funcionalidades principais:
[] Listagem de produtos carregando corretamente
[] Produto pode ser adicionado ao carrinho
[] Atualização de quantidade no carrinho
[] Finalização de compra com sucesso

3. Pagamentos:
[] Pagamento aprovado atualiza status do pedido
[] Pagamento recusado exibe mensagem adequada
[] Nenhum pagamento duplicado gerado

4. Validações de campos:
[] Campos obrigatórios validados
[] Mensagens de erro claras para usuário
[] Dados inválidos não são aceitos

5. Segurança:
[] URLs protegidas exigem autenticação
[] Dados sensíveis não expostos em tela ou logs
[] HTTPS ativo

6. Performance básica:
[] Páginas principais carregam em até 3 segundos
[] API responde sem erros 5xx

7. Experiência do usuário:
[] Layout consistente em telas principais
[] Botões e links funcionam corretamente
[] Mensagens de sucesso e erro visíveis

8. Evidências:
[] Screenshots coletados
[] Logs salvos, se aplicável

Status final:
[] Apto para produção
[] Não apto para produção
</code></pre></small>
            </p>
            <p id="textoPost">Relatórios de bugs registram defeitos encontrados durante testes. Contém descrição clara do problema, passos para reprodução, resultado esperado, resultado obtido e evidências, como screenshots ou logs.
<small><pre><code>
Relatório de Bug:
ID: BUG-PAG-014
Título: Erro 500 ao finalizar pagamento com cartão de crédito
Projeto: E-commerce Web
Módulo: Pagamentos
Tipo: Defeito funcional
Severidade: Alta
Prioridade: Alta
Status: Aberto
Responsável: Time de Desenvolvimento
Reportado por: QA
Data: 15/01/2026

Ambiente:
Ambiente: Homologação
Navegador: Google Chrome 120
Sistema Operacional: Windows 11

Descrição do problema:
Ao tentar finalizar compra utilizando cartão de crédito válido, sistema retorna erro interno (HTTP 500) e não conclui pagamento.

Pré-condições:
Usuário autenticado no sistema
Produto adicionado ao carrinho
Cartão de crédito válido disponível para teste

Passos para reprodução:
Acessar sistema
Realizar login com usuário válido
Adicionar produto ao carrinho
Clicar em Finalizar compra
Selecionar pagamento via cartão de crédito
Informar dados válidos do cartão
Confirmar pagamento

Resultado esperado:
Pagamento processado com sucesso
Pedido criado com status "Pago"
Tela de confirmação exibida ao usuário

Resultado obtido:
Sistema retorna erro HTTP 500
Tela genérica de erro exibida
Pedido não é criado

Evidências:
Screenshot da tela de erro
Log da API de pagamento mostrando exceção
Request e response da requisição (HTTP 500)

Impacto:
Usuários não conseguem finalizar compras utilizando cartão de crédito, bloqueando vendas.

Observações:
Erro ocorre de forma consistente ao usar cartão Visa em ambiente de homologação.
</code></pre></small>
            </p>

            <br><hr><h4>Aula 2- SRS e design de testes:</h4>
            <p id="textoPost">Documento SRS (Software Requirements Specification) descreve, de forma detalhada e estruturada, o que sistema deve fazer, quais suas restrições, regras de negócio, e requisitos funcionais e não funcionais. Requisitos funcionais descrevem o que o sistema faz (features). Exemplo: RF-01 Aluno deve realizar login com e-mail e senha. Requisitos não funcionais descrevem como sistema deve se comportar (ambiente, especificações técnicas e ferramentas). Exemplo: Sistema deve responder em até 2 segundos, Dados do aluno devem ser protegidos por autenticação JWT. Requisitos funcionais geram testes funcionais e requisitos não funcionais geram testes não funcionais. <a href="srs.pdf" class="text-decoration-none" target="_blank">Exemplo de SRS</a>.</p>
            
            <br><h4>Técnicas de análise e levantamento (elicitação) de requisitos:</h4>
            <ul>
                <li>Leitura de documentação: QA analisa documentação oficial do projeto para entender o que deve ser desenvolvido, quais são regras de negócio, restrições, e fluxos principais e alternativos;
<small><pre><code>
<b>História de Usuário</b>:
Como aluno,
Quero acessar minhas notas
Para acompanhar meu desempenho escolar.

Informações extraídas pelo QA:
Apenas alunos autenticados acessam notas
Notas são individuais
Existe tela específica de consulta

Impacto direto nos testes:
Criar teste para acesso com login válido
Criar teste para acesso sem login (bloqueio)
Criar teste para tentativa de acesso a notas de outro aluno

<b>Documento SRS</b>:
SRS Requisitos Funcionais:
RF-01: Sistema deve permitir que aluno autenticado visualize suas notas
RF-02: Sistema deve garantir que aluno visualize apenas suas próprias notas
RF-03: Acesso às notas deve ser restrito a usuários autenticados

SRS Requisitos Não Funcionais:
RNF-01: Tempo de resposta da tela de notas deve ser inferior a 2 segundos
RNF-02: Informações exibidas devem estar protegidas por autenticação.

O que QA extrai do SRS:
Login é obrigatório
Existe controle de permissão
Há requisito de desempenho
Há requisito de segurança

Impacto direto nos testes
Teste de acesso com login válido
Teste de acesso sem login (bloqueio)
Teste de tentativa de acesso a dados de outro aluno
Teste de tempo de resposta da funcionalidade

<b>Documentos funcionais</b>:
Funcionalidade: Consulta de Notas
Aluno deve acessar sistema utilizando login e senha.
Após autenticação, aluno poderá acessar o menu "Minhas Notas".
Sistema deve exibir apenas notas do aluno autenticado.
Notas devem ser exibidas por disciplina e período letivo.
Aluno não poderá editar ou excluir notas.

O que o QA identifica na leitura:
Fluxo principal de acesso
Regra de permissão
Restrições de edição
Organização das informações

Impacto direto nos testes
Teste de login obrigatório
Teste de acesso ao menu "Minhas Notas"
Teste de exibição correta por disciplina
Teste garantindo que campos são somente leitura

<b>Reuniões com PO / Cliente (baseadas no SRS)</b>:
Dúvida do QA:
"No RF-01, o sistema deve mostrar notas parciais ou apenas notas finais?"

Resposta do cliente:
"O sistema deve exibir notas parciais e finais, separadas por disciplina."

Ajuste no SRS:
Inclusão de novo requisito: RF-04 - Sistema deve exibir notas parciais e finais separadamente

Impacto nos testes:
Novo cenário de consulta por disciplina
Casos de teste para notas parciais e finais
</code></pre></small>
                </li>
                <li>Entrevistas: Conversas estruturadas ou semiestruturadas com stakeholders;
<small><pre><code>
Sistema: Sistema Escolar Web
Funcionalidade: Consulta de notas e faltas
Fase do projeto: Início do desenvolvimento

Participantes:
QA
PO (representando cliente)
Coordenador pedagógico (stakeholder)

Objetivo da entrevista:
Entender regras de negócio, permissões e exceções relacionadas à visualização de notas e faltas dos alunos.

Perguntas do QA (com raciocínio real):

QA: "Quem pode acessar as notas no sistema?"
Stakeholder: "Apenas alunos e responsáveis."
Insight: existe mais de um perfil - novos cenários de permissão.

QA: "O aluno consegue ver notas de outros alunos?"
Stakeholder: "Não, somente as próprias notas."
Insight: requisito claro de segurança e autorização.

QA: "As notas são parciais ou apenas finais?"
Stakeholder: "As duas. Durante o semestre são parciais, no final ficam consolidadas."
Insight: necessidade de testes por tipo de nota.

QA: "O responsável vê as mesmas informações que o aluno?"
Stakeholder: "Sim, mas não pode ver dados pessoais do aluno."
Insight: regra específica por perfil.

QA: "Existe algum período em que as notas ficam indisponíveis?"
Stakeholder: "Sim, durante o fechamento do semestre."
Insight: cenário de indisponibilidade - testes negativos.

Informações consolidadas após a entrevista

Requisitos funcionais levantados:
Alunos veem apenas suas notas
Responsáveis veem notas do aluno vinculado
Notas parciais e finais devem ser exibidas
Acesso bloqueado durante fechamento do semestre

Requisitos não funcionais:
Controle de acesso por perfil
Mensagem clara quando notas estiverem indisponíveis

Impacto direto no design de testes:

Cenários criados a partir da entrevista
Aluno acessa notas durante o semestre
Aluno acessa notas após fechamento
Responsável acessa notas do aluno
Tentativa de acesso indevido a notas de outro aluno

Registro da entrevista (artefato real de QA)
Ata de reunião / Registro de entrevista:
Data
Participantes
Perguntas realizadas
Decisões tomadas
Ações pendentes
Conclusão prática
</code></pre></small>
                </li>
                <li>Reuniões e Workshops (Refinamento / Grooming): encontros colaborativos entre PO, time de desenvolvimento, QA e stakeholders para detalhar, esclarecer, priorizar requisitos e alinhar entendimento, garantindo que itens estejam prontos para implementação e testes;
<small><pre><code>
Sistema: Sistema Escolar Web
Funcionalidade em refinamento: Consulta de notas
Sprint: Planejamento da Sprint 5

Participantes:
Product Owner (PO)
QA
Desenvolvedor Backend
Desenvolvedor Frontend
Scrum Master

Objetivo da reunião:
Detalhar requisitos
Quebrar a funcionalidade em cenários testáveis
Definir critérios de aceite claros
Identificar riscos antes do desenvolvimento

Simulação real da reunião:
PO apresenta a funcionalidade
PO: "O aluno precisa acessar suas notas pelo sistema."
QA inicia o refinamento com perguntas
QA: "O aluno pode ver notas de períodos anteriores?"
PO: "Sim, através de um filtro por período."
Impacto: necessidade de testes de filtro.

QA: "Se o aluno não tiver notas lançadas, o que o sistema deve mostrar?"
PO: "Uma mensagem informando que não há notas disponíveis."
Impacto: cenário negativo e validação de mensagem.

QA: "Durante o fechamento do semestre, as notas ficam disponíveis?"
PO: "Não, o acesso deve ser bloqueado temporariamente."
Impacto: novo cenário de exceção.

Desenvolvedor complementa:
Dev: "O backend vai retornar status 403 quando o acesso estiver bloqueado."
Impacto: QA define validação de status e mensagem.

Definição de critérios de aceite (resultado do grooming):
Aluno autenticado acessa suas notas
Aluno pode filtrar por período
Sistema exibe mensagem quando não houver notas
Acesso bloqueado durante fechamento do semestre
Mensagem clara para o usuário

Resultado prático da reunião:
Cenários criados
Consulta de notas com período atual
Consulta de notas com período anterior
Consulta sem notas cadastradas
Tentativa de acesso durante bloqueio

Ajustes na documentação:
Documento funcional atualizado
Critérios de aceite formalizados
Itens prontos para virar casos de teste

Artefatos gerados:
Ata de refinamento
Lista de cenários
Critérios de aceite
Pendências técnicas
Conclusão prática
</code></pre></small>
                </li>
                <li>Observação do Usuário (Shadowing): técnica onde analista ou QA acompanha usuário em seu trabalho real, observando como ele executa tarefas no dia a dia para identificar necessidades, regras implícitas, exceções e problemas que não aparecem na documentação ou nas reuniões;
<small><pre><code>
Sistema: Sistema de Gestão de Clínicas
Módulo analisado: Agendamento de consultas
Objetivo: Entender como recepcionistas realmente trabalham no dia a dia

Shadowing (na prática): Profissional (QA/Analista) acompanha, sem interferência usuário no ambiente real, observando:
Ações
Atalhos
Dificuldades
Gambiarras
Comportamentos não documentados

Usuário observado:
Recepcionista da clínica

Situação 1 - Agendamento comum
Recepcionista recebe ligação.

Observação do QA:
Abre sistema
Não usa botão "Novo Agendamento"
Vai direto na agenda do médico e clica no horário
Insight: fluxo real é diferente do fluxo desenhado.

Situação 2 - Cliente atrasado
Paciente chega atrasado.

Observação do QA:
Recepcionista apaga agendamento antigo
Cria outro manualmente
Não usa opção "Reagendar"
Insight: Funcionalidade existe, mas não é intuitiva.

Situação 3 - Falha do sistema
Sistema demora para carregar.

Observação do QA:
Recepcionista anota nome do paciente em papel
Lança no sistema depois
Insight crítico: sistema precisa suportar operação posterior (offline ou rascunho).

Perguntas feitas após observação:
QA: "Por que você não usa o botão de reagendamento?"
Usuária: "É muito demorado, prefiro apagar e refazer."
Confirma problema de usabilidade.

Problemas identificados (que ninguém tinha contado):
Fluxo real ≠ fluxo projetado
Funcionalidades pouco usadas
Dependência de papel em caso de lentidão
Risco de perda de informação

Resultados práticos do shadowing:
Requisitos descobertos:
Agendamento direto pelo calendário
Reagendamento em menos cliques
Salvamento temporário (rascunho)
Melhor feedback de carregamento

Impacto para QA:
Criação de casos de teste baseados no uso real
Testes de usabilidade
Testes de performance percebida
Testes de recuperação de falha

Artefatos gerados:
Relatório de observação
Lista de problemas reais
Sugestões de melhoria
Novos cenários de teste
Conclusão prática
</code></pre></small>
                </li>
                <li>Questionários: técnica onde perguntas estruturadas são enviadas a grupo de usuários ou stakeholders para coletar informações de forma padronizada, rápida e em escala, ajudando a identificar necessidades, expectativas, problemas recorrentes e prioridades do sistema;
<small><pre><code>
Sistema: Portal Escolar Online
Objetivo: Permitir que alunos consultem notas, faltas, calendário acadêmico e avisos
Fase do projeto: Levantamento e refinamento de requisitos
Técnica utilizada: Questionário
Público-alvo: Alunos e professores da escola

Muitos usuários
Pouco tempo para entrevistas individuais
Necessidade de dados quantitativos + qualitativos

Questionário com objetivo de melhorar Portal Escolar Online.

Seção 1 - Perfil do Usuário

1. Qual é o seu perfil?
() Aluno
() Professor
() Coordenador

2. Com que frequência você acessa o portal escolar atualmente?
() Todos os dias
() 2 a 3 vezes por semana
() Raramente
() Nunca

Seção 2 - Uso Atual do Sistema

3. Quais funcionalidades você mais utiliza?
(Marque todas que se aplicam)
[] Consulta de notas
[] Consulta de faltas
[] Calendário acadêmico
[] Avisos da escola
[] Não utilizo o sistema

4. Em qual dispositivo você mais acessa o portal?
() Computador
() Celular
() Tablet

Seção 3 - Problemas e Dores (requisitos não funcionais)

5. Você já teve dificuldades para acessar suas notas?
() Sim
() Não

Se sim, quais?
✏️ Campo aberto

6. Avalie a velocidade do sistema:
() Muito lenta
() Lenta
() Adequada
() Rápida

7. O sistema costuma apresentar erros ou instabilidade?
() Frequentemente
() Às vezes
() Raramente
() Nunca

Seção 4 - Expectativas e Requisitos Funcionais

8. Quais funcionalidades você considera essenciais?
(Marque até 3)
[] Ver notas por disciplina
[] Histórico de notas anteriores
[] Detalhamento de avaliações
[] Exportar boletim em PDF
[] Notificações de novas notas

9. Você gostaria de receber notificações quando novas notas forem lançadas?
() Sim, por e-mail
() Sim, pelo aplicativo
() Não

Seção 5 - Segurança e Privacidade

10. Você acredita que suas informações estão seguras no portal?
() Sim
() Não
() Não sei

11. Quem você acredita que pode visualizar suas notas?
(Marque todas que achar correto)
[] Apenas o aluno
[] Professores
[] Coordenação
[] Outros alunos (resposta importante para validação de regra de negócio)

Seção 6 - Pergunta Aberta (ouro do levantamento)

12. Na sua opinião, o que poderia melhorar no portal escolar?
Campo aberto

Análise dos Resultados
Após coletar respostas, time de QA / Produto percebe:
- Muitos alunos querem notificação de novas notas
- Reclamações sobre lentidão em horários de pico
- Dúvidas sobre quem pode visualizar notas (requisito de segurança)
- Forte uso via dispositivos móveis

Transformando Questionário em Requisitos e Testes
RF-01: O sistema deve permitir a visualização de notas por disciplina
RF-02: O sistema deve enviar notificações quando novas notas forem lançadas
RNF-01: O sistema deve responder em até 3 segundos em horários de pico
RNF-02: Um aluno não pode visualizar notas de outros alunos
</code></pre></small>
                </li>
                <li>Análise de Sistemas Existentes (Benchmarking): técnica que consiste em estudar sistemas similares do mercado para identificar boas práticas, funcionalidades, padrões e oportunidades de melhoria que possam ser aplicadas ao sistema em desenvolvimento;
<small><pre><code>
Empresa desenvolvendosistema escolar online para alunos e professores, com foco em consulta de notas, faltas e boletins.

Contexto do trabalho (dia a dia):
Antes de definir requisitos finais, QA e PO decidem analisar sistemas já consolidados no mercado para evitar retrabalho e alinhar produto às expectativas reais dos usuários.

Sistemas analisados (benchmark):
Google Classroom
Sistema Escolar Estadual já utilizado por outras escolas
Plataforma privada de gestão escolar (ex.: Sponte ou similar)

Atividades realizadas:
QA cria lista de funcionalidades-chave:
Login e recuperação de senha
Visualização de notas por disciplina
Histórico de boletins
Controle de faltas
Acesso por perfil (aluno, professor, coordenador)

QA navega nos sistemas benchmark e observa:
Como notas são apresentadas (tabela, gráfico, média final)
Se aluno consegue ver apenas suas próprias informações
Se há exportação de boletim em PDF
Como funciona filtro por período letivo

QA registra boas práticas encontradas:
Uso de cores para indicar aprovação/reprovação
Exibição clara do professor responsável pela disciplina
Histórico separado por ano letivo

Resultado prático gerado (requisito refinado):
"Sistema deve permitir que aluno visualize suas notas organizadas por ano letivo, com indicação visual de aprovação ou reprovação, semelhante ao padrão encontrado em sistemas escolares amplamente utilizados."

Valor para QA e testes:
Ajuda a criar cenários de teste mais realistas
Reduz risco de requisitos incompletos
Garante que sistema siga padrões já aceitos pelo mercado
Facilita validações de usabilidade e experiência do usuário
</code></pre></small>
                </li>
                <li>Prototipação: técnica que consiste em criar representações visuais ou interativas do sistema para facilitar entendimento, coletar feedback rápido dos usuários e ajustar requisitos antes do desenvolvimento;
<small><pre><code>
Equipe está desenvolvendo sistema escolar e precisa validar como será tela de consulta de notas do aluno antes de iniciar desenvolvimento.

Contexto do trabalho (dia a dia):
PO cria protótipo de baixa fidelidade (wireframe) no Figma para representar tela de "Minhas Notas". QA, desenvolvedores e grupo de alunos participam da validação.

O que protótipo contém:
Campo para seleção do ano letivo
Lista de disciplinas
Nota parcial, nota final e média
Indicador visual de aprovação/reprovação
Botão "Exportar boletim em PDF"

Atividades realizadas:
PO apresenta protótipo aos alunos e professores
Usuários navegam no protótipo simulando o uso real
QA observa dúvidas e dificuldades dos usuários

Feedback coletado:
Alunos pedem para visualizar faltas junto das notas
Professores solicitam identificação clara do peso das avaliações
Usuários confundem nota parcial com nota final

Ajustes feitos antes do desenvolvimento:
Inclusão da coluna "Faltas"
Diferenciação visual entre nota parcial e final
Tooltip explicativo sobre cálculo da média

Resultado prático para QA:
Requisitos ficaram mais claros e completos
Casos de teste puderam ser escritos antes do código existir
Redução de retrabalho e defeitos em produção
</code></pre></small>
                </li>
                <li>Análise de Critérios de Aceite: critérios objetivos que definem sucesso;
<small><pre><code>
QA analisa critérios que dizem quando funcionalidade está pronta (done).

Dado que o aluno esteja autenticado
Quando acessar a tela "Minhas Notas"
Então sistema deve exibir apenas suas notas
E não permitir acesso a notas de outros alunos

Impacto direto nos testes:
Cada critério vira, no mínimo, um caso de teste:
Teste positivo: aluno vê suas notas
Teste negativo: aluno tenta ver notas de outro aluno
</code></pre></small>
                </li>
                <li>Perguntas de Esclarecimento (Questionamento Ativo): explorar ambiguidades e riscos.
<small><pre><code>
QA questiona pontos não claros ou riscos do requisito.

"Aluno pode acessar notas sem login?"
"Aluno pode ver notas de anos anteriores?"
"Existe perfil de responsável com acesso às notas?"

Respostas e impacto nos testes:
Sem login - acesso bloqueado - teste de segurança
Anos anteriores - filtro por período - teste de filtro
Perfil responsável - novos cenários de permissão
</code></pre></small>
                </li>
            </ul>

            <br><h4>Test Case Design:</h4>
            <p id="textoPost">Técnicas para organizar, estrategicamente, informações dos testes.</p>
            <ul>
                <li>Funcional (caixa-preta - Black-box testing): testes que irão verificar se comportamento do software está conforme esperado. Não são verificados códigos ou arquiteturas;</li>
                <li>Estrutural (caixa-branca - White-box testing): testes que verificam códigos e/ou arquitetura do software, sendo diretamente ligados ao código;</li>
                <li>Não-funcional: testes relacionados aos comportamentos agregados as funcionalidades, não as funcionalidades propriamente ditas, como testes de performance, segurança, usabilidade e quaisquer outros que envolvam comportamentos gerados de funcionalidade ou sistema como todo;</li>
                <li>Orientados a mudança: testes realizados após comportamentos inesperados ou indesejados das funcionalidades testadas. Para casos pós falha, são aplicados testes de confirmação, para verificar se mesma ainda ocorre ou foi corrigida, como revisão de bugs corrigidos. Casos onde 1º resultado passou, são realizados testes de regressão quando há alteração de outras funcionalidades que podem gerar bugs de efeito colateral.</li>
            </ul>
            <ul>
                <li>Validação: verifica conformidade do software de acordo com exigências de qualidade do cliente. sendo realizados testes caixa-preta aplicados por profissionais que não desenvolveram o software;</li>
                <li>Verificação: verifica conformidade da implementação do software afim de garantir que a mesma está correta. São utilizados testes caixa-branca, mais comumente aplicados pelos próprios desenvolvedores, com auxilio de ferramentas.</li>
            </ul>

            <p id="textoPost">(Etapa 1) Análise e elicitação de requisitos visa coletar e analisar requisitos de software para verificar alinhamento com objetivos de negócios e necessidades técnicas. Compõe das seguintes etapas:</p>
            <ol>
                <li>Revisão dos requisitos funcionais e não funcionais;</li>
                <li>Priorização de áreas de alto risco e funcionalidades críticas;</li>
                <li>Mapeamento das condições de teste com objetivos do projeto para garantir cobertura completa.</li>
            </ol>
<small><pre><code>
Produto: Sistema Web de Pedidos para Cafeteria
Objetivo de negócio: permitir que clientes realizem pedidos online e que cafeteria gerencie pedidos de forma eficiente.

Stakeholders:
Product Owner (PO)
Desenvolvedores
QA Analyst

1. Revisão dos Requisitos Funcionais e Não Funcionais:

Requisitos Funcionais (RF):
RF01: cliente deve conseguir realizar pedido selecionando produtos do cardápio.
RF02: sistema deve calcular automaticamente valor total do pedido.
RF03: atendente deve visualizar pedidos em tempo real.
RF04: cliente deve receber confirmação do pedido.

Requisitos Não Funcionais (RNF):
RNF01: sistema deve responder em até 2 segundos para ações principais.
RNF02: sistema deve estar disponível 99% do tempo.
RNF03: sistema deve funcionar nos navegadores Chrome e Firefox.

Atuação prática do QA: QA analisa requisitos e levanta pontos como:
RF01 não define: Quantidade máxima de itens? É permitido pedido vazio?
RF02: Como tratar valores decimais? Regras de arredondamento?
RF04: Confirmação via tela? E-mail? Ambos?

2. Priorização de Áreas de Alto Risco e Funcionalidades Críticas

Funcionalidade - Impacto no Negócio - Probabilidade de Falha - Risco
Realizar pedido - Alto - Alto - Alto
Cálculo de valores - Alto - Médio - Alto
Visualização pelo atendente - Médio - Médio - Médio
Confirmação do pedido - Médio - Baixo - Baixo

Testes mais profundos e antecipados em:
Fluxo de criação de pedido
Cálculo de preço
Automatizar testes do cálculo do pedido
Executar testes exploratórios no fluxo principal

3. Mapeamento das Condições de Teste com os Objetivos do Projeto
Objetivo de Negócio: Permitir que clientes realizem pedidos online sem erros e com rapidez.

Condições de Teste Criadas pelo QA:
Objetivo do Projeto - Requisito - Condição de Teste
Pedido sem falhas - RF01 - Validar criação de pedido com itens válidos
Pedido sem falhas - RF01 - Validar bloqueio de pedido sem itens
Valor correto - RF02 - Validar soma correta com múltiplos produtos
Valor correto - RF02 - Validar arredondamento de valores
Rapidez - RNF01 - Validar resposta em até 2s
Compatibilidade - RNF03 - Validar fluxo completo no Chrome e Firefox

Resultado Gerado pelo QA (Entregáveis Reais):
Checklist de requisitos validados
Lista de dúvidas e gaps de requisitos
Mapa de risco por funcionalidade
Condições de teste ligadas aos objetivos de negócio
Base sólida para criação dos casos de teste
</code></pre></small>

            <p id="textoPost">(Etapa 2) Identificação do Test Scenario ocorre após requisitos definidos com precisão, onde testers dividem aplicação em modelos lógicos. Compõe das seguintes fases:</p>
            <ol>
                <li>Identificar interações e fluxos de trabalho do usuário;</li>
                <li>Verificar condições de entrada válidas e inválidas;</li>
                <li>Avaliar pontos de integração com APIs, bancos de dados e sistemas externos.</li>
            </ol>
<small><pre><code>
Contexto do Projeto - Sistema web de pedidos para uma cafeteria, composto por:
Frontend web
Backend com API REST
Banco de dados relacional
Serviço externo de notificação de pedidos

Objetivo do QA nesta etapa: Identificar cenários de teste macro, antes de detalhar casos de teste.

1. Identificação das Interações e Fluxos de Trabalho do Usuário:

Fluxo principal (happy path):
Usuário acessa sistema
Usuário visualiza cardápio
Usuário adiciona produtos ao pedido
Usuário altera quantidades
Usuário visualiza valor total atualizado
Usuário finaliza pedido
Sistema exibe confirmação do pedido

Fluxos alternativos:
Usuário remove item do pedido
Usuário tenta finalizar pedido sem itens
Usuário abandona pedido antes da finalização
Usuário tenta adicionar produto indisponível

2. Definição dos Test Scenarios Baseados nos Fluxos:

Test Scenarios de Usuário:
Criar pedido com um item válido
Criar pedido com múltiplos itens válidos
Atualizar quantidade de item no pedido
Remover item do pedido antes da finalização
Tentar finalizar pedido sem itens
Cancelar pedido durante o fluxo

Esses cenários representam modelos lógicos da aplicação, não casos de teste ainda.

3. Verificação das Condições de Entrada:

Condições de Entrada Válidas:
Produto existente no cardápio
Quantidade maior que zero
Sessão de usuário ativa
API respondendo com status de sucesso
Dados enviados no formato esperado

Condições de Entrada Inválidas:
Produto inexistente
Quantidade zero ou negativa
Finalização de pedido sem itens
Payload com dados inválidos
Sessão expirada

4. Avaliação dos Pontos de Integração:

Integração com APIs:
Frontend (API de produtos)
Frontend (API de pedidos)
Validação de códigos HTTP
Validação de mensagens de erro retornadas

Integração com Banco de Dados:
Persistência correta do pedido após finalização
Registro correto dos itens e valores
Consistência entre pedido e itens
Rollback em caso de erro durante a gravação

Integração com Sistemas Externos:
Envio de confirmação do pedido
Comportamento do sistema em caso de falha do serviço externo
Garantia de não duplicação de pedidos

5. Resultado Final do Trabalho do QA:

Ao final da identificação de test scenarios, QA entrega:
Lista estruturada de test scenarios
Mapeamento de fluxos críticos
Identificação clara de entradas válidas e inválidas
Pontos de integração mapeados
Base sólida para criação de casos de teste manuais e automatizados
</code></pre></small>

            <p id="textoPost">(Etapa 2b / 3) Test Plan é documento de planejamento dos testes, com descrição das atividades e necessidades para realização dos mesmos. Etapas para construção de Test Plan:</p>
            <ol>
                <li>Estude requisitos do software, elabore introdução do planejamento com escopo do que será realizado;</li>
                <li>Conforme requisitos, definida tipos de testes e estratégias que precisarão ser aplicadas, e estágios e/ou ciclos de testes;</li>
                <li>Identifique recursos tecnológicos necessários para aplicação dos testes, como ambiente, tecnologias, softwares e dispositivos que serão utilizados para realização dos testes;</li>
                <li>Identifique recursos humanos necessários para realização dos testes, quantos analistos, quantos testes, etc;</li>
                <li>Crie cronograma das atividades e execuções de testes, considerando que, além do planejado, poderão haver bugs que demandarão tempo para investigação e produção, reportação, e revisão das correções aplicadas;</li>
                <li>Identifique e especifique riscos que poderão afetar seu planejamento de testes, como por exemplo, mudança de requisitos, limitação das tecnologias ou recursos, etc;</li>
                <li>Identifique também restrições do seu planejamento, há algo que não será coberto pelos testes? Identifique no seu planejamento;</li>
                <li>Informe que artefatos serão gerados com base nos testes aplicados, por exemplo: próprio plano de teste, suite de testes manuais e/ou automatizados, relatórios, etc;</li>
                <li>Informe referências utilizadas para elaboração do plano de testes e casos de testes, por exemplo: documentos de requisitos, histórias de usuários entre outros.</li>
            </ol>
<small><pre><code>
Test Plan - Sistema de Gestão de Cafés (Web)

1. Introdução:
Este documento descreve Plano de Testes para sistema Sistema de Gestão de Cafés, aplicação web utilizada para cadastro, listagem, edição e exclusão de cafés, além de consulta pública dos dados. Objetivo deste Test Plan é definir escopo, estratégia, recursos, cronograma, riscos e artefatos relacionados às atividades de teste, garantindo que sistema atenda aos requisitos funcionais e não funcionais estabelecidos.

2. Escopo dos Testes:

2.1 Em Escopo - Serão testadas as seguintes funcionalidades:
Cadastro de cafés
Listagem de cafés
Consulta pública de cafés
Atualização de dados de cafés
Exclusão de cafés
Validações de campos obrigatórios
Regras de negócio descritas nos requisitos
Respostas da API REST
Compatibilidade básica com navegadores modernos

2.2 Fora do Escopo - Não serão cobertos neste ciclo:
Testes de carga e stress
Testes de segurança avançados (pentest)
Testes em dispositivos móveis físicos
Integrações com sistemas externos inexistentes no momento

3. Tipos de Testes e Estratégia:

3.1 Tipos de Testes - Serão aplicados tipos de testes:
Testes Funcionais
Testes de Regressão
Testes Exploratórios
Testes de API
Testes de Usabilidade básicos
Testes Manuais e Automatizados

3.2 Estratégia de Testes:
Testes manuais serão priorizados no início do projeto, durante validação de requisitos.
Testes automatizados serão aplicados para fluxos críticos (CRUD).
Testes de regressão serão executados a cada nova entrega.
Testes exploratórios serão realizados ao final de cada ciclo.

4. Estágios e Ciclos de Teste:
Ciclo 1: Testes funcionais iniciais (cadastro e listagem)
Ciclo 2: Testes de atualização, exclusão e validações
Ciclo 3: Testes de regressão
Ciclo 4: Testes exploratórios e validação final

5. Recursos Tecnológicos:

5.1 Ambiente:
Ambiente de desenvolvimento (DEV)
Banco de dados de testes
API REST disponível via endpoint de homologação

5.2 Tecnologias e Ferramentas:
Navegadores: Chrome, Firefox
Ferramenta de testes de API: Postman
Automação: Selenium / Cypress (exemplo)
Gerenciamento de testes: Planilha ou ferramenta de gestão (ex: Jira, TestRail)
Versionamento: Git

6. Recursos Humanos - Papel (quantidade):
QA Analyst (1)
Desenvolvedor (2)
Product Owner (1)

Responsabilidades do QA:
Criação do Test Plan
Elaboração de casos de teste
Execução dos testes
Registro e acompanhamento de defeitos
Reexecução de testes após correções

7. Cronograma de Testes -  Atividade (duração estimada em dias):
Análise de requisitos (1)
Criação do Test Plan (1)
Criação dos casos de teste (2)
Execução dos testes (3)
Reteste e regressão (2)
OBS: Cronograma considera tempo adicional para investigação de bugs, reporte, acompanhamento e validação das correções.

8. Riscos:
Mudanças frequentes nos requisitos
Atraso na entrega das funcionalidades
Ambiente de testes instável
Falta de dados consistentes para testes
Dependência de correções do time de desenvolvimento

9. Restrições:
Prazo limitado para execução dos testes
Apenas 1 QA disponível
Não haverá testes automatizados completos neste ciclo
Testes realizados apenas em ambiente web

10. Artefatos Gerados:
Plano de Testes (Test Plan)
Casos de Teste Manuais
Scripts de Testes Automatizados (parciais)
Relatórios de Execução de Testes
Relatórios de Defeitos (Bugs)

11. Referências:
Documento de Requisitos do Sistema
Histórias de Usuário
Critérios de Aceite
Documentação da API
Padrões internos de QA
</code></pre></small>

            <p id="textoPost">(Etapa 4) Test Case são conjuntos de ações utilizadas para testar cenários com baseado em requisito. Cenários de Testes definem "O que" deve ser testado, enquanto os Casos de Testes definem "Como". Compõe das seguintes etapas:</p>
            <ol>
                <li>Nome / Test Scenario: descrição objetiva do propósito do teste, via id's nos nomes dos casos para melhor organização dos casos de testes;</li>
                <li>Pré-condição: descreve o que é necessário para realização dos passos do caso de teste, por exemplo: para realizar login é necessário que usuário esteja cadastrado;</li>
                <li>Passos: descreve sequência de passos necessários para aplicação do teste;</li>
                <li>Resultado esperado: descreve resultado esperado que deve ocorrer após execução dos passos e com pré-condição estabelecidas;</li>
                <li>Resultado: descreve resultado final do teste, por exemplo: Pass - quando resultado esperado é mesmo que ocorrido, Fail - quando ocorrido não está de acordo com esperado, N/A (Não aplicável) quando teste não é aplicável ao dispositivo por motivo específico, N/T (Não testado) quando caso de teste não é testado;</li>
                <li>Nível de prioridade: indica a importância do caso de teste, ajudando a focar nos testes mais críticos primeiro.</li>
            </ol>
<small><pre><code>
Contexto do Projeto: Sistema web de pedidos para cafeteria, onde cliente pode montar e finalizar pedidos online.

Caso de Teste 1: Nome / Test Scenario
TC-TS01-001 - Finalizar pedido com um item válido
Este cenário valida se usuário consegue concluir pedido corretamente quando todas condições estão válidas.

Pré-condição:
Sistema disponível
Usuário com acesso à aplicação
Produto cadastrado e disponível no cardápio
API de pedidos em funcionamento

Passos:
Acessar sistema web de pedidos
Visualizar cardápio
Selecionar produto disponível
Adicionar produto ao pedido
Clicar no botão "Finalizar pedido"

Resultado Esperado:
Sistema deve calcular corretamente valor do pedido
Pedido deve ser salvo com sucesso no banco de dados
Sistema deve exibir mensagem de confirmação do pedido

Resultado: N/T (Não testado)

Nível de Prioridade: Alta

Caso de Teste 2: Nome / Test Scenario
TC-TS01-002 - Finalizar pedido com múltiplos itens

Pré-condição:
Sistema disponível
Usuário com acesso à aplicação
Dois ou mais produtos disponíveis no cardápio
API de pedidos ativa

Passos:
Acessar sistema
Adicionar 2 produtos diferentes ao pedido
Alterar quantidade de 1 dos produtos
Conferir valor total do pedido
Finalizar pedido

Resultado Esperado:
Valor total deve refletir corretamente itens e quantidades
Pedido deve ser persistido corretamente
Confirmação do pedido deve ser exibida

Resultado: N/T (Não testado)

Nível de Prioridade: Alta

Caso de Teste 3 (Entrada Inválida): Nome / Test Scenario
TC-TS01-003 - Tentar finalizar pedido sem itens

Pré-condição:
Sistema disponível
Usuário com acesso à aplicação
Carrinho vazio

Passos:
Acessar sistema
Não adicionar nenhum produto
Clicar em "Finalizar pedido"

Resultado Esperado:
Sistema deve impedir finalização do pedido
Mensagem de erro informando que pedido não pode estar vazio

Resultado: N/T (Não testado)

Nível de Prioridade: Alta
</code></pre></small>

            <p id="textoPost">(Etapa 5) Test Data mal gerenciados podem levar a cobertura de teste incompleta ou a falsos positivos. Um projeto eficaz de Test Data inclui:</p>
            <ol>
                <li>Dados válidos para testes positivos;</li>
                <li>Dados inválidos para testes negativos;</li>
                <li>Dados de limite para limites superior e inferior;</li>
                <li>Variações de dados para testes de desempenho e segurança.</li>
            </ol>
<small><pre><code>
Contexto do Projeto: Sistema web de pedidos para cafeteria, onde clientes realizam pedidos informando:
Produto
Quantidade
Dados do cliente (nome e telefone)

Objetivo do QA: Garantir que diferentes tipos de dados cubram cenários positivos, negativos, limites e variações críticas.

1. Dados Válidos - Testes Positivos:
Esses dados validam comportamento esperado do sistema em condições normais de uso.

Exemplo de Test Data Válido:
Produto: Café Expresso
Quantidade: 1
Nome do cliente: João Silva
Telefone: 11987654321

Objetivo do Teste:
Pedido deve ser criado com sucesso
Valor calculado corretamente
Confirmação exibida ao usuário

Uso real: Executar fluxos principais (happy path) e regressão.

2. Dados Inválidos - Testes Negativos:
Esses dados validam se sistema bloqueia entradas incorretas e exibe mensagens adequadas.

Exemplos de Test Data Inválido:
Produto inexistente
Quantidade: 0
Quantidade: -3
Nome do cliente vazio
Telefone com caracteres alfanuméricos

Objetivo do Teste:
Sistema deve impedir a criação do pedido
Mensagens de erro devem ser claras e corretas
Nenhum dado inválido deve ser persistido no banco

Uso real: Evitar falsos positivos e bugs críticos em produção.

3. Dados de Limite - Boundary Value Analysis:
Esses dados validam comportamento do sistema nos limites inferior e superior.

Regras de Negócio (Exemplo):
Quantidade mínima permitida: 1
Quantidade máxima permitida: 10 itens por produto

Test Data de Limite:
Quantidade = 1 (limite inferior válido)
Quantidade = 10 (limite superior válido)
Quantidade = 0 (abaixo do limite)
Quantidade = 11 (acima do limite)

Objetivo do Teste:
Garantir que limites sejam respeitados
Evitar erros de cálculo ou quebra do sistema

Uso real: Esses dados normalmente pegam bugs que passam em testes básicos.

4. Variações de Dados - Desempenho e Segurança:

Variações para Desempenho:
Pedido com 1 item
Pedido com 10 itens
Pedido com múltiplos produtos e quantidades máximas
Execução simultânea de múltiplos pedidos

Objetivo:
Verificar tempo de resposta
Garantir estabilidade sob carga moderada

Variações para Segurança:
Nome do cliente com script HTML
Nome com SQL Injection básico
Campos com strings extremamente longas
Envio de payload malformado via API

Objetivo:
Garantir sanitização de dados
Evitar falhas de segurança comuns
Prevenir persistência de dados maliciosos

Uso real: Mesmo quando não há time de segurança, o QA cobre o básico.
</code></pre></small>

            <p id="textoPost">(Etapa 6) Test Environment controlado é essencial para testes confiáveis. Isso envolve:</p>
            <ol>
                <li>Configurar ambientes separados para desenvolvimento, teste, homologação e produção;</li>
                <li>Definir dependências de hardware, software e terceiros;</li>
                <li>Implantar versão mais recente do software e configurar frameworks de automação.</li>
            </ol>
<small><pre><code>
Contexto do Projeto: Sistema web de pedidos para cafeteria, composto por:
Frontend web
Backend com API REST
Banco de dados relacional
Serviço externo de notificação

Objetivo do QA: Garantir que testes sejam executados em um ambiente estável, previsível e rastreável, evitando falsos resultados.

1. Configuração de Ambientes Separados:

Ambientes Definidos no Projeto:

Desenvolvimento (DEV)
Utilizado pelos desenvolvedores para implementação e testes locais.

Teste (QA)
Ambiente exclusivo para execução de testes funcionais, regressão e automação.

Homologação (HML)
Ambiente próximo de produção, usado para validação final e aceite do negócio.

Produção (PROD)
Ambiente real, utilizado pelos clientes finais.

Prática real de QA: validar se ambiente de teste está isolado e não depende de dados ou serviços de produção.

2. Definição de Dependências de Hardware, Software e Terceiros:

Dependências de Hardware:
Servidor com capacidade mínima definida
Estações de teste com acesso à internet
Dispositivos para testes básicos de compatibilidade (desktop)

Dependências de Software:
Sistema operacional Linux no servidor
Navegadores Chrome e Firefox em versões estáveis
Banco de dados PostgreSQL
Backend rodando com Java ou Python
Frontend acessível via navegador

Dependências de Terceiros:
Serviço externo de envio de notificações
Gateway de mensagens (mockado em QA)
Serviço de autenticação (quando aplicável)

Ação real do QA: Solicitar mock ou stub de serviços externos para evitar instabilidade nos testes.

3. Implantação da Versão Correta do Software:

Controle de Versão:
Identificação da versão testada: v1.3.0
Commit ou tag associada à versão
Registro da versão nos relatórios de teste

Atividade do QA:
Confirmar que build implantado é mais recente
Validar se ambiente foi atualizado corretamente
Evitar testar versões desatualizadas ou parciais

4. Configuração de Frameworks de Automação:

Ferramentas Utilizadas:
Framework de automação web (ex: Selenium ou Cypress)
Framework de testes de API
Gerenciador de dependências
Pipeline de CI para execução automática

Configuração no Ambiente de Teste:
URLs apontando para ambiente QA
Dados de teste específicos
Execução de testes automatizados a cada novo deploy
Geração de relatórios automáticos

Visão prática: QA valida que testes automatizados não apontam para DEV ou PROD por engano.

5. Boas Práticas Aplicadas pelo QA:
Ambientes claramente documentados
Controle de acesso por perfil
Base de dados exclusiva para testes
Reset ou seed de dados antes da execução
Registro de instabilidades do ambiente
Comunicação constante com DevOps
</code></pre></small>

            <p id="textoPost">(Etapa 7) Test Execution iniciados após configuração dos ambientes e frameworks. Compõe as seguintes atividades:</p>
            <ol>
                <li>Casos de teste são revisados quanto à precisão e integridade;</li>
                <li>Testes duplicados são removidos para melhorar a eficiência;</li>
                <li>Scripts de teste automatizados são executados e os resultados são analisados.</li>
            </ol>
<small><pre><code>
Contexto do Projeto: Sistema web de pedidos para cafeteria, com:
Ambiente de teste (QA) configurado
Framework de automação funcional e de API disponível
Casos de teste documentados e versionados

Objetivo do QA nesta fase: Executar testes de forma eficiente, confiável e rastreável, analisando resultados e identificando falhas reais.

1. Revisão dos Casos de Teste:
Antes de iniciar execução, QA realiza revisão rápida dos casos de teste.

Atividades realizadas:
Verificar se casos de teste estão alinhados aos requisitos atualizados
Validar se pré-condições estão claras e possíveis de serem atendidas
Conferir se passos estão objetivos e sem ambiguidades
Garantir que resultado esperado esteja mensurável

Exemplo real:
Caso de teste menciona botão "Finalizar"
QA valida se nome do botão ainda existe na interface
Caso contrário, teste é ajustado antes da execução

2. Remoção de Casos de Teste Duplicados:
Durante revisão, QA identifica redundâncias.

2 casos testam:
Finalização de pedido com 1 item válido
Finalização de pedido com item único válido

Ação do QA:
Manter apenas 1 caso bem descrito
Ajustar cobertura para evitar sobreposição
Atualizar matriz de rastreabilidade

3. Preparação para Execução dos Testes:

Checklist antes de executar:
Ambiente QA disponível e estável
Versão correta do sistema implantada
Base de dados preparada com massa de teste
Ferramentas de teste acessíveis
Scripts automatizados apontando para o ambiente correto

4. Execução de Casos de Teste Manuais:

Execução prática:
QA executa casos de teste por prioridade
Fluxos críticos executados primeiro
Resultados registrados caso a caso

Exemplo de registro:
Resultado: Pass
Evidência: print da tela de confirmação do pedido
Observações: execução dentro do tempo esperado

5. Execução de Scripts de Teste Automatizados:

Execução:
Scripts de regressão são disparados
Testes de API e UI executados
Logs e relatórios gerados automaticamente

Análise dos Resultados:
Testes aprovados confirmados
Falhas analisadas individualmente
Identificação de falhas reais vs problemas de ambiente

Exemplo real:
Teste falhou por timeout
QA verifica instabilidade do ambiente
Caso não seja bug, teste é marcado como bloqueado

6. Análise e Consolidação dos Resultados:

Atividades finais do QA:
Consolidar quantidade de testes executados
Avaliar taxa de aprovação e falhas
Registrar defeitos encontrados
Comunicar status ao time

Exemplo de status:
Total de testes: 45
Pass: 38
Fail: 5
Blocked: 2
</code></pre></small>

            <p id="textoPost">Pairwise Testing (all-pairs testing) é método de teste de software que examina todas combinações possíveis de pares de parâmetros de entrada. Essa abordagem é particularmente útil quando o teste exaustivo é impraticável devido ao grande número de casos de teste potenciais. Compõe das seguintes etapas:</p>
            <ol>
                <li>Identificar parâmetros de entrada: listar e priorizar parâmetros de entrada com base nos requisitos do sistema ou nas especificações funcionais;</li>
                <li>Definir valores dos parâmetros: determinar todos valores possíveis para cada parâmetro de entrada, de forma a abranger diversos cenários;</li>
                <li>Gerar combinações aos pares: criar manualmente combinações que cubram sistematicamente todos pares de parâmetros de entrada;</li>
                <li>Criar casos de teste detalhados: desenvolver casos de teste abrangentes com base nos pares gerados, garantindo clareza e completude;</li>
                <li>Executar casos de teste: executar casos de teste manualmente e documentar meticulosamente resultados e observações;</li>
                <li>Analisar resultados: analisar resultados dos testes para identificar defeitos, inconsistências ou áreas que necessitam de melhorias.</li>
            </ol>
            <p id="textoPost">Matrizes ortogonais são conceito matemático usado em testes de pares para projetar experimentos ou casos de teste de forma sistemática e eficiente. Ferramentas para Paiwise Testing são PICT (Pairwise Independent Combinatorial Testing), Hexawise, Testersdesk, ACTS (Automated Combinatorial Testing for Software) e AllPairs.</p>
<small><pre><code>
Teste de combinações de funcionalidades
Cenário: Site simples de e-commerce
Objetivo: validar combinações de funcionalidades utilizando pairwise testing (teste em pares)

Funcionalidades consideradas:
Métodos de Pagamento: Cartão de Crédito, PayPal, Transferência Bancária
Métodos de Envio: Padrão, Expresso, Noturno
Tipos de Cliente: Novo, Recorrente, Visitante

Abordagem:
Utilização do pairwise testing para garantir que todas as combinações possíveis em pares entre as funcionalidades sejam testadas
Redução da quantidade total de casos de teste, mantendo uma boa cobertura de testes

Exemplos de casos de teste gerados:

Caso de Teste 1
Método de Pagamento: Cartão de Crédito
Método de Envio: Padrão
Tipo de Cliente: Novo

Caso de Teste 2
Método de Pagamento: Cartão de Crédito
Método de Envio: Expresso
Tipo de Cliente: Recorrente

Caso de Teste 3
Método de Pagamento: Cartão de Crédito
Método de Envio: Noturno
Tipo de Cliente: Visitante

Caso de Teste 4
Método de Pagamento: PayPal
Método de Envio: Padrão
Tipo de Cliente: Recorrente

Caso de Teste 5
Método de Pagamento: PayPal
Método de Envio: Expresso
Tipo de Cliente: Visitante

Caso de Teste 6
Método de Pagamento: PayPal
Método de Envio: Noturno
Tipo de Cliente: Novo

Caso de Teste 7
Método de Pagamento: Transferência Bancária
Método de Envio: Padrão
Tipo de Cliente: Visitante

Caso de Teste 8
Método de Pagamento: Transferência Bancária
Método de Envio: Expresso
Tipo de Cliente: Novo

Caso de Teste 9
Método de Pagamento: Transferência Bancária
Método de Envio: Noturno
Tipo de Cliente: Recorrente
</code></pre></small>

            <p id="textoPost">Model-Based Testing (MBT) é abordagem de teste via uso de modelos. Ao contrário do teste tradicional, que envolve análise minuciosa de cada detalhe intrincado, teste baseado em modelos adota abordagem geral. Permite que você se concentre nas funcionalidades principais sem se perder em detalhes insignificantes. Diagramas utilizados, conforme nível de abstração:</p>
            <ul>
                <li>Alto nível de abstração: diagramas de casos de uso ou modelos comportamentais fornecem visão geral do comportamento do sistema;</li>
                <li>Nível intermediário: diagramas de estados (estados e transições) e diagramas de sequência (interações entre componentes);</li>
                <li>Baixo nível de abstração: modelos altamente detalhados, estados e interações divididos em passos menores, e modelos complexos e multinível, onde componentes podem ser compostos por subcomponentes menores.</li>
            </ul>
            <p id="textoPo">Modelo do SUT (System Under Test) é diagrama de atividades simplificado, que define quais ações podem ser realizadas, em qual ordem, e quais passos devem preceder ou podem seguir outros.</p>
<small><pre><code>
Aplicação sob teste (AUT) simula tela de máquina de café, permitindo:
Escolher bebida
Ajustar açúcar e leite
Finalizar preparo

Casos de teste iniciais:
1º caso de teste: Preparo de espresso, sem adicionais
2º caso de teste: Preparo de latte, e Ajuste de leite e açúcar
Cada caso de teste corresponde a 1 caminho no diagrama de atividades

Durante execução:
Squish assume controle da AUT
Reproduz passos na ordem definida pelo modelo
Cada passo possui 1 implementação, escrita em linguagem de programação

@mbt.step("Click on Macchiato")
def step():
    mouseClick(waitForObject(names.macchiato_button))
    test.vp("VP_macchiato")

# -------- Ajustando leite e açúcar --------
@mbt.step("Set milk")
def step():
    mousePress(waitForObject(names.milk_slider_handle))
    slider = waitForObject(names.coffee_sugarSlider_Slider)
    x = builtins.int(slider.width * random.random())
    y = builtins.int(slider.height * 0.5)
    mouseMove(slider, x, y)
    mouseRelease()
    snooze(0.5)

Adicionando novo passo ao modelo MBT:
Identificado que faltava no modelo funcionalidade de voltar para tela anterior e escolher outra bebida

Etapas realizadas no Squish IDE:
Add Step Mode
Criação do novo passo: "Go back"
Connect Steps Mode
Conexão do novo passo aos demais no diagrama
Generate missing steps implementations
Geração automática do esqueleto do passo
Implementação real do passo

Substituição do código vazio por ação concreta:
@mbt.step("Go back")
def step():
    mouseClick(waitForObject(names.back_button))
</code></pre></small>

            <p id="textoPost">Black-box testing (teste de caixa-preta) é técnica de teste de software onde tester avalia funcionalidade do sistema sem conhecer estrutura interna do código. Objetivo é verificar se software atende aos requisitos especificados, testando entradas e saídas sem considerar implementação interna. Técnicas black-box:</p>
            <ul>
                <li>Particionamento por equivalência: Testers dividem entradas em partições equivalentes;
<small><pre><code>
Um sistema de cadastro de usuários possui campo idade, com seguinte regra de negócio:
Idade aceita deve estar entre 18 e 65 anos
Valores fora desse intervalo não são permitidos
Campo é obrigatório
Sistema exibe mensagem de erro para valores inválidos
Tester não conhece código interno, apenas requisitos funcionais.

Partições de equivalência identificadas:
Tester divide entradas possíveis em grupos (partições) que devem ter mesmo comportamento do sistema

Partições válidas:
Idade entre 18 e 65 (Exemplo: 25, 40, 60)

Partições inválidas:
Idade menor que 18 (Exemplo: 10, 15, 17)
Idade maior que 65 (Exemplo: 66, 80, 100)
Campo vazio ou nulo (Exemplo: não informar idade)
Valor não numérico (Exemplo: "abc", "@#", "vinte")

Casos de teste derivados (black-box):
Caso de Teste - Entrada (Idade) - Partição - Resultado Esperado
CT01 - 25 - Válida - Cadastro realizado com sucesso
CT02 - 17 - Inválida (&lt;18) - Mensagem de erro exibida
CT03 - 70 - Inválida (&gt;65) - Mensagem de erro exibida
CT04 - (vazio) - Inválida (obrigatório) - Mensagem de campo obrigatório
CT05 - "abc" - Inválida (não numérico) - Mensagem de erro exibida
</code></pre></small>
                </li>
                <li>Teste de tabela de decisão: Usa formato tabular para representar lógica de decisão complexa e casos de teste, garantindo que todas condições possíveis sejam testadas;
<small><pre><code>
Um sistema de e-commerce aplica desconto no pedido de acordo com três condições:
Cliente é VIP?
Valor da compra é maior ou igual a R$ 200?
Cupom de desconto é válido?

Regras de negócio:
Desconto só é aplicado se:
Cliente for VIP OU Valor da compra maior ou igual a R$ 200 E cupom precisa ser válido
Caso contrário, nenhum desconto é aplicado

Condições:
Condição - Descrição
C1 - Cliente é VIP
C2 - Valor da compra maior ou igual a R$ 200
C3 - Cupom válido

Ações:
Ação - Descrição
A1 - Aplicar desconto
A2 - Não aplicar desconto

Tabela de decisão:
Regra - Cliente VIP (C1) - Compra maior ou igual a R$ 200 (C2) - Cupom válido (C3) - Ação
R1 - Sim - Sim - Sim - Aplicar desconto
R2 - Sim - Não - Sim - Aplicar desconto
R3 - Não - Sim - Sim - Aplicar desconto
R4 - Não - Não - Sim - Não aplicar desconto
R5 - Sim - Sim - Não - Não aplicar desconto
R6 - Sim - Não - Não - Não aplicar desconto
R7 - Não - Sim - Não - Não aplicar desconto
R8 - Não - Não - Não - Não aplicar desconto

Casos de teste derivados:
Caso de Teste - VIP - Valor da Compra - Cupom - Resultado Esperado
CT01 - Sim - R$ 250 - Válido - Desconto aplicado
CT02 - Sim - R$ 150 - Válido - Desconto aplicado
CT03 - Não - R$ 300 - Válido - Desconto aplicado
CT04 - Não - R$ 100 - Válido - Sem desconto
CT05 - Sim - R$ 220 - Inválido - Sem desconto
CT06 - Não - R$ 210 - Inválido - Sem desconto
CT07 - Sim - R$ 80 - Inválido - Sem desconto
CT08 - Não - R$ 50 - Inválido - Sem desconto
</code></pre></small>
                </li>
                <li>Análise de valores limite: Testa valores nos limites dos intervalos de entrada e saída. Muitos erros ocorrem nas extremidades desses intervalos;
<small><pre><code>
Sistema de transferência bancária possui seguinte regra:
Valor mínimo para transferência: R$ 10,00
Valor máximo para transferência: R$ 5.000,00
Valor deve estar dentro desse intervalo, inclusive
Valores fora do intervalo devem ser rejeitados
Tester avalia apenas entradas e saídas, sem conhecer implementação interna (teste de caixa-preta)

Limites identificados:
Limite inferior: Valor mínimo permitido: R$ 10,00
Limite superior: Valor máximo permitido: R$ 5.000,00

Valores de teste escolhidos: Para cada limite, o QA testa:
Valor abaixo do limite
Valor exato do limite
Valor acima do limite

Casos de teste (valores limite):
Caso de Teste - Valor da Transferência - Tipo de Valor - Resultado Esperado
CT01 - R$ 9,99 - Abaixo do limite inferior - Transferência recusada
CT02 - R$ 10,00 - Limite inferior - Transferência realizada
CT03 - R$ 10,01 - Acima do limite inferior - Transferência realizada
CT04 - R$ 4.999,99 - Abaixo do limite superior - Transferência realizada
CT05 - R$ 5.000,00 - Limite superior - Transferência realizada
CT06 - R$ 5.000,01 - Acima do limite superior - Transferência recusada
</code></pre></small>
                </li>
                <li>Teste de caso de uso: Testa sistema com base na interação do usuário e em cenários;
<small><pre><code>
Aplicativo de delivery de comida permite que usuário:
Faça login
Busque restaurantes
Selecione produtos
Finalize pedido
QA testa sistema a partir da interação real do usuário, seguindo fluxo do negócio

Caso de uso: Realizar pedido de comida
Ator: Cliente
Objetivo: Permitir que cliente realize pedido com sucesso

Pré-condições:
Usuário cadastrado no sistema
Usuário autenticado (login realizado)
App com conexão à internet

Fluxo principal (cenário feliz):
Usuário acessa aplicativo
Usuário realiza login com credenciais válidas
Usuário pesquisa restaurante
Usuário seleciona restaurante disponível
Usuário adiciona produtos ao carrinho
Usuário acessa carrinho
Usuário escolhe forma de pagamento
Usuário confirma pedido
Sistema processa pagamento
Sistema exibe confirmação do pedido

Resultado esperado:
Pedido realizado com sucesso
Número do pedido exibido ao usuário

Fluxos alternativos (cenários):
Cenário alternativo 1 - Pagamento recusado
No passo 9, pagamento falha
Sistema exibe mensagem de erro
Pedido não é confirmado

Cenário alternativo 2 - Restaurante indisponível
No passo 4, restaurante fica indisponível
Sistema informa indisponibilidade
Usuário retorna à lista de restaurantes

Cenário alternativo 3 - Carrinho vazio
Usuário tenta confirmar pedido sem itens
Sistema bloqueia ação
Mensagem de aviso exibida

Casos de teste derivados do caso de uso:
Caso de Teste - Cenário - Resultado Esperado
CT01 - Fluxo principal completo - Pedido realizado com sucesso
CT02 - Pagamento recusado - Pedido não confirmado
CT03 - Restaurante indisponível - Pedido não iniciado
CT04 - Carrinho vazio - Mensagem de erro exibida
</code></pre></small>
                </li>
                <li>Teste de transição de estados: Testa diferentes estados como máquina de estados finitos e projeta casos de teste com base nas transições.
<small><pre><code>
Sistema de pedidos online possui pedido que muda de estado conforme ações do usuário e do sistema.

Estados possíveis do pedido:
Novo
Pago
Em preparo
Enviado
Entregue
Cancelado

Transições permitidas:
Estado Atual - Ação - Próximo Estado
Novo - Confirmar pagamento - Pago
Pago - Iniciar preparo - Em preparo
Em preparo - Enviar pedido - Enviado
Enviado - Confirmar entrega - Entregue
Novo - Cancelar pedido - Cancelado
Pago - Cancelar pedido - Cancelado

Transições não permitidas (exemplos):
Enviado - Pago
Entregue - Em preparo
Cancelado - Qualquer outro estado

Casos de teste baseados em transições:

Caso de Teste 1 - Fluxo válido completo
Criar pedido (estado: Novo):
Confirmar pagamento - Pago
Iniciar preparo - Em preparo
Enviar pedido - Enviado
Confirmar entrega - Entregue
Resultado esperado: Pedido entregue com sucesso

Caso de Teste 2 - Cancelamento antes do pagamento
Criar pedido (estado: Novo):
Cancelar pedido - Cancelado
Resultado esperado: Pedido cancelado corretamente

Caso de Teste 3 - Cancelamento após pagamento
Criar pedido (estado: Novo):
Confirmar pagamento - Pago
Cancelar pedido - Cancelado
Resultado esperado: Pedido cancelado e reembolso iniciado

Caso de Teste 4 - Transição inválida
Criar pedido (estado: Novo)
Tentar confirmar entrega

Resultado esperado:
Sistema bloqueia a ação
Mensagem de erro exibida

Tabela de transições (resumo):
Estado Inicial - Ação - Estado Final - Válido?
Novo - Confirmar pagamento - Pago - Sim
Pago - Enviar pedido - Enviado - Não
Cancelado - Iniciar preparo - Em preparo - Não
Enviado - Confirmar entrega - Entregue - Sim
</code></pre></small>
                </li>
            </ul>

            <p id="textoPost">Experience-based testing é teste baseado em experiência e intuição do testador, com base em experiência prática, conhecimento do domínio, intuição, histórico de bugs e comportamento típico de sistemas e usuários. Consiste nas técnicas:</p>
            <ul>
                <li>Error Guessing (Adivinhação de Erros): tester cria testes com base em bugs comuns já vistos, padrões de falhas, pontos historicamente problemáticos e áreas complexas do sistema;                 </li>
                <li>Exploratory Testing (Teste Exploratório): tester não segue script fixo, onde aprende o sistema enquanto testa, cria testes durante a execução e adapta caminho conforme encontra comportamentos (Ciclo comum: Explorar → Testar → Aprender → Ajustar → Testar de novo).</li>
            </ul>
<small><pre><code>
Nova funcionalidade: bloqueio e desbloqueio de cartão no app.
Estados do cartão: Ativo, Bloqueado temporariamente, Bloqueado por fraude, Cancelado

Transições oficiais documentadas:
Ativo → Bloqueado temporariamente
Bloqueado temporariamente → Ativo
Bloqueado por fraude → Cancelado

Aplicando Error Guessing:
Problemas suspeitos que não estão nas especificações formais:
- Cliques repetidos
- Troca rápida de estados
- Perda de rede
- Concorrência entre app e backend
- Sessão expirada

Casos criados:

Teste 1- Clique duplo rápido
Tocar "Bloquear cartão" várias vezes
Esperado: apenas uma transição de estado

Teste 2- Internet cai durante bloqueio
Bloquear cartão
Desligar Wi-Fi no meio
Verificar estado final

Teste 3- Dois dispositivos
App aberto no celular A e B
Bloquear em A
Ver se B atualiza estado

Teste 4- Sessão expirada
Deixar app parado
Tentar desbloquear
Ver se pede login novamente

Após sessão exploratória de 45 minutos
Roteiro leve: "Explorar todas transições de estado do cartão"

Durante exploração QA testa:
bloquear → voltar tela → tentar pagar
bloquear → gerar cartão virtual
bloquear → tentar alterar limite
bloquear → trocar idioma
bloquear → atualizar app
bloquear → logout/login

Bug encontrado:
Após bloquear cartão, sair da conta e entrar novamente
Tela mostra cartão ativo, mas backend está bloqueado.
Bug crítico de sincronização de estado.
</code></pre></small>

            <p id="textoPost">White-Box testing é teste de caixa branca, onde o testador tem conhecimento do código-fonte e da estrutura interna do sistema. QA analisa lógica interna do código, decisões (if, else), laços, caminhos de execução e condições booleanas. Consiste nas técnicas:</p>
            <ul>
                <li>Statement Coverage (Cobertura de Instruções): garantir que cada linha/instrução executável do código rode pelo menos 1 vez;</li>
                <li>Branch Coverage (Cobertura de Decisões/Ramos): garantir que cada decisão (if, else) seja avaliada como verdadeira e falsa pelo menos 1 vez;</li>
                <li>Condition Coverage (Cobertura de Condições): garantir que cada condição booleana dentro de decisões seja avaliada como verdadeira e falsa pelo menos 1 vez;</li>
                <li>Path Coverage (Cobertura de Caminhos): garantir que todos os caminhos possíveis através do código sejam executados pelo menos 1 vez;</li>
            </ul>
<small><pre><code>
QA técnico em backend testa função responsável por liberar desconto em pedido:
def calcular_desconto(valor, cliente_vip, cupom_valido):
    if valor &gt;= 200 and cliente_vip:
        return 20
    elif valor &gt;= 200 or cupom_valido:
        return 10
    else:
        return 0

Statement Coverage:
Teste - Entrada - Linha atingida
T1 - valor=250, vip=True, cupom=False - return 20
T2 - valor=250, vip=False, cupom=False - return 10
T3 - valor=50, vip=False, cupom=False - return 0

Branch Coverage:
Primeiro IF: valor &gt;= 200 and cliente_vip
TRUE → T1
FALSE → T2/T3

Segundo IF: valor &gt;= 200 or cupom_valido
TRUE → T2
FALSE → T3

Condition Coverage:
Agora cada condição isolada deve ser TRUE e FALSE.
valor &gt;= 200
cliente_vip
cupom_valido

Teste - valor&gt;=200 - vip - cupom
T1 - TRUE - TRUE - FALSE
T2 - TRUE - FALSE - FALSE
T3 - FALSE - FALSE - TRUE
T4 - FALSE - FALSE - FALSE

Path Coverage:
IF verdadeiro → return 20
IF falso → ELIF verdadeiro → return 10
IF falso → ELIF falso → return 0
T1 → caminho 1
T2 → caminho 2
T3 → caminho 3
</code></pre></small>

            <p id="textoPost">Orthogonal array testing é técnica de teste de software que utiliza matrizes ortogonais para projetar casos de teste de forma sistemática e eficiente. Essa abordagem é especialmente útil quando há múltiplos parâmetros de entrada com várias combinações possíveis, tornando o teste exaustivo impraticável. A técnica envolve:</p>
            <ol>
                <li>Identificar parâmetros de entrada: listar e priorizar parâmetros de entrada com base nos requisitos do sistema ou nas especificações funcionais;</li>
                <li>Definir valores dos parâmetros: determinar todos valores possíveis para cada parâmetro de entrada, de forma a abranger diversos cenários;</li>
                <li>Gerar casos de teste usando matrizes ortogonais: utilizar matrizes ortogonais para criar um conjunto de casos de teste que cubram sistematicamente todas as combinações possíveis de parâmetros de entrada, garantindo uma cobertura eficiente;</li>
                <li>Executar casos de teste: executar casos de teste manualmente ou usando ferramentas de automação, documentando meticulosamente os resultados e observações;</li>
                <li>Analisar resultados: analisar os resultados dos testes para identificar defeitos, inconsistências ou áreas que necessitam de melhorias.</li>
            </ol>
<small><pre><code>
Contexto do Projeto: Sistema de reserva de voos, onde usuários selecionam:
Destino (A, B, C)
Classe (Econômica, Executiva, Primeira Classe)
Tipo de passagem (Ida, Ida e Volta)
Opção de bagagem (Sim, Não)

Objetivo do QA: Garantir que todas combinações possíveis de parâmetros de entrada sejam testadas de forma eficiente, utilizando matrizes ortogonais para otimizar o número de casos de teste.

1. Identificação dos Parâmetros de Entrada:
Parâmetros identificados:
Destino: A, B, C
Classe: Econômica, Executiva, Primeira Classe
Tipo de passagem: Ida, Ida e Volta
Opção de bagagem: Sim, Não

2. Definição dos Valores dos Parâmetros:
Valores definidos para cada parâmetro:
Destino: A, B, C
Classe: Econômica, Executiva, Primeira Classe
Tipo de passagem: Ida, Ida e Volta
Opção de bagagem: Sim, Não

3. Geração de Casos de Teste usando Matrizes Ortogonais:
Utilização de matriz ortogonal para gerar casos de teste que cubram todas as combinações possíveis
Caso de Teste - Destino - Classe - Tipo de Passagem - Bagagem
CT01 - A - Econômica - Ida - Sim
CT02 - A - Executiva - Ida e Volta - Não
CT03 - B - Primeira Classe - Ida - Sim
CT04 - C - Econômica - Ida e Volta - Não
CT05 - B - Executiva - Ida - Não
CT06 - C - Primeira Classe - Ida e Volta - Sim
CT07 - A - Primeira Classe - Ida e Volta - Sim
CT08 - B - Econômica - Ida e Volta - Não
CT09 - C - Executiva - Ida - Sim

4. Execução dos Casos de Teste:
Execução manual ou automatizada dos casos de teste gerados
Registro dos resultados e observações para cada caso de teste

5. Análise dos Resultados:
Análise dos resultados para identificar defeitos, inconsistências ou áreas que necessitam de melhorias
Relatório de teste consolidado com insights e recomendações para o time de desenvolvimento
</code></pre></small>

            <p id="textoPost">State Transition testing (teste de transição de estados) é usado quando sistema possui status bem definidos e regras de mudança entre eles, onde QA quais estados existem, quais transições são permitidas, quais transições são proibidas, quais ações provocam mudança de estado, e quais mensagens aparecem quando a transição é inválida.</p>
<small><pre><code>
Sistema: Plataforma de Pedidos Online
Módulo: Gestão de Pedido
Fonte: SRS + Refinamento com PO

Estados definidos no requisito

Pedido pode ter status:
Novo
Aguardando Pagamento
Pago
Em Preparo
Pronto
Enviado
Entregue
Cancelado

Transições permitidas (regra de negócio):
Estado Atual - Ação - Próximo Estado
Novo - gerar cobrança - Aguardando Pagamento
Aguardando Pagamento - pagamento aprovado - Pago
Pago - iniciar preparo - Em Preparo
Em Preparo - finalizar preparo - Pronto
Pronto - despachar - Enviado
Enviado - confirmar entrega - Entregue
Novo - cancelar - Cancelado
Aguardando Pagamento - cancelar - Cancelado

Transições proibidas (definidas pelo PO):
Pedido Pago → Novo
Pedido Entregue → Em Preparo
Pedido Cancelado → qualquer estado
Pedido Novo → Enviado direto
- QA anota isso na matriz de estados.

Test Scenarios (QA cria primeiro):
TS-STATE-01 — Fluxo completo válido
TS-STATE-02 — Cancelamento antes pagamento
TS-STATE-03 — Cancelamento após pagamento (proibido)
TS-STATE-04 — Entrega sem envio (proibido)
TS-STATE-05 — Mudança dupla de estado via API
TS-STATE-06 — Repetição de ação já executada

TC-STATE-01 — Fluxo completo válido
Pré-condição: Pedido criado

Passos:
Criar pedido
Gerar cobrança
Aprovar pagamento
Iniciar preparo
Finalizar preparo
Despachar
Confirmar entrega

Resultado esperado:
Sistema permite todas transições
Status final = Entregue
Histórico de status registrado

TC-STATE-02 — Transição inválida direta
Objetivo: tentar pular estado

Passos:
Criar pedido (Novo)
Tentar marcar como Enviado via API

Resultado esperado:
Sistema bloqueia
Retorna erro 409 ou 400

Mensagem: "Transição de estado inválida"

TC-STATE-03 — Reabrir pedido cancelado

Passos:
Criar pedido
Cancelar pedido
Tentar marcar como Pago

Resultado esperado:
Bloqueado
Status permanece Cancelado
Log de tentativa inválida

TC-STATE-04 — Repetir ação já executada

Passos:
Pedido = Pago
Executar "iniciar preparo"
Executar "iniciar preparo" novamente

Resultado esperado:
Segunda tentativa rejeitada
Sem duplicação de evento

Mensagem clara

TC-STATE-05 — Teste via API (muito comum no trabalho)

Passos:
POST /pedido → cria pedido
PUT /pedido/status=Pago
PUT /pedido/status=Entregue

Resultado esperado:
API rejeita segunda chamada
Erro de transição inválida
</code></pre></small>

            <p id="textoPost">Bug Report é relatório apresentando informações detalhadas sobre erro (bug). Dados serão cadastrados em planilhas ou ferramentas de gerenciamento de falhas, como Jira, Mantis, Testlink, etc. Compõe das seguintes etapas:</p>
            <ol>
                <li>ID: identificação única do bug;</li>
                <li>Título: descrição objetiva do problema;</li>
                <li>Projeto/Módulo: onde bug foi encontrado;</li>
                <li>Tipo: tipo do bug (funcional, UI, performance, segurança, etc);</li>
                <li>Severidade: impacto do bug (crítico, alto, médio, baixo);</li>
                <li>Prioridade: urgência para correção (alta, média, baixa);</li>
                <li>Status: situação atual do bug (aberto, em progresso, resolvido, fechado);</li>
                <li>Responsável: pessoa ou time encarregado da correção;</li>
                <li>Reportado por: quem encontrou o bug;</li>
                <li>Data: data de registro do bug;</li>
                <li>Ambiente: detalhes do ambiente onde bug foi encontrado (sistema operacional, navegador, versão do software, etc);</li>
                <li>Descrição do problema: explicação detalhada do bug;</li>
                <li>Pré-condições: condições necessárias para reprodução do bug;</li>
                <li>Passos para reprodução: sequência detalhada para reproduzir o bug;</li>
                <li>Resultado esperado: o que deveria acontecer;</li>
                <li>Resultado obtido: o que realmente aconteceu;</li>
                <li>Evidências: screenshots, logs ou vídeos que comprovem o bug;</li>
                <li>Impacto: análise do impacto do bug no sistema ou usuários;</li>
                <li>Observações: informações adicionais relevantes.</li>
            </ol>
<small><pre><code>
ID: BUG-ECOM-1427
Título: Cupom de desconto é aplicado duas vezes ao clicar rapidamente no botão "Aplicar cupom"

Projeto: Plataforma E-commerce Web
Módulo: Checkout / Pagamento

Tipo: Funcional - Regra de negócio / cálculo incorreto
Severidade: Alta - valor do pedido fica incorreto
Prioridade: Alta - afeta faturamento
Status: Aberto
Responsável: Time Backend - Checkout Service
Reportado por: UB Social - QA
Data: 10/02/2026

Ambiente: 
Sistema Operacional: Ubuntu 25.04
Navegador: Chrome 144
Versão do sistema: v3.18.2
Ambiente: Homologação

URL: https://hml.lojaexemplo.com/checkout

Descrição do problema: Ao inserir cupom de desconto válido e clicar rapidamente 2 ou mais vezes no botão "Aplicar cupom", sistema aplica desconto múltiplas vezes, reduzindo valor total do pedido de forma incorreta. Sistema deveria permitir apenas 1 aplicação de cupom por pedido.

Pré-condições:
Usuário logado
Produto no carrinho
Valor do carrinho acima de R$200
Cupom válido disponível (ex: DESC10)

Passos para reprodução:
Acessar checkout
Adicionar produto ao carrinho (ex: R$300)
Ir para tela de pagamento
Inserir cupom DESC10
Clicar rapidamente 2–3 vezes no botão "Aplicar cupom"
Observar o valor total

Resultado esperado:
Cupom aplicado apenas 1 vez
Desconto de 10% aplicado 1 única vez
Botão deveria desabilitar após primeiro clique

Valor esperado:
R$300 → R$270

Resultado obtido:
Cupom aplicado múltiplas vezes
Desconto duplicado ou triplicado

Valor observado:
R$300 → R$270 → R$243 → R$218,70

Evidências:
Screenshot anexado: bug1427_total_duplicado.png
Vídeo reprodução: bug1427_click_duplo.mp4
Log de requisições mostra múltiplos POST /apply-coupon

Impacto:
Perda financeira direta
Exploração fácil pelo usuário
Afeta cálculo de receita
Pode gerar inconsistência contábil
Risco de uso indevido em larga escala

Observações:
Problema não ocorre se clicar apenas uma vez
Endpoint permite múltiplas requisições simultâneas
Possível falta de idempotência no backend

Recomenda-se:
desabilitar botão após clique
validar cupom já aplicado no servidor
</code></pre></small>

            <br><hr><h4>Aula 3- Design de Testes para Aplicações Web:</h4>
            <ul>
                <li class="text-warning">Análise de requisitos para aplicações web</li>
                <li class="text-warning">Identificação de fluxos críticos</li>
                <li class="text-warning">Design de testes funcionais para aplicações web</li>
                <li class="text-warning">Design de testes não funcionais para aplicações web</li>
                <li class="text-warning">Criação de cenários de teste baseados em navegação, formulários e validações</li>
            </ul>
        </div>
    </div>


<!--Rodapé-->
<div class="row">
    <div class="col-sm-12 text-center bg-black text-light pt-4 pb-3">
        <p>Elaborado por Mateus Schwede<br><small class="text-muted">ubsocial.github.io</small></p>
    </div>
</div>

</div>
</body>
</html>


<!-- ANOTAÇÕES:
VENDO AQUI: https://www.tricentis.com/learn/getting-started-with-test-design
https://www.testim.io/blog/test-case-design-guide-for-qa-engineers/
https://www.testim.io/blog/test-strategy-vs-test-plan/
https://www.testim.io/blog/test-suite/

https://talkingabouttesting.com/2024/10/13/design-de-testes-o-que-todo-mundo-deveria-saber-sobre-automacao-de-testes/
-->