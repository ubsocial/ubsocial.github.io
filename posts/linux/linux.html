<!doctype html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" href="../../icons/logoTit.png">
    <link rel="stylesheet" href="../../estilo.css">
    <title>UB Social</title>
</head>
<body>
<div class="container-fluid">


    <div class="row">
        <div class="col-sm-12">
            <nav class="navbar rounded-bottom fixed-top navbar-expand-lg navbar-light bg-light shadow">
                <div class="container-fluid">
                    <a class="navbar-brand" href="../../index.html"><img src="../../icons/logo.png" class="d-inline-block align-text-top" width="11pt"> UB Social</a>
                    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
                    <div class="collapse navbar-collapse" id="navbarNav">
                        <ul class="navbar-nav">
                            <li class="nav-item"><a class="nav-link" href="../../index.html">Home</a></li>
                            <li class="nav-item"><a class="nav-link" href="../../sobre/sobre.html">Sobre</a></li>
                            <li class="nav-item"><a class="nav-link" href="../../livros/livros.html">Livros</a></li>
                        </ul>
                    </div>
                </div>
            </nav>
        </div>
    </div>

    <div class="row">
        <div class="col-sm-12 text-center" id="titulo">
            <h1>Linux</h1>
            <h6><strong>Conceitos técnicos e gestão prática</strong></h6>
            <a href="../../index.html" class="btn btn-link text-decoration-none mb-3">Voltar</a><br>
            <a href="https://youtube.com/playlist?list=PLnPZ9TE1Tj4DrAn4b0aK3fgO9RrJkE2FJ&si=Ptc4DHav8FvzQhsy" class="btn btn-link text-decoration-none mb-3" target="_blank"><svg xmlns="http://www.w3.org/2000/svg" width="1.3em" height="1.3em" fill="currentColor" class="bi bi-youtube text-danger" viewBox="0 0 16 16"><path d="M8.051 1.999h.089c.822.003 4.987.033 6.11.335a2.01 2.01 0 0 1 1.415 1.42c.101.38.172.883.22 1.402l.01.104.022.26.008.104c.065.914.073 1.77.074 1.957v.075c-.001.194-.01 1.108-.082 2.06l-.008.105-.009.104c-.05.572-.124 1.14-.235 1.558a2.007 2.007 0 0 1-1.415 1.42c-1.16.312-5.569.334-6.18.335h-.142c-.309 0-1.587-.006-2.927-.052l-.17-.006-.087-.004-.171-.007-.171-.007c-1.11-.049-2.167-.128-2.654-.26a2.007 2.007 0 0 1-1.415-1.419c-.111-.417-.185-.986-.235-1.558L.09 9.82l-.008-.104A31.4 31.4 0 0 1 0 7.68v-.123c.002-.215.01-.958.064-1.778l.007-.103.003-.052.008-.104.022-.26.01-.104c.048-.519.119-1.023.22-1.402a2.007 2.007 0 0 1 1.415-1.42c.487-.13 1.544-.21 2.654-.26l.17-.007.172-.006.086-.003.171-.007A99.788 99.788 0 0 1 7.858 2h.193zM6.4 5.209v4.818l4.157-2.408L6.4 5.209z"/></svg> Conteúdo disponível</a>
        </div>
    </div>

    <div class="row">
        <div class="col-sm-12">

            <div class="card mb-4">
                <h4 class="card-header">Fundamento</h4>
                <div class="card-body">
                    <p>Criado em 1991 por Linus Torvalds, Linux não é um SO completo. É um kernel livre baseado em Unix (Ken Thompson e Dennis Ritchie), Minix, desenvolvido em C, considerado, inicialmente, um emulador de terminal para uso em Unix. Através de Richard Stallman, Linus conhece o projeto GNU, onde, futuramente, licencia o kernel Linux (GNU/Linux). Sua 1ª distribuição comercial foi a Yggdrasil Linux/GNU/X, lançada em 1992, no formato Live CD. O mascote do Linux é o pinguim Tux (Torvalds' Unix ou Tuxedo). Atualmente, 90% dos servidores web são Linux, correspondendo 99% dos supercomputadores no mundo. Linux está presente na maior parte de nossa rotina, como em dispositivos embarcados (smart TVs, Android, MacOS, video games, eletrodomésticos, multimídias automotivas, caixas eletrônicos), órgãos governamentais (forças armadas, departamentos governamentais), aplicações críticas (trens bala, CERN, sistemas de tráfego aéreo, reatores nucleares, foguetes de sondagem, artilharias de guerra), entre outros. Isso ocorre porque o Linux é Free (livre), onde não há restrição legal para manuseamento do código, permitindo, dessa forma, personalização profunda, de acordo com a necessidade. Além disso, o kernel possui enorme comunidade de contribuidores, ocasionando frequentes atualizações de integridade e otimização. Seu código fonte está disponível em <a href="https://www.kernel.org" class="text-decoration-none" target="_blank">kernel.org</a>. Principais órgãos certificadores são LPI (Linux Professional Institute), Red Hat e The Linux Foundation. Esse resumo prepara você para concluir a certificação LPI Linux Essentials, a certificação básica do LPI. Tais certificações são reconhecidas mundialmente. Software livre (free software - Free as in freedom. "free" as in "free speech", not as in "free beer") possui código aberto (open source) e segue as diretrizes da GPL. Free refere-se ao conceito de liberdade, não ao preço de gratuidade (FOSS - Free and Open Source Software, FLOSS - Free/Libre and Open Source Software, sendo FLOSS a maneira mais correta, SL/CA - Software Livre e de Código Aberto). A criação da organização Creative Commons (CC), juntamente com suas licenças, disponibiliza maior diversificação de regras nos direitos autorais do mesmo, permitindo maior cooperação do projeto com a comunidade. Licenças baseadas em Creative Commons são as mais utilizadas na web.. Nem todo software open source (código aberto) é free software, nem mesmo gratuito. Customização, suporte, treinamento e serviços terceiros sob free software podem ser cobradas. Manifesto GNU (GNU not Unix) foi atrelado a FSF (Free Software Foundation), criados por Stallman para armazenar a GPL (GNU General Public License), que possui 4 liberdades:</p>
                    <ol start="0">
                        <li><b>Executar</b> o software para qualquer propósito ou finalidade;</li>
                        <li><b>Estudar</b> o funcionamento interno do software, podendo fazer alterações e adaptações conforme necessidade;</li>
                        <li><b>Modificar</b> e melhorar o software, para que a comunidade possa beneficiar-se das mesmas;</li>
                        <li><b>Distribuir</b> o software, contanto que a distribuição seja com as mesmas liberdades que o software recebido, como não fechar o código.</li>
                    </ol>
                    <p>Licenças como essas são Copyleft (contrárias a Copyright). A LGPL (GNU Lesser General Public License) foi escrita como meio-termo da GPL, permitindo associação com softwares que não estejam sob licenças GPL e LGPL, incluindo software proprietário. A AGPL (GNU Affero General Public License) cobre venda de acesso a software hospedado. A FDL (GNU Free Documentation License) estende princípios da liberdade à documentação do software. Licença permissiva (permissive), contrária à Copyleft, permite ao proprietário criar suas próprias cláusulas. Open Source Initiative (OSI) é organização dedicada a promover free software, a qual os principais projetos de free software estão vinculados.</p>

                    <h5>Principais free softwares:</h5>
                    <ul>
                        <u>Escritório</u>:
                        <li>OpenOffice/LibreOffice/ONLYOFFICE, similar ao Microsoft Office
                            <ul>
                                <li>Writer: editor de texto, similar ao Word;</li>
                                <li>Calc: planilhas, similar ao Excel;</li>
                                <li>Impress: slides, similar ao PowerPoint;</li>
                                <li>Draw: desenho vetorial;</li>
                                <li>Math: formulas matemáticas;</li>
                                <li>Base: banco de dados;</li>
                            </ul>
                        </li>
                        <li>Mozilla Thunderbird: gestão de e-mails, similar ao Outlook e Gmail;</li>
                        <li>Scribus: edição de publicações, similar ao InDesign;</li>
                        <li>Calibre e Foliate: gestão de ebooks, similar ao Kindle;</li>
                        <li>Moodle: ambiente de aprendizagem online, similar ao Google Classroom;</li>
                        <li>MediaWiki: gestão de enciclopédias online (Wikipédia);</li>
                        <li>Skanlite e Simple Scan: digitalização de impressão;</li>
                        
                        <br><u>Network</u>:
                        <li>Mozilla Firefox: browser web, similar ao Chrome;</li>
                        <li>Chromium: browser alternativa free ao Chrome;</li>
                        <li>Wireshark: análise de rede;</li>
                        <li>OpenVPN: serviço VPN, similar a NordVPN;</li>
                        <li>Remmina: conexão remota, similar ao TeamViewer;</li>
                        <li>FileZilla: cliente FTP;</li>
                        <li>Wordpress: gestão de websites, similar ao Wix;</li>
                        <li>KDE Connect: conexão e sincronização do dispositivo com celular;</li>
                        <li>Kodi: hub de home theater e entretenimento, similar a Netflix;</li>

                        <br><u>Multimídia</u>:
                        <li>Blender: renderização e animações 3D (Toystory, Titanic,  20th century fox);</li>
                        <li>GIMP (GNU Image Manipulation Program) e Krita: edição de imagens, similar ao Photoshop (Álbum Lemonade Beyoncé);</li>
                        <li>Photoscape: similar ao GIMP, com menos funcionalidades;</li>
                        <li>Inkscape: editor de gráficos vetoriais, similar ao Corel Draw e Illustrator;</li>
                        <li>Shotwell: edição simples de imagens, similar ao Illustrator;</li>
                        <li>ImageMagick: converter e editar imagens, via CLI</li>
                        <li>Audacity: edição profissional de áudio, similar ao Adobe Audition;</li>
                        <li>VLC (VideoLAN Client media player): player de mídias áudio visuais;</li>
                        <li>Rhythmbox: player de áudio;</li>
                        <li>Shotcut, Lightwork e Kdenlive: edição profissional de vídeo, similar ao Adobe Premiere e Final Cut Pro;</li>
                        <li>OBS (Open Broadcaster Software) Studio: streaming e gravação;</li>
                        <li>MuseScore: criação de partituras musicais;</li>

                        <br><u>Utilitários</u>:
                        <li>QEMU (Quick EMUlator), GNOME Boxes: gestão de máquinas virtuais, similar a VMWare e Virtualbox;</li>
                        <li>KTorrent e Transmission: softwares BitTorrents, para gestão de torrent, similar ao uTorrent;</li>
                        <li>vim (Vi IMproved): editor de texto CLI;</li>
                        <li>7-Zip: descompactador e desempacotador, similar ao WinRAR;</li>
                        <li>GParted (GNOME Partition Editor): gestão de disco;</li>
                        <li>Discover, Snap Store, Flathub, Gnome software: lojas de aplicativos, similar a Microsoft Store e App Store;</li>

                        <br><u>Tecnologias</u>:
                        <li>Apache e nginx: servidor HTTP;</li>
                        <li>Eclipse e VSCodium: ambiente de desenvolvimento, similar ao VSCode, Visual Studio e IntelliJ;</li>
                        <li>PostgreSQL, MariaDB, Apache Cassandra: bancos de dados, similares a Oracle DB, SQL Server, MySQL e MongoDB;</li>
                        <li>Git: versionamento de projetos;</li>
                        <li>OpenJDK: tecnologia Java, versão free software do Oracle JDK;</li>
                        <li>Além disso, tem-se também excelentes ferramentas ERP, CRM, etc.</li>
                    </ul>

                    <h5>Estrutura/camadas de sistema Linux:</h5>
                    <ol>
                        <li><b>Hardware</b>: Componentes físicos do dispositivo;</li>
                        <li><b>Kernel Linux</b>: Núcleo do sistema operacional. Mediador entre hardware e camadas superiores;</li>
                        <li><b>Sistema Operacional</b> (SO): Auxilia e hospeda aplicações e arquivos das camadas superiores;</li>
                        <li><b>Terminais Virtuais</b> (teletypes: tty1..6..63): Interpretam comandos binários e convertem para linguagem de máquina. Camada de execução de comandos e configurações;</li>
                        <li><b>Servidor Gráfico</b>: Base de implantação do ambiente gráfico (GUI). Entre os principais, tem-se Xorg (X ou X11) e Wayland (Wayland Compositor);</li>
                        <li><b>Display Manager</b> (DM): Gerencia logins na GUI e seleciona tipo de GUI que será executada;</li>
                        <li><b>Desktop</b>: Camada que hospeda aplicações dependentes de GUI para funcionamento.</li>
                    </ol>

                    <h5>Tipos de kernel GNU/Linux:</h5>
                    <ul>
                        <li><b>Generic (Stable)</b>: Padrão de SOs Linux;</li>
                        <li><b>LTS (Longterm)</b>: Maior suporte e estabilidade;</li>
                        <li><b>Zen</b>: Open Source, fork do Generic, objetivo de otimização;</li>
                        <li><b>Liquorix</b>: Similar ao Zen, objetivo de otimização para games e mídia;</li>
                        <li><b>Hardened</b>: Open Source, objetivo de segurança e robustez, menos performance;</li>
                        <li><b>XanMod</b>: Objetivo de performance;</li>
                        <li><b>HWE</b>: Hardware Enablement (HWE) Kernel, desenvolvido pela Canonical (Ubuntu), consiste em versão do kernel GNU/Linux com partes LTS e, ao mesmo tempo, partes modernas, objetivando funcionamento em hardware antigo e moderno. Faz parte do programa  de Enablement Stack do Ubuntu, que oferece suporte contínuo para hardware novo sem necessidade de atualizar para versão completamente nova do sistema operacional.</li>
                    </ul>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Distros</h4>
                <div class="card-body">
                    <p>Uma distribuição (distro) Linux é um SO com kernel Linux (GNU/Linux). Atualmente, há cerca de 600 distros, nem todas gratuitas. As distros base (from scratch) são Slackware, Debian, Red Hat Enterprise Linux (RHEL), Gentoo, SUSE e Arch. Com isso, criou-se uma árvore de distros geradas a partir de suas progenitoras (<a href="https://commons.wikimedia.org/wiki/File:Linux_Distribution_Timeline_27_02_21.svg" class="text-decoration-none" target="_blank">timeline distros Linux</a>). Como exemplo, o Ubuntu é baseado no Debian, o Mint é baseado no Ubuntu. O Fedora e o CentOS são versões free do RHEL. O <a href="https://distrowatch.com" class="text-decoration-none" target="_blank">distrowatch</a> possui todas notícias sobre distros Linux. A versão não modificada do kernel Linux é chamada de 'Vanilla'. A distro mais antiga em atividade é o Slackware.</p>
                    <ul>
                        <li>Distros <b>versionadas</b> (lançamentos versionados);
                            <ul>
                                <li>LTS (long term support): Possui atualizações menos frequentes e pacotes mais estáveis. Ex: Ubuntu LTS;</li>
                                <li>testing: Versão não LTS, possui as mais recentes atualizações publicadas. Ex: Debian Testing;
                                    <ul>
                                        <li>Point release: Versões de distros GNU/Linux lançadas frequentemente, geralmente a cada 6 ou 8 meses (ex: 20.1, 20.2, <s>20.4 é LTS</s>).</li>
                                    </ul>
                                </li>
                                <li>unstable: Possui as atualizações mais recentes e que ainda não foram publicadas (beta). Ex: Debian Unstable.</li>
                            </ul>
                        </li>
                        <li>Distros <b>rolling release</b> (lançamentos contínuos, atualizações constantes, ausência de versionamento). Ex: Gentoo, Arch Linux e openSUSE Tumbleweed;</li>
                        <li>Distros <b>imutáveis</b>: Similares a rolling release, porém com objetivo de kernel e libraries imutáveis, onde os pacotes instalados são independentes do sistema, como via containers. Pode-se instalar pacotes diretamente ao sistema, mas, a cada modificação direta nele, será gerado novo snapshot do sistema e, via confirmação de atualização pelo usuário, o sistema inteiro será novamente instalado, juntamente com as modificações realizadas. Ex: Fedora Silverblue.</li>
                    </ul>
                    
                    <h5>GUI e CLI:</h5>
                    <p>Toda distro é <b>CLI</b> (command-line interface), onde há ausência de interface gráfica, sendo somente modo texto. Servidores geralmente utilizam somente CLI. Distros com adesão de <b>GUI</b> (graphical user interface) possuem interface gráfica, sendo essa renderizada através de <b>desktop environment</b> (DE). Desktop environment engloba a interface gráfica do gerenciador de janelas, além de seus respectivos softwares. Window manager (gerenciador de janelas) utiliza compositor de janelas, responsável por renderizar as janelas na GUI, por exemplo Compton e Openbox. Os DEs são diferentes no que diz respeito a uso de recursos de hardware no dispositivo, customização e aparência. Entre os principais DEs, tem-se:</p>
                    <ul>
                        <li>Gnome (GNU network object model environment): Principal DE Linux, possui widget toolkit GTK (ou GTK+, ou GIMP Toolkit) e servidores gráficos Xorg e Wayland. Caracteriza-se por ser mais responsivo, minimalista e, ao mesmo tempo, completo em funcionalidades. Portanto, consome mais recursos de hardware do dispositivo. A GUI do Gnome é Gnome Shell. Usa compositor de janelas Mutter e, em algumas distros, Metacity;</li>
                        <li>KDE (K desktop environment): Utiliza widget toolkit Qt (ou 'cute'). Caracteriza-se por ser extremamente customizável e consome poucos recursos de hardware do dispositivo. A GUI do KDE é KDE Plasma. Usa compositor de janelas Kwin;</li>
                        <li>XFCE (XForms common environment): Caracteriza-se por ser mais estável e consumir menos recursos de hardware do dispositivo. Utiliza servidor gráfico Xorg. Usa compositor de janelas xfwm;</li>
                        <li>MATE (MATE advanced traditional environment): Nome advindo da 'erva-mate', caracteriza-se por ser leve e customizável. Usa compositor de janelas Metacity;</li>
                        <li>LXDE (Lightweight X11 desktop environment): Caracteriza-se por consumir pouquíssimos recursos de hardware do dispositivo. Utiliza widget toolkit GTK. Usa compositor de janelas Openbox;</li>
                        <li>LXQt (LXDE + Qt): Utiliza widget toolkit Qt, caracteriza-se por consumir pouquíssimos recursos de hardware do dispositivo;</li>
                        <li>Cinnamon: Caracteriza-se por ser extremamente similar ao Windows. Consome poucos recursos de hardware do dispositivo;</li>
                        <li>Fluxbox: Caracteriza-se por consumir pouquíssimos recursos de hardware do dispositivo;</li>
                        <li>Deepin DE (desktop environment): Caracteriza-se por ser extremamente similar ao MacOS;</li>
                        <li>Pantheon: Caracteriza-se por ser extremamente similar ao MacOS. Baseado no Gnome, utiliza widget toolkit GTK;</li>
                        <li>Unity: Alternativo ao Gnome, utiliza widget toolkit GTK;</li>
                        <li>Budgie Desktop: Utiliza GTK, alternativo ao Gnome, baseando-se no mesmo;</li>
                        <li><i>Tile/Tiling window managers (TWM)</i>: Categoria de DEs gerenciadores de janelas estáticas e ajustadas automaticamente, focados na utilização somente via teclado. Geralmente voltados para uso em ambientes terminais somente shell. Possui como objetivos o minimalismo e foco. Geralmente configuráveis via arquivos de texto declarativos. Há possibilidade de utilizá-los em conjunto com demais DEs. Exemplos:
                            <ul>
                                <li>i3WM: Mais popular TWM;</li>
                                <li>Sway (executado sob Wayland);</li>
                                <li>WindowMaker;</li>
                                <li>AwesomeWM.</li>
                            </ul>
                        </li>
                        <li>Entre outros.</li>
                    </ul>
                    <p>Em muitas situações, pode-se optar por qual DE instalar na distro. Como, por exemplo, no Debian, optar entre Debian Gnome, Debian KDE, Debian XFCE, etc. Além disso, pode-se instalar um tipo de GUI, com DE não pertencente a mesma (exemplo GUI Gnome Shell em DE XFCE). <b>XApps</b> são apps GNU/Linux, com visual GTK, desenvolvidos pela equipe do Mint, com objetivo de fornecer experiência  global e independente entre diferentes DEs, garantindo funcionamento em qualquer ambiente desktop GUI GNU/Linux. Distros com DEs como XFCE, LXQt, MATE e Fluxbox são ideais para hardware obsoleto. Distros com DEs como XFCE, KDE e Cinnamon possuem mais similaridade com Windows. Distros com DEs como Pantheon e Deepin DE possuem mais similaridade com MacOS. Linux <b>Mesa</b>/Mesa3D/The Mesa 3D Graphics Library é conjunto de hospedagem de implementações de APIs gráficas opensource (como a OpenGL), para comunicação com drivers gráficos do Kernel Linux, como Intel e NVidia AMD. Linux <b>Proton</b> é a camada de compatibilidade da Valve, para funcionamento de games nas distros. Sistemas GNU/Linux embarcados como Raspberry Pi OS (Raspbian) funcionam em hardware como placas Raspberry Pi. O <b>PulseAudio</b> é servidor de som que age como um intermediário entre aplicações de áudio o hardware de som, permitindo flexibilidade na gestão de fluxos de áudio. O <b>JACK</b> (JACK audio connection kit) é daemon de servidor de som profissional que fornece conexões em tempo real e baixa latência para dados de áudio e MIDI entre aplicativos que implementam sua API. O <b>PipeWire</b> é tecnologia que visa unificar e substituir PulseAudio e JACK, oferecendo um servidor de mídia multimodal na gestão de áudio e vídeo.</p>
                    <h5>Servidores:</h5>
                    <p>Dispositivos com função de prover determinados serviços, de forma segura e eficaz. Geralmente são classificados da seguinte maneira:</p>
                    <ul>
                        <li><b>Web</b>: Provê resposta requisitada pelo dispositivo cliente, via protocolo HTTP (Hypertext Transfer Protocol). Entre os principais softwares para gestão de servidor web tem-se Apache, nginx, Node.js e lighttpd;</li>
                        <li><b>Banco de dados</b>: Armazenamento e gestão de dados. Entre os principais softwares para gestão de banco de dados, tem-se Oracle DB, MySQL, SQL Server, MariaDB, PostgreSQL e MongoDB;</li>
                        <li><b>Armazenamento de dados</b>: Utilizado em dispositivos corporativos/domésticos para comunicação e armazenamento de dados. Entre dispositivos Linux, o protocolo NFS (Network File System) permite criação e acesso de diretórios remotos. Windows possui o Samba (SMB - Simple Message Block), para comunicação com outros dispositivos Linux. OwnCloud é servidor de armazenamento de dados em cloud. NextCloud é similar, possuindo funcionalidades extras, como videoconferência e funções relacionadas;</li>
                        <li><b>Arquivos</b>: Utilizados para acesso/gestão de arquivos e diretórios diretamente, via protocolo FTP (File Transfer Protocol);</li>
                        <li><b>Aplicação (Applications Server)</b>: Execução de aplicações diversas, que podem ser utilizadas de forma compartilhada, sem comprometer desempenho e integridade. Entre as principais aplicações, tem-se Java, PHP e .NET;</li>
                        <li><b>Email</b>: Gestão de emails, via protocolo SMTP (Simple Mail Transfer Protocol). Geralmente utilizado em conjunto com servidores web (servidor <b>webmail</b>);</li>
                        <li><b>Streaming</b>: Transmissão de recursos de mídia em tempo real, via padrão DLNA (Digital Living Network Alliance);</li>
                        <li><b>Backup</b>: Armazenamento seguro de cópias de dados;</li>
                        <li><b>Proxy</b>: Filtragem de requisições entre cliente e servidor (intermediador), fornecendo privacidade, onde o IP da operação é o do Proxy;</li>
                        <li><b>Jogos</b>: Execução de games, fornecendo desempenho e banda larga. Servidores <b>VPS</b> (Virtual Private Server) podem ser utilizados para tal, criando máquinas virtuais para maior desempenho;</li>
                        <li><b>DNS</b>: Fornece tradução de nomes de domínio (Domain Name Service) para IPs;</li>
                        <li><b>DHCP</b>: Gestão automatizada de fornecimento de endereços IPs (DHCP - Dynamic Host Communication Protocol);</li>
                        <li><b>Blade</b>: Servidor físico que ocupa espaços menores, muito utilizado em redes locais;</li>
                        <li><b>Impressão</b>: Gestão, em larga escala, de impressão de documentos;</li>
                        <li><b>Fax</b>: Gestão automatizada, em larga escala, de envio/recebimento de fax;</li>
                        <li><b>Sistema operacional</b>: Armazenamento de sistema operacional em máquina física, para acesso remoto e compartilhado.</li>
                    </ul>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Instalação</h4>
                <div class="card-body">
                    <p>Existem diversas formas para utilizar distros Linux. Pode-se instalá-lo diretamente na máquina (<b>bare metal</b>), via pendrive bootável (live boot), unicamente ou ao lado de outro SO já presente no dispositivo (dual boot, multi boot). Primeiramente, precisa-se baixar o arquivo .iso da distro, para posteriormente formatar o pendrive com a .iso selecionada (pendrive bootável), através de algum software específico, como balenaEtcher. Após formatação concluída, o computador precisa ser reiniciado e sua BIOS acessada (F12), para selecionar opção de boot do pendrive. Os principais instaladores de distros Linux são Anaconda (Sabayon), DI (Debian-Installer), Drakx Installer (Mandriva/Mageia), Sysinstaller, Ubiquity (Ubuntu16), Calamares (Red Hat), YaST (SUSE), etc. Outro meio para utilizar distro Linux é através de <b>VM</b> (virtual machine) com o arquivo .iso da distro. Outra alternativa é através de <b>containers</b>. Via Windows, pode-se utilizar distro Linux via <b>WSL</b> (Windows Subsystem for Linux). Por fim, pode-se utilizar distro Linux online, via plataforma <b>cloud</b>, como Amazon, Azure, GCP, etc. Distros <b>modo incógnito</b> são live USB que são executadas na memória RAM do dispositivo, com processamento e armazenamento volátil, ou seja, removido após desligamento do dispositivo.</p>

                    <h5>Tipos de instalação (iso):</h5>
                    <ul>
                        <li><b>USB</b>: Geralmente associada à pendrive bootável, para instalação/teste no dispositivo;</li>
                        <li><b>Live</b>: Geralmente associada à Live USB, para utilizar a distro sem necessidade de instalação. Leve;</li>
                        <li><b>CD</b>: Geralmente mais leve, possui menos recursos, geralmente necessita de internet para instalação de demais programas, ou descartando, dependendo do tamanho do CD. Geralmente instalação mais direta que USB;</li>
                        <li><b>DVD</b>: Geralmente mais pesada, possui todos os recursos para instalação, geralmente descartando internet. Mais pesada que o comum;</li>
                        <li><b>NetInstall</b>: Geralmente associada, ou à USB ou à pequeno CD, para instalação totalmente dependente de internet. Extremamente leve;</li>
                        <li><b>non-free</b>: Imagem completa, contendo, inclusive, toda gama de conectores de hardware de todos fabricantes. Geralmente a mais pesada;</li>
                        <li><b>Netboot</b>: Forma de instalação. Geralmente associada à instalação direta, via rede TFTP, DHCP/BOOTP/RARP, utilizando PXE e TFTP;</li>
                        <li><b>Torrent</b>, <b>Container</b>, <b>ARM</b>, <b>Cloud</b>, <b>VM</b>, <b>Mobile</b>, <b>Build Scripts</b>: Outras formas de instalação, sendo build scripts os arquivos de códigos.</li>
                    </ul>

                    <h5>Particionamento de disco:</h5>
                    <p>Objetivo do particionamento é separar, ao máximo, as finalidades dos diretórios com relação ao dispositivo de armazenamento, facilitando assim a manutenção, em caso de falhas/erros em uma partição, onde as demais permanecerão intactas.</p>
                    <p><b>Desktop</b>:<br>Particionamento de disco com 500GB disponíveis para armazenamento e 4GB de RAM, para instalação de Ubuntu 20. Formatação do tipo GPT (GUID Partition Table) ou MBR (Master Boot Record), será da seguinte forma:</p>
                    <ul>
                        <li><b>Boot</b>: Partição para boot da distro, tipo primária FAT32, com label <i>/boot/efi</i>, com média de 800MB;</li>
                        <li><b>Swap</b>: Partição de memória virtual, tipo primária linux-swap, sem label, com média de metade do tamanho da RAM ou mais (aqui no caso 2GB);</li>
                        <li><b>Root</b>: Partição raíz, onde ficará o sistema, tipo primária journaling EXT4 (ou BTRFS), com label <i>/</i>, preenchendo com o restante do espaço livre.
                            <ul>
                                <li><span class="text-muted">Opcional</span> (Partição <b>home</b> separada): Partição onde ficarão os arquivos dos usuários (documentos, imagens, vídeos, etc), do tipo primária journaling EXT4, com label <i>/home</i>, preenchendo com o espaço livre restante (Neste caso, 40% do espaço livre restante será de home, e os demais 60% será de root);</li>
                                <li><span class="text-muted">Opcional</span> (<b>criptografia</b>): Pode-se criptografar a participação root com o LUKS (Linux Unified Key Setup-on-disk-format. Ferramentas como Dm-crypt e Cryptsetup realizam tal procedimento em discos já formatados).</li>
                            </ul>
                        </li>
                    </ul>
                    <p><b>Servidor</b>:</p>
                    <u>Particionamento 1</u>:
                    <p>Particionamento de disco com 40GB, em modo antigo MBR BIOS (não EFI, onde criaria somente partições primárias).</p>
                    <img src="partServidor.png" class="img-fluid" width="350px">
                    <ul>
                        <li><b>Boot</b>: Tipo primária, localização início, journaling EXT4, ponto de montagem <i>/boot</i>, com média de 1GB;</li>
                        <li><b>Swap</b>: Tipo primária, localização início, swap, com média de 2GB;</li>
                        <li><b>LVM</b>: Tipo lógica, localização início, volume físico LVM, com média de 15GB (logical volume management, faz tamanho da partição ser dinâmico (criação de volumes lógicos), sem perda de dados);</li>
                        <li><b>usr</b>: Tipo lógica, localização início, journaling XFS, ponto de montagem <i>/usr</i>, com média de 20GB;</li>
                        <li><b>tmp</b>: Tipo lógica, localização início, journaling EXT4, ponto de montagem <i>/tmp</i>, opção de montagem 'noexec' (não permite executar binários), com média de 1GB;</li>
                        <li><b>Root</b>: Tipo lógica, localização início, journaling EXT4, ponto de montagem <i>/</i>, com média de 10GB;</li>
                        <li><b>var</b>: Configurar LVM, criando grupo de volumes (nome 'system'), selecionar partição LVM acima. Com isso, criar volume lógico, grupo 'system' (nome 'var'), tamanho restante disponível. Selecionar volume lógico e usar como journaling XFS, ponto de montagem <i>/var</i>;</li>
                        <li><b>Espaço livre</b>: Conforme finalidade do servidor. Partição tamanho total, tipo lógica, ponto de montagem <i>/var/www</i> para servidor Apache, ou <i>/home</i> para desktop, ou <i>/var/mysql</i> para servidor MySQL, ou <i>/srv/samba</i> para servidor de arquivos.</li>
                    </ul>
                    <u>Particionamento 2</u>:
                    <p>Particionamento de disco com 238GB, em modo EFI, com utilização de criptografia. Preferível utilizar BTRFS ao invés de EXT4.</p>
                    <img src="partServidor2.jpg" class="img-fluid rounded" width="350px">
                    <p>Toda distro Linux possui codecs (compatibilizadores de formatos de mídia), pode-se configurar snapshots via gerenciador de backups Timeshift, realizar tarefas agendadas de Cron/Crontab, UFW (Ubuntu firewall) e GUFW (Graphical), gestão de configurações Tweaks, entre outras funcionalidades. Há possibilidade de executar softwares incompatíveis com Linux via softwares interpretadores, como <b>Wine</b> (Wine is not emulator) e <b>PlayOnLinux</b>, através da implementação livre da API do Windows e engenharia reversa.</p>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Estrutura</h4>
                <div class="card-body">
                    <p>No Linux não existem programas, drivers e extensões: Tudo é considerado arquivo. Dispensando conceito de 'pasta', a estrutura de diretórios de arquivos no Linux possui padrão POSIX, baseada em FHS (File system Hierarchy Standard). Até mesmo os componentes de hardware são controlados por arquivos em realtime. Nos caminhos de diretórios, tem-se o <i>caminho absoluto</i> (originado a partir do diretório raíz até o diretório atual, exemplo: <span class="text-muted">/home/ubsocial/arquivo</span>. Comando 'pwd' mostra caminho absoluto - print world directory) e caminho relativo (originado a partir de diretório qualquer até o diretório atual (não originado no diretório '/'), exemplo <span class="text-muted">ubsocial/arquivo</span>).</p>
                    <ul>
                        <li>Diretório root: <b>/</b> <span class="text-muted">(cd /)</span></li>
                        <li>Diretório home: <b>~</b> <span class="text-muted">(cd ~)</span> o mesmo que '/home/usuarioSessao'</li>
                        <li>Diretório atual: <b>.</b> <span class="text-muted">(cd .)</span></li>
                        <li>Diretório pai: <b>..</b> <span class="text-muted">(cd ..)</span></li>
                        <li>Diretório anterior: <b>-</b> <span class="text-muted">(cd -)</span></li>
                    </ul>
                    <p>Todo arquivo oculto inicia com ponto (<b>.</b>) antes do nome. Diretórios possuem barra (<b>/</b>) no final do nome (por convenção, geralmente possuem '.d' no final do nome, nos casos em que o diretório possuir arquivos de serviço específico). Diretórios com <b>@</b> no final do nome são links simbólicos, ou seja, atalhos para o diretório real. Diretórios como /bin, /sbin, /etc, /lib devem estar na mesma partição que '/'.</p>

                    <h5>Estrutura de diretórios:</h5>
                    <ul>
                        <li><b>/</b> (root): Diretório raíz, progenitor de todos os demais, onde encontram-se os diretórios abaixo;</li>
                        <li><b>/bin</b>: Possui todos os binários (user binaries), comandos/alias do shell, disponíveis aos usuários comuns. Link simbólico (ou soft link) para '/usr/bin'. Exemplo, alias 'ls' refere-se a '/bin/ls', ou seja, '/usr/bin/ls';</li>
                        <li><b>/boot</b>: Arquivos estáticos para inicialização (boot) do Linux, como gerenciador GRUB e imagem do kernel;</li>
                        <li><b>/cdrom</b>: Diretório legado (não pertence a FHS), para montagem temporária de imagem de CD-DVD. Local atual para tal é '/media';</li>
                        <li><b>/dev</b>: Arquivos de dispositivos (devices) de entrada e saída, como periféricos, como hd (sda, vda), ssd e usb (sda, sdb), cdrom, disquete floppy (fd) e tty;</li>
                        <li><b>/etc</b>: Abreviação de 'etcetera' ou 'edit do/to config'. Arquivos de configuração do sistema, como scripts de inicialização, módulos de programas, tabela de sistema de arquivos (fstab - file system table), configurações de services e usuários;</li>
                        <li><b>/home</b>: Diretórios dos usuários do sistema. Cada usuário é representado por diretório com seu nome, contendo seus respectivos arquivos dentro (área de trabalho, documentos, imagens, etc);</li>
                        <li><b>/lib, /lib32, /libx32, /lib64</b>: Bibliotecas (libraries) compartilhadas e módulos do kernel. Libraries são scripts que podem ser utilizados por outros arquivos dependentes para seu funcionamento. Links simbólicos para '/usr/lib', '/usr/lib32', 'usr/libx32' e '/usr/lib64';</li>
                        <li><b>/lost+found</b>: Diretório geralmente oculto (/.lost+found) de 'achados e perdidos' (não faz parte da FHS), usado para reparos gerais no sistema, como comando 'fsck';</li>
                        <li><b>/media</b>: Ponto de montagem para mídias removíveis (media), como cdrom, floppy, webcam, usb, hd e ssd externos;</li>
                        <li><b>/mnt</b>: Ponto de montagem temporária (mount) de sistema de arquivos, como outros SOs e cdrom (similar ao '/media');</li>
                        <li><b>/opt</b>: Abreviação de 'optional', utilizado por arquivos proprietários, não licenciados pela GNU, adicionados pelos usuários;</li>
                        <li><b>/proc</b>: Processos (process) do Linux e todas informações do hardware (cpu, memória e partições), módulos carregados no kernel ('/proc/modules') e configurações do kernel ('/proc/sys/'). Diretório virtual (gravado em RAM, volátil, todos arquivos nele são apagados no desligamento do dispositivo);</li>
                        <li><b>/root</b>: Arquivos do usuário administrador (root, 'home do root'), para administração de interface de rede, usuários e grupos, prioridades, entre outros;</li>
                        <li><b>/run</b>: Diretório virtual de arquivos temporários sensíveis de inicialização do sistema, além de informações de services em execução (run, runtime);</li>
                        <li><b>/sbin</b>: Link simbólico para '/usr/sbin', possui os super binários (super binaries ou system binaries), comandos/alias do administrador do Linux (root), utilizados para inicialização, reparação e restauração do sistema, e informações sensíveis de rede. '/usr/local/sbin' armazena super binários instalados localmente, que não são gerenciados pelo gerenciador de pacotes. '/usr/local/bin' é similar, porém voltado aos binários comuns;</li>
                        <li><b>/srv</b>: Serviços (service) do Linux, como rede, acessíveis externamente. Geralmente utilizado para instalação de servidores web ('/srv/www'), samba ('/srv/samba') e ftp ('/srv/ftp');</li>
                        <li><b>/sys</b>: Diretório virtual de mapeamento de chamadas diretas ao kernel (system), sistema de arquivos sys (sysfs), e informações sobre devices e módulos, sendo similar ao '/proc', porém mais organizado e categorizado;</li>
                        <li><b>/tmp</b>: Diretório virtual de arquivos temporários (temp, temporary);</li>
                        <li><b>/usr</b>: Recursos do Linux (user, unix system resources), como libraries e binaries, scripts do kernel ('/src'), documentação ao usuário, além de arquivos não essenciais ao sistema, que seguem padrão GNU. Considerado segunda hierarquia do FHS;</li>
                        <li><b>/var</b>: Arquivos de informações e tamanho variável (variable), como cache, email, logs e impressão ('/spool').</li>
                    </ul>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">File systems e devices</h4>
                <div class="card-body">
                    <h5>File systems:</h5>
                    <p>File system tem objetivo de gerenciar os bytes de dados no dispositivo. Os <b>inodes</b> (index node - nó de índice - nó-i) são elementos de filesystem para armazenar metadados (dados sobre dados, como datas de modificações, diretório de localização, usuário proprietário, etc) de arquivos, através da tabela dos inodes. Comando 'ls -i' mostrará arquivos e inodes. No EXT4, os inodes são criados quando o file system é criado (na instalação da distro), onde há quantidade fixa de inodes no disco (limitada), conforme tamanho dos blocks do file system. Mesmo o disco possuindo mais espaço físico do que inodes, a partir do momento que todos inodes serem preenchidos, não haverá mais espaço para armazenamento. File systems como ZFS, NTFS e BTRFS realizam criação dinâmica de inodes, conforme criação de arquivos no sistema, evitando esgotamento de armazenamento. Quantidade de inodes e blocks é informada via comando 'tune2fs -l /dev/nomeParticaoOuDisco' ou 'df -i'. Função do comando 'ls' é exibir, de forma legível, informações dos inodes. Os inodes em conjunto são como "mapa" dos arquivos no disco, indicando suas posições na estrutura do file system. O <b>superblock</b> (superbloco) é block master, com informações críticas do file system, também usado para unir todos inodes no mesmo. GNU/Linux mantém cópia do superblock em cada file system. Conteúdo de superblock é visto via comando 'dumpe2fs /dev/dev/nomeParticaoOuDisco' ou 'dumpe2fs /dev/dev/nomeParticaoOuDisco | grep superblock'. Backups do superblock são encontrados nos arquivos com blocos de 1K no inode 8193, com blocos de 2K no 16384, e com blocos de 4K no 32768.</p>
                    <ul>
                        <u>Microsoft</u>:
                        <li><b>FAT32</b> (File allocation table): Utilizado em Windows, não suporta journaling;</li>
                        <li><b>exFAT</b> (Extensible FAT): Alternativa ao FAT, melhor compatibilidade entre diferentes file systems. Possui pouquíssimos recursos e suporta arquivos de tamanhos diversos. Ideal para pendrives e HDs externos que acessam diferentes file systems;</li>
                        <li><b>NTFS</b> (New technology file system): Evolução do FAT32, suporte de volumes maiores, possui checksums em journaling e snapshots em volume shadow copy. Compatível com leitura de dados em outros file systems, mas com compatibilidade de escrita instável;</li>
                        <u>Linux</u>:
                        <li><b>ext4</b> (Fourth extended file system): Mais popular em dispositivos Linux "domésticos", possui checksums em journaling;</li>
                        <li><b>ZFS</b> (Zettabyte file system): Gerencia vários volumes (pool), checksums próprios e confiáveis, snapshots e copy on write (COW). O openZFS é a versão free do ZFS. Utilizado em servidores;</li>
                        <li><b>BTRFS</b> (B-tree file system): Simimlar ao ZFS, com otimizações e aberto. Ideal para servidores.</li>
                    </ul>

                    <h5>Devices:</h5>
                    <p>Linux possui 3 formatos de gerenciamento de dados: <b>stdin</b> 0 (standard input, entrada de dados, como via teclado), <b>stdout</b> 1 (standard output, saída de dados, como via display tela) e <b>stderr</b> 2 (standard error, feedback de erro, como via display tela ou arquivo de log). Pode-se alterar o padrão, como redirecionar stderr para arquivo ('<span class="text-muted">ls erro 2&gt; arquivo</span>'). Redirecionar stdout e stderr para mesmo local com '<span class="text-muted">ls -l ubsocial 2&&gt;1 arquivo</span>'. Redirecionar stdout e stderr para locais diferentes com '<span class="text-muted">ls -l ubsocial &gt; arquivo 2&gt; arquivoErros</span>'. O diretório '/dev' armazena arquivos dos dispositivos periféricos, com exceção de placas de rede, que são carregadas via módulo do kernel. Em '/dev' há '/devfs' ou '/udev'. '/dev' carrega todos os módulos ("drivers") do Linux, incluindo os não presentes no hardware host. '/devfs' (filesystem, DevFS) armazena informações de arquivos do dispositivo. '/udev' (userspace /dev - substituto do DevFS) carrega somente módulos encontrados no hardware host, além da configuração automatizada codeplug e hotplug. Seu arquivo de configurações é '/etc/udev/udev.conf' e seus arquivos de regras (rules) estão em '/etc/udev/rules.d/'. Os comando <i>udevmonitor</i> e <i>udevadm monitor</i> permitem modificar eventos armazenados no sistema lógico sysfs, onde ficam as identificações dos dispositivos. Lixeira no GNU/Linux encontra-se em diretório virtual para GUI 'trash:///', sendo o protocolo da lixeira ao desktop environment que é link simbólico para '/home/usuario/.local/share/Trash/', onde há os diretórios 'expunged/' (onde os arquivos apagados são enviados (lixeira da lixeira)), 'files/' (arquivos que estão na pasta lixeira) e 'info/' (informações e metadados dos arquivos na lixeira (diretório origem, data remoção, etc)) com arquivos 'nomeArquivo.trashinfo'. Protocolo da lixeira tem função de unificar diretórios '.Trash/' de todos dispositivos envolvidos, onde todos arquivos removidos serão exibidos na pasta 'lixeira/' da máquina. Diretório '.Trash-1000/' é diretório em dispositivos periféricos, onde ficam arquivos removidos nesse dispositivo. Ou seja, é a lixeira do periférico. Possui diretórios 'files/' e 'info/', com mesmo propósito informado acima. O 1000 significa UID do usuário logado e que apagou o arquivo (se root, então será '.Trash-0/', pois UID de root é 0. Nesse caso, somente root tem permissão de acessar). Comando 'trash nomeArquivo' envia arquivo para lixeira (se instalado o trash em CLI). Comando 'trash-empty' limpará lixeira CLI.</p>
                    
                    <h5>Tipos de devices:</h5>
                    <ul>
                        <li><b>Caractere</b> (c): Orientados à comunicação e fluxo de informações de modo serial, ou seja, caractere a caractere. Utilizados por comunicações entre portas seriais ou paralelas, como modens, e tty's (comunicação com o kernel);</li>
                        <li><b>Bloco</b> (block): Orientados ao armazenamento de informações temporárias de mídia. Geralmente utilizado para representar partições, hd's (sda ou vda) e pendrives;</li>
                        <li><b>FIFO</b> (first in, first out): Processamento de dados em formato de fila, viabilizando comunicação entre dois processos independentes;</li>
                        <li><b>Socket</b>: Voltados à criação de ponto de comunicação.</li>
                    </ul>

                    <h5>Diretórios dos devices:</h5>
                    <ul>
                        <li><b>/dev/fd0</b> e <b>/dev/fd1</b>: Respectivamente, 1ª e 2ª unidade de disquete (floppy disk);</li>
                        <li><b>/dev/hda</b> e <b>/dev/hdb</b>: Dispositivos HD IDE master (hda) e slave (hdb);
                            <ul>
                                <li><b>/dev/hda1</b>: 1ª partição do 1º dispositivo IDE master;</li>
                                <li><b>/dev/hda2</b>: 2ª partição do 1º dispositivo IDE master, e assim por diante;</li>
                                <li><b>/dev/hdb1</b>: 1ª partição do 2º dispositivo IDE master;</li>
                                <li><b>/dev/hdb2</b>: 2ª partição do 2º dispositivo IDE master, e assim por diante;</li>
                            </ul>
                        </li>
                        <li><b>/dev/sda</b> e <b>/dev/sdb</b>: Respectivamente, 1º e 2º dispositivo SSD SATA;
                            <ul>
                                <li><b>/dev/sda1</b>: 1ª partição do 1º dispositivo SATA/SCSI;</li>
                                <li><b>/dev/sda2</b>: 2ª partição do 1º dispositivo SATA/SCSI, e assim por diante;</li>
                                <li><b>/dev/sdb1</b>: 1ª partição do 2º dispositivo SATA/SCSI;</li>
                                <li><b>/dev/sdb2</b>: 2ª partição do 2º dispositivo SATA/SCSI, e assim por diante;</li>
                                <li><b>/dev/xt1</b>: 1ª partição do 1º dispositivo MFM, e assim por diante;</li>
                                <li><b>/dev/sdd</b>: Cartões que seguem padrão SATA/SCSI;</li>
                            </ul>
                        </li>
                        <li><b>/dev/cdrom</b>: Dispositivos cdrom.</li>
                    </ul>

                    <h5>Arquivos em /boot:</h5>
                    <ul>
                        <li><b>/boot/config-versao-modelo</b>: Configurações do kernel, opções e módulos compilados juntos ao mesmo;</li>
                        <li><b>/boot/initrd.img-versao-modelo</b>: Imagem de disco RAM inicial, que carrega sistema de arquivos temporário em memória, para inicialização do sistema;</li>
                        <li><b>/boot/System-map-versao-modelo</b>: Mapas dos dispositivos dos discos. Gerencia memória antes do carregamento do kernel;</li>
                        <li><b>/boot/vmlinuz-versao-modelo</b>: Arquivo com informações da memória virtual para uso ao kernel, ao mesmo compactado com extração automática;</li>
                        <li><b>/boot/grub</b>: Diretório de configuração do inicializador GRUB.</li>
                    </ul>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Usuários</h4>
                <div class="card-body">
                    <h5>Tipos:</h5>
                    <ul>
                        <li><b>Usuário comum/padrão/regular</b> ($): (UID/GID 1000 à 60000, alguns iniciam em 500) é o padrão para utilização do GNU/Linux, possui restrições de gerenciamento sensíveis ao sistema, shell padrão (bash) e diretório home (/home);</li>
                        <li><b>Usuário de sistema</b>: (UID/GID 1 à 99, ou entre 500-1000) é fictício, criado durante a instalação de algum script, para execução de processos, não possuindo capacidade de login no sistema. Geralmente não possui shell (/sbin/nologin ou /bin/false), nem diretório home (caso possuir, geralmente não está vinculado a '/home');</li>
                        <li><b>Usuário de serviço</b>: (UID/GID 1000 à 60000 vinculado a conta de serviço) é fictício, similar ao de sistema (diferencia-se nos identificadores), criado para instalação e configuração de serviços no sistema;</li>
                        <li><b>Administrador</b> (root, #): (UID/GID 0), é o super user possui permissão total de gerenciamento do sistema. O root (<b>sudo</b>, super user do) é o único usuário com permissão de gerenciamento fora de seu diretório home, total ao sistema. Possui diretório home dedicado (/root).</li>
                    </ul>

                    <h5>Arquivos de usuário e grupo:</h5>
                    <p>Arquivo '/etc/passwd' possui informações dos usuários, separadas por ':'. Constituem, respectivamente, login do usuário, senha ('x', determinando que a senha está em '/etc/shadow', ou '*', determinando que o login está desabilitado, ou linha em branco ou '!', determinando ausência de senha), UID (user identification), GID (group identification), GComs (dados de comentários do usuário, separados por vírgula), localização home do usuário e shell do usuário. Arquivo '/etc/shadow' possui informações das senhas dos usuários. Constituem, respectivamente, login do usuário, senha criptografada, data da modificação de senha (nº de dias), nº de dias para GNU/Linux permitir nova modificação de senha, nº de dias que o usuário pode manter mesma senha, nº de dias para expirar senha, nº de dias após expiração de senha, nº de dias até expiração de senha e campo reservado para futura informação. '/etc/login.defs' é o arquivo padrão lido quando novo usuário é cadastrado no sistema. '/etc/skel' é o arquivo que contém informações que são copiadas para dentro de /home/novoUsuario quando novo usuário é cadastrado. Todo usuário possui grupo relacionado. Nativamente, quando usuário é criado, também é criado grupo com mesmo nome. '/etc/group' contém os grupos cadastrados no sistema, constituindo nomeGrupo:senhaGrupo:GID:usuario1,usuario2 (senha 'x' indica que está em '/etc/gshadow', arquivo que contém informações das senhas dos grupos no sistema). Assim como usuários, há também grupo de sistema, geralmente usados para execução de processos (flag '--system' indica cadastro de usuário ou grupo de sistema). '/etc/sudoers' controla quem pode usar comando <i>sudo</i> e como (diretório '/etc/sudoers.d' possui arquivos que suplementam configurações ao sudoers).</p>
<small><pre><code>
<u><b>Informações de usuários</b></u>:
<b>Username</b>: Nome do usuário
<b>Password Status</b>: P(senha utilizável), L(senha bloqueada), NP(não há senha)
<b>Change Date</b>: Data de última modificação de senha
<b>Minimum</b>: Nº mínimo de dias que deve passar para permitir alteração de senha
<b>Maximum</b>: Nª de dias restantes para senha expirar
<b>Warn</b>: Nº de dias, antes da expiração de senha, para notificar usuário
<b>Inactive</b>: Nº de dias, após expiração de senha, que usuário permanece ativo

<u><b>Comandos de usuários</b></u>:
<b>w</b>: Ver detalhes de usuários conectados
<b>whoami</b>: Ver usuário atual (ou 'who')
<b>quota</b>: Informações do usuário na sessão
<b>id nomeUsuario</b>: Verificar se usuário encontra-se no sistema
<b>getent passwd</b>: Abrir passwd
<b>Ver informações da senha de user</b>: chage -l nomeUsuario
<b>pwconv</b>: Criar arquivo '/etc/shadow' a partir de '/etc/passwd' <span class="text-muted">(pwunconv faz operação inversa)</span>
<b>sudo + comando</b>: Comando em modo administrador
<b>sudo su</b>: Set user, alternar usuário, padrão (nome omitido) é root
<b>sudo su -</b>: Alternar para usuário root, alternando todas definições do ambiente para root
<b>sudo su - nomeUsuario</b>: Alternar usuário, alternando todas definições do ambiente para novo usuário
<b>su - nomeUsuario</b>: Sair do usuário root, para usuário comum
<b>Alterar senha de usuário</b>: passwd [parâmetros] [utilizador] <spam class="text-muted">(passwd -S sysadmin)</spam>
<b>Alterar metadados de usuário</b>: chage -W 5 nomeUsuario (alterar nº dias de avisos antes de expirar senha)(em '/etc/shadow')
<b>Criar usuário</b>: adduser nomeUsuario ('/etc/adduser.conf'. Ou useradd, '/etc/default/useradd', useradd não atribui shell ao usuário)
<b>Criar usuário que não pode logar no shell</b>: adduser --shell /usr/sbin/nologin --home /usr/share/novoUser novoUser (ou '/bin/false'. Para users que usarão apenas arquivos compartilhados ou executar processo)
<b>Listar usuários</b>: cat /etc/passwd
<b>Deletar usuário</b>: deluser nomeUsuario (ou userdel)

<u>Grupos</u>:
<b>Adicionar grupo</b>: groupadd nomeGrupo (ou 'addgourp nomeGrupo')
<b>Adicionar grupo de sistema</b>: groupadd --system nomeGrupo
<b>Adicionar usuário em grupo</b>: gpasswd -a nomeUsuario nomeGrupo
<b>Adicionar usuário logado em grupo suplementar</b> (temporariamente): newgrp nomeGrupo
<b>Manipular informações de usuários e grupos</b>: usermod e groupmod
<b>Adicionar usuário em grupo</b>: usermod -aG nomeGrupo nomeUsuario (-a é append)
<b>Renomear grupo</b>: groupmod -n novoNomeGrupo antigoNomeGrupo
<b>Definir senha para grupo</b>: gpasswd nomeGrupo
<b>Deletar grupo</b>: delgroup nomeGrupo (ou groupdel)
<b>Listar grupos</b>: groups (ou 'groups nomeUsuario' para grupos do usuário)

<u>Exemplos</u>:
useradd -s /bin/bash -m -c "UB Social, 10, 519999999, 5198989898," ubsocial
'-s' define shell
'-m' define home
'-c' define campos de comentários (gecos)

chage -W 5 nomeUsuario
'-m' nº mínimo de dias entre troca de senhas
'-M' nº máximo de dias entre troca de senhas
'-E' data expiração de senha
'-e' forçar expiração de senha (passwd -e nomeUsuario)

<u>Exemplo, configuração de usuários em servidor</u>:
- Cadastrar grupos:
addgroup empresa
addgroup tecnologia
addgroup rh
addgroup comercial
addgroup financeiro
- Adicionar grupo ao diretório: chgrp empresa dir1/ (<span class="text-muted">Somente usuários do grupo 'empresa' poderão acessar diretório 'dir1/'</span>)
</small></pre></code>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Rede</h4>
                <div class="card-body">
                    <h5>Conceitos:</h5>
                    <ul>
                        <li><b>IP</b>: internet protocol (protocolo de rede), nº identificador único gerado, pelo servidor DHCP, para cada dispositivo ativo na mesma rede ativa (sintaxe: 'ip:porta');
                            <ul>
                                <li>IPv4:
                                    <ul>
                                        <li>IPs públicos (válidos na internet) e privados (inválidos na internet) diferentes;</li>
                                        <li>Possui Nat e classes de rede;</li>
                                        <li>Localhost: 127.0.0.1</li>
                                        <li>Exemplo: 192.0.2.146</li>
                                    </ul>
                                </li>
                                <li>IPv6:
                                    <ul>
                                        <li>IPs públicos e privados iguais;</li>
                                        <li>Não possui Nat e classes de rede;</li>
                                        <li>Localhost: ::1</li>
                                        <li>Exemplo: 2001:db8:3333:4444:5555:6666:7777:8888</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li><b>Host</b>: dispositivo conectado na rede. Todo host possui identificador (IP) e nome (hostname) na rede em que está conectado. Localhost é o dispositivo local na própria rede, com IP 127.0.0.1;</li>
                        <li>Protocolo <b>TCP</b>: transmission control protocol (protocolo de controle de transmissão), padrão de comunicação para entrega de dados e mensagens em rede, via IP (TCP/IP);</li>
                        <li>Protocolo <b>UDP</b>: user datagram protocol (protocolo de datagrama do usuário). O TCP é orientado à conexão e fornece comunicação confiável aos recursos, enquanto o UDP é de transporte em tempo real sem conexão, oferece comunicação mais rápida, mas com pouca confiabilidade;</li>
                        <li><b>MAC address</b>: media access control (endereço MAC) é número identificador única das placas físicas de rede do dispositivo;</li>
                        <li><b>VPN</b>: virtual private network (rede privada virtual), serviço que fornece "túnel" criptografado entre host-alvo (oculta IP à rede pública), para navegação protegida;</li>
                        <li><b>Proxy</b>: equipamento de rede que faz intermédio de comunicação entre cliente-servidor. Nesse contexto, IP da requisição deixa de ser o do cliente, tornando-se o do proxy. Uma VPN, além de mascarar tráfego de dados até o servidor, também criptografa esse tráfego (proxy não criptografa dados, portanto os mesmos ainda ficam visíveis);</li>
                        <li><b>Firewall</b>: dispositivo de rede (programa ou equipamento físico) com objetivo de aplicar políticas/regras (rules) de segurança aos pontos da rede, geralmente associados a redes TCP/IP;</li>
                        <li><b>AppArmor</b> (Application Armor): sistema de controle de acesso obrigatório (MAC - Mandatory Access Control) que fornece camada de segurança adicional no GNU/Linux, permitindo ao administrador criar regras e perfis de segurança específicos para arquivos e aplicações;</li>
                        <li><b>Active Directory</b> (AD): serviço de diretório da Microsoft para gerenciar recursos em rede, como computadores, usuários e grupos. No GNU/Linux, o Active Directory pode ser integrado para permitir que usuários autenticados no AD (via Windows ou GNU/Linux) possam acessar GNU/Linux usando suas credenciais do AD;</li>
                        <li><b>DHCP</b>: dynamic host configuration protocol (protocolo de configuração dinâmica de host), é protocolo TCP/IP que fornece configuração dinâmica de terminais, com concessão de IPs de hosts, máscara de sub-rede, default gateway (gateway padrão), IP de 1 ou mais servidores DNS, sufixos de pesquisa do DNS e número IP de um ou mais servidores WINS. Um servidor DHCP tem objetivo principal de prover IPs aos dispositivos ativos em sua rede;</li>
                        <li><b>Nameserver</b>: nome do dispositivo servidor na rede;</li>
                        <li><b>DNS</b>: domain name system (sistema de nomes de domínio) é sistema hierárquico e distribuído de gestão de nomes para dispositivos e serviços conectados à rede (pública ou privada). Exemplo: IP Amazon 192.0.2.44, DNS do IP da Amazon é www.amazon.com;</li>
                        <li><b>Gateway</b> (conversor de protocolo): pedaço de hardware (ex: roteador), que intermedia (interface) de conexões entre redes. Ou seja, ponto de entrada/saída que conecta 2 ou mais IPs, por meio de sequência numérica;</li>
                        <li><b>Broadcast</b>: endereço lógico onde todos dispositivos nas rede ficam habilitados a receber datagramas. Uma mensagem enviada ao endereço broadcast, será replicada a todos dispositivos conectados ao mesmo;</li>
                        <li><b>Unicast</b>: mesmo que broadcast, porém usado para único dispositivo;</li>
                        <li><b>Multicast</b>: mesmo que broadcast, porém usado para grupo específico de dispositivos;</li>
                        <li>Rede tipo <b>NAT</b>: network address translation - <b>masquerading</b> (tradução de endereço de rede) consiste em reescrever, via tabela hash, os IPs de origem de um pacote que passam por um router ou firewall de maneira que um dispositivo de rede interna tenha acesso ao exterior;</li>
                        <li>Rede tipo <b>bridge</b> (ponte): desativa o NAT no dispositivo, permitindo que o mesmo funcione como servidor DHCP, evitando conflito de IP;</li>
                        <li><b>Netmask</b>: máscara de rede e <b>subnet mask</b> (máscara de sub-rede), identificador (255.255.225.x/x) sob um IP para separar partes da rede em pública, sub-rede e hosts, onde o dispositivo roteador a utilizará para encaminhar pacotes de dados (datagramas) ao local correto. Sub-rede é divisão de rede. Cálculo de netmask (máscara e sub-rede) consiste em converter número binário no padrão acima, ou inverso. Comando 'ipcalc' (Ex: 'ipcalc 192.168.0.0/24') realiza cálculo automaticamente;<br><img src="calculo_netmask.png" class="img-fluid" width="450px"></li>
                        <li><b>Datagram</b>: datagrama é segmento de dados enviados por rede comutada por pacotes.</li>
                    </ul>

                    <h5>Arquivos:</h5>
                    <ul>
                        <li>'<i>/etc/hostname</i>' armazena o nome do dispositivo ($HOSTNAME);
                            <ul>
                                <li>Modificar hostname: <span class="text-muted">hostnamectl --set-hostname novoNome</span></li>
                                <li>Modificar hostname temporariamente: <span class="text-muted">hostname novoNome</span></li>
                            </ul>
                        </li>
                        <li>'<i>/etc/network/interfaces</i>' arquivo de configuração de IPs (Debian);
                            <ul>
                                <li>'auto' significa que placa será configurada automaticamente na inicialização do serviço;</li>
                                <li>'allow-hotplug' significa que placa será iniciada automaticamente no boot do dispositivo, mas dependerá de 'ifup' quando o serviço de rede for iniciado;</li>
                                <li>iface nomePlaca inet metodoAtribuicao
                                    <ul>
                                        <li>IP dinâmico: iface nomePlaca inet dhcp</li>
                                        <li>IP fixo:
<small><pre><code>
iface nomePlaca inet static
address 192.168.0.20/24
netmask 255.255.255.0
gateway 192.168.0.1

<b>Ex: Incluir placa virtual de rede em '/etc/network/interfaces'</b>
auto nomePlaca:0
iface nomePlaca:0 inet static
address 10.11..12.13
netmask 255.255.255.0
(<span class="text-muted">Sair do arquivo, reiniciar service (sudo systemctl restart networking) e verificar com 'ip a'</span>)
</code></pre></small>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>'<i>/etc/sysconfig/network-scripts/ifcfg-interfaceRede</i>' arquivo de configuração de IPs (Red Hat);</li>
                        <li>'<i>/etc/hosts</i>' possui tabela de hosts do dispositivo, seguindo sintaxe 'ip nomeHost.dominio nomeHost'. Esse arquivo é lido antes de acessos ao DNS;</li>
                        <li>'<i>/etc/resolv.conf</i>'realiza configuração de servidores de DNS para cliente Linux. Possui sintaxe:</li>
<small><pre><code>
search nomeHost.dominio
domain nomeHost.dominio
nameserver dnsPrimario
nameserver dnsSecundario
</code></pre></small>
                    </ul>
                    
                    <h5>Componentes:</h5>
                    <ul>
                        <li><b>eth</b> (eth0, eth1, eth2...): Ethernet, placa de rede cabeada do dispositivo;</li>
                        <li><b>wlo</b> (wlo0, wlo1, wlo2...), <b>wlan</b> (wlan0, wlan1, wlan2...): Wlo é wireless network interface (NIC). Wireless-LAN (Local Area Network), plca de wifi do dispositivo;</li>
                        <li><b>ra</b> (ra0, ra1, ra2...): Placa de rede com chipset Ralink;</li>
                        <li><b>lo</b>: Loopback, interface de rede virtual do dispositivo para conexões TCP/IP.</li>
                    </ul>

                    <h5>Comandos:</h5>
                    <p>Entre os comandos de rede, tem-se <b>route</b> (<span class="text-muted">route -n</span>) para visualizar e manipular tabela de roteamento IP (inet) e gateway. O <b>ifconfig</b> e <b>iwconfig</b> para informações dos componentes de rede do dispositivo, <b>ip a</b> (ou 'ip address show'), <b>ip r</b> (ou 'ip route show' ver tabela de rotas) e <b>nmcli</b> são similares a ambos. <b>ip addr show</b> mostra IP do dispositivo. <b>iwlist scan</b> mostra todas redes sem fio. <b>netstat</b> ou <b>ss</b> mostra todas conexões de entrada e saída de rede, tabelas de roteamento e estatísticas do protocolo de rede. '<i>netstat -atunp</i>' mostra com detalhes de PID, TCP e UDP. <b>ping</b> mostra tempo de envio/recebimento de resposta em rede (Ex: '<span class="text-muted">ping -c 4 192.168.1.2</span>' (Ping para esse IPv4 limitado em 4 iterações). Ex2: '<span class="text-muted">ping uol.com.br</span>' (Ping no site do uol)). <b>host</b> (<i>host -opcao idHost</i>, Ex: '<span class="text-muted">host www.google.com</span>') localiza informações de rede como, por exemplo, IPv4 (opção -4) ou IPv6 (opção -6) de determinado host (comando <b>dig</b> informa com mais detalhes). As portas de rede encontram-se em '/etc/services'. Entre os firewalls Linux, tem-se <b>iptables</b>, juntamente com <b>UFW</b> (Ubuntu firewall), que possui o GUFW como serviço GUI para gerenciamento, além do <b>firewalld</b>. MacAddress é o id da placa física, geralmente identificado como link/ether, HWaddr ou HW, seguindo padrão 'xx:xx:xx:xx:xx:xx' (Ex: <span class="text-muted">5c:cd:5b:74:ae:32</span>). O MacAddress da placa wifi do dispositivo geralmente encontra-se em wlan, identificado como 'HWaddr' ou 'ether'. Também pode ser encontrado com <b>inxi -Nn</b> na opção state 'up'. cURL (<b>curl</b>) oferece interface CLI para transferência de dados via protocolos de rede. <b>wget</b> é similar ao curl (Ex: '<span class="text-muted">wget http://ftp.gnu.org/pacote.tar.gz</span>'). <b>traceroute</b> mostra rota via rede até o destino (Ex: '<span class="text-muted">traceroute www.google.com</span>'). Comando <b>ssh</b> (secure shell) faz comunicação entre dispositivos via rede, com porta padrão 22. Por padrão no Debian, somente usuário comum pode conectar-se via SSH, para evitar telemetria. Passo a passo para acessar VM via SSH:</p>
                    <ol>
                        <u>Host</u>:
                        <li>Instalar SSH server: <span class="text-muted">sudo apt install openssh-server</span></li>
                        <li>Iniciar SSH: <span class="text-muted">systemctl start ssh</span> (status para verificar)</li>
                        <li>Verificar se porta 22 está aberta: <span class="text-muted">ss -atun | grep 22</span></li>
                        <u>VM</u>:
                        <li>Alterar configuração de rede da VM para modo Bridge
                            <ul>
                                <li>Selecionar modo Bridge</li>
                                <li>Selecionar placa de rede da máquina física que está conectada à internet (wireless é wlan, cabeada é eth)</li>
                            </ul>
                        </li>
                        <li>Instalar SSH client: <span class="text-muted">sudo apt install openssh-client</span></li>
                        <li>Reiniciar rede:
                            <ol>
                                <li><span class="text-muted">systemctl restart networking</span></li>
                                <li><span class="text-muted">ifdown nomePlacaFisica</span></li>
                                <li><span class="text-muted">ifup nomePlacaFisica</span></li>
                                <li><span class="text-muted">dhclient -v</span></li>
                            </ol>
                        </li>
                        <u>Host</u>:
                        <li>Conectar: <span class="text-muted">ssh -l nomeUsuarioVM ipVM</span></li>
                        <li>Informar 'yes' para aceitar key do server</li>
                    </ol>
                    <u>Permitir SSH via root</u>:
                    <ol>
                        <u>No client</u>:
                        <li>Na VM, abrir arquivo de configuração: <span class="text-muted">nano /etc/ssh/sshd_config</span></li>
                        <li>Nesse arquivo, descomentando a linha desejada, pode-se alterar as configurações ssh</li>
                        <li>Modificar linha PermitRootLogin para 'PermitRootLogin yes'</li>
                        <li>Reiniciar rede: <span class="text-muted">systemctl restart networking</span></li>
                        <u>No server</u>:
                        <li>Conectar: <span class="text-muted">ssh -l root ipVM</span></li>
                        <li>Se alterou porta: <span class="text-muted">ssh -l root piVM -p numPorta</span></li>
                    </ol>
                    <p>No caso acima, rede tipo <i>NAT</i> (Network address translation) é quando placa de rede da VM usa rede (IP) da máquina física para conexão. O tipo <i>Bridge</i> (Ponte) é quando VM conectada com cabo diretamente no modem, usando placa da máquina física somente como ponte para conexão.</p>
<small><pre><code>
SSH (secure shell):
<i>ssh -p numPorta usernameRemoto@ipRemoto</i> (-4 para somente IPv4, -6 para somente IPv6)
<b>Conexão SSH</b>: ssh -p 22 root@10.1.2.3 (porta 22(padrão), username 'root', ip '10.1.2.3')

Comando 'ss' (sockets services - alternativo ao netstat):
ss -atun | grep 22
-a: all
-t: tcp
-u: udp
-n: mostrar em formato numérico
LISTEN: SSH ouvindo na porta 22 (disponível)
</code></pre></small>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Terminais</h4>
                <div class="card-body">
                    <p>Emulador de terminal é o programa que emula um terminal, no Linux representado pelo shell. Terminais virtuais (<b>tty</b>, teletypes) suportam o ambiente do sistema. Para acessar a tty utiliza-se 'ctrl+alt+FnumTty' (Ex: '<span class="text-muted">ctrl+alt+F2</span>' acessará tty2), para alternar a tty utiliza-se 'alt+FnumTty'. Algumas tty's carregam GUI (geralmente tty1 e tty2), outras somente CLI (geralmente tty3 a 6). As tty's estão em '/dev/'.</p>

                    <h5>Sessões:</h5>
                    <p>Linux funciona sob sessão(ões) ativa(s). O login criará 1 sessão, composta por dados gerados do mesmo. Todo o log no sistema pertencerá a sessão ativa. Uma sessão possui usuário responsável, com seus respectivos arquivos, mensagens do sistema (logs), variáveis locais e histórico de comandos. Um mesmo usuário pode criar várias sessões ao mesmo tempo (cada shell executado e não fechado criará nova sessão, $SHLVL mostra o nível do shell). Toda vez que usuário comum executar '<span class="text-muted">sudo su</span>', criará nova sessão com root, e poderá encerrá-la com '<span class="text-muted">exit</span>', '<span class="text-muted">ctrl+d</span>' ou '<span class="text-muted">logout</span>' para retomar a sessão com usuário comum. Pode-se criar novas sessões via alternância de usuário, tty (com login) ou shell.</p>

                    <h5>Shell:</h5>
                    <p>Camada de acesso básico ao Linux, utilizada para execução de binários e super binários. Para executar shell, basta informar seu nome ou diretório (ex: '<span class="text-muted">/usr/bin/sh</span>'). Comandos para encerrá-lo são os mesmos de sessão acima. Arquivo '/etc/bash.bashrc' possui informações dos shells interativos. Entre os tipos de shell, tem-se:</p>
                    <ul>
                        <li>sh (Bourne shell)</li>
                        <li>bash (Bourne again shell, evolução do sh)</li>
                        <li>csh (C shell)</li>
                        <li>tcsh (Turbo C shell, evolução do csh)</li>
                        <li>ksh (Korn shell)</li>
                        <li>zsh (Z shell)</li>
                    </ul>

                    <h5>Variáveis:</h5>
                    <p>Espaços de memória que armazenam valores, com função de fornecer dados ao sistema. Comando <b>echo</b> faz chamada de conteúdo no shell em stdout (ex: '<span class="text-muted">echo "ola"</span>' mostrará "ola" na tela). Para listar todas variáveis, tem-se 'set' (locais), 'env' (globais) e 'printenv'. Arquivo '/etc/sysctl.conf' realiza definições de variáveis de sistema para o kernel.</p>
                    <ul>
                        <li><b>Variáveis locais</b>: Disponíveis somente para shell atual, são voláteis, possuindo visibilidade restrita ao ambiente onde foi definida. Sintaxe: <span class="text-danger">nome=valor</span>;</li>
                        <li><b>Variáveis globais</b> (de ambiente, environment): Não possuem restrição de ambiente, disponíveis a todo sistema. Comando 'export NOMEVARIAVEL', torna variável local em global. Sintaxe: <span class="text-danger">export NOME=valor</span>.</li>
                    </ul>
                    <ul>
                        <u>Variáveis globais</u>:
                        <li>HOME: Identifica o diretório do usuário;</li>
                        <li>HOSTTYPE: Identifica a plataforma do dispositivo;</li>
                        <li>HISTSIZE: Armazena limite de comando armazenados em histórico (histfile, padrão é 1000);</li>
                        <li>HISTFILE: Identifica local onde histórico de comandos é armazenado;</li>
                        <li>HISTFILESIZE: Armazena limite de linhas que o histórico (histfile) pode possuir (padrão é 2000);</li>
                        <li>SHELL: Identifica o shell atual;</li>
                        <li>TERM: Identifica o terminal atual;</li>
                        <li>USER: Identifica o usuário atual;</li>
                        <li>PATH: Identifica lista de diretórios dos binários executáveis shell (separados por ':');</li>
                        <li>PS1: Representa as informações exibidas no prompt (linha do shell para comando (prompt string), como '<span class="text-muted">usuario@nomeMaquina:~$</span>');</li>
                        <li>LOGNAME: Identifica nome do usuário logado atual;</li>
                        <li>OSTYPE: Identifica SO atual.</li>
                    </ul>
<small><pre><code>
<b>Exemplo</b>:
nome="ubsocial"
echo $nome <span class="text-muted">(toda vez que nome for chamada, representará seu valor: <i>ubsocial</i>)</span>
unset nome <span class="text-muted">(descarta variável)</span>
echo $HOME <span class="text-muted">(exibirá valor de HOME)</span>
</small></pre></code>

                    <h5>Alias:</h5>
                    <p>Apelido/atalho atrelado a determinada rotina. Comando 'alias' listará todos aliases do sistema.</p>
<small><pre><code>
<b>Exemplo</b>:
alias j="ls -l"
j <span class="text-muted">(ao digitar 'j' será executado seu valor: Comando 'ls -l')</span>
unalias j <span class="text-muted">(descarta alias)</span>
</code></pre></small>

                    <h5>Arquivos de variáveis:</h5>
                    <p>Para armazenar variável no Linux, precisa salvá-la no arquivo, caso contrário ela é removida da memória após finalizar sessão.</p>
                    <ol>
                        <u>Escopo global</u> (/etc):
                        <li><i>/etc/profile</i>: Armazena comandos e variáveis para usuários do sistema;</li>
                        <li><i>/etc/environment</i>: Usado para definir variáveis globais;</li>
                        <u>Escopo local</u> (/home):
                        <li><i>/home/.bashrc</i>: Script de inicialização do bash para shells sem login;</li>
                        <li><i>/home/.profile</i> ou <i>/home/._profile</i>: Script de inicialização do bash para shells com login;</li>
                        <li><i>/home/.bash_login</i> e <i>/home/.bash_logout</i>: Possui binários que são executados no login/logout do shell.</li>
                        Comando 'source' reseta o arquivo (Ex: '<span class="text-muted">source /etc/profile</span>').
                    </ol>

                    <h5>Arquivos de exibição de mensagens:</h5>
                    <ul>
                        Responsáveis por armazenar mensagens padrão stderr.
                        <li><i>/etc/issue</i>: Mensagens antes do login do sistema;</li>
                        <li><i>/etc/motd</i>: Mensagens após login do sistema;</li>
                        <li><i>/etc/issue.net</i>: Mensagens via rede, logins remotos;</li>
                        <li><i>~/.bash_history</i>: Histórico dos comandos.</li>
                    </ul>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Shell</h4>
                <div class="card-body">
                    <p>Camada de comunicação entre binários e kernel. As sintaxes do resumo possuem '&lt;&gt;' para termo que deve ser informado obrigatoriamente, e '[]' para termo que pode ser informado opcionalmente. Nessas sintaxes, todo termo fora de símbolos (parênteses, colchetes, chaves) deve ser informado obrigatoriamente. Comandos shell são case sensitive, onde caracteres maiúsculos diferenciam-se de minúsculos. Comando binário interpretado pelo shell possui composição:</p>
                    <ol>
                        <li><b>comando</b>: arquivo binário em '/usr/bin' ou '/usr/sbin';</li>
                        <li><b>parâmetro(s)</b>: opcional, altera comportamento do comando. Também chamado de 'flag' e 'opção'. Representado por 1 hífen seguido de letra (forma simplificada, padrão POSIX), ou 2 hífens seguidos de palavra (forma extensa, arquitetura GNU e UNIX). Na forma simplificada, pode-se conter vários parâmetros aninhados, onde tem-se 1 hífen seguido das letras dos respectivos parâmetros;</li>
                        <li><b>argumento(s)</b>: opcional, especifica alvo do comando. Representado por palavra(s) ou expressão(ões).</li>
                    </ol>
                    Parâmetro modifica execução do comando para determinado argumento.
                    <p>Sintaxe 1: <span class="text-danger">comando [-p] [argumento]</span><br>Sintaxe 2: <span class="text-danger">comando [--parametro] [argumento]</span></p>
                    
                    <u>Exemplos</u>:
                    <p><span class="text-muted">ls</span><br><span class="text-muted">ls /home</span><br><span class="text-muted">ls -s /home</span><br><span class="text-muted">ls -s -a /home</span><br><span class="text-muted">ls -sa /home</span><br><span class="text-muted">ls --size /home</span><br><span class="text-muted">ls --size --all /home</span></p>

                    <h5>Atalhos shell</h5>
                    <ul>
                        <li><b>tab</b>: Autocompletar comando;</li>
                        <li><b>seta up</b>: Comando anterior;</li>
                        <li><b>seta down</b>: Mostrar comando sucessor ao anterior;</li>
                        <li><b>^c</b>: Quer dizer <i>ctrl+c</i>;</li>
                        <li><b>M-c</b>: Quer dizer <i>alt+c</i>;</li>
                        <li><b>ctrl+shift+c</b>: Copiar;</li>
                        <li><b>ctrl+shift+v</b>: Colar;</li>
                        <li><b>shift+pgup</b>: Scroll acima;</li>
                        <li><b>shift+pgdn</b>: Scroll abaixo;</li>
                        <li><b>ctrl+a</b>: Mover cursor ao começo da linha;</li>
                        <li><b>ctrl+e</b>: Mover cursor ao final da linha;</li>
                        <li><b>ctrl+u</b>: Recortar tudo à esquerda do cursor;</li>
                        <li><b>ctrl+k</b>: Recortar tudo à direita do cursor;</li>
                        <li><b>ctrl+y</b>: Colar conteúdo recortado;</li>
                        <li><b>alt+b</b>: Voltar 1 palavra;</li>
                        <li><b>ctrl+w</b>: Deletar 1 palavra;</li>
                        <li><b>ctrl+p</b>: Comando anterior;</li>
                        <li><b>ctrl+n</b>: Próximo comando;</li>
                        <li><b>ctrl+c</b>: Abrir nova linha a partir do cursor (cancelar operação em andamento);</li>
                        <li><b>q</b>: Geralmente sair (quit) de comando interativo;</li>
                        <li><b>ctrl+d</b>: Sair;</li>
                        <li><b>ctrl+z</b>: Pausar comando em andamento;</li>
                        <li><b>alt+f</b>: Mover 1 palavra;</li>
                        <li><b>alt+d</b>: Deletar 1 palavra;</li>
                        <li><b>ctrl+r</b>: Iniciar/Próxima pesquisa;</li>
                        <li><b>ctrl+g</b>: Cancelar pesquisa;</li>
                        <li><b>ctrl+x</b> ou <b>ctrl+e</b>: Editar;</li>
                        <li><b>ctrl+l</b>: Limpar shell (move cursor para baixo até ocultar conteúdo anterior);</li>
                        <li><b>ctrl+-</b>: Desfazer;</li>
                        <li><b>!!</b>: Repetir último comando.</li>
                    </ul>

                    <h5>Comandos gerais:</h5>
<small><pre><code>
<b>Ver shell padrão</b>: echo $SHELL (ou 'echo $0')
<b>Data e hora do sistema</b>: date
<b>Fechar o bash</b>: exit
<b>Limpar bash</b>: clear
<b>Ajuda no bash</b>: help
<b>Comentário no Bash</b>: #comentario (Comentários não afetam execuções no shell)
<b>Concatenar comandos</b> (; ou &&): ls ; echo "a" (ou ls && echo "a")

<b>Histórico de comandos</b>: history
<b>Histórico dos 10 últimos comandos</b>: history 10 (ou fc -l 10)
<b>Histórico dos comandos 2 ao 6</b>: fc -l 2 6
<b>Histórico dos comandos na última hora</b>: fc -l h
<b>Executar 34º comando do histórico</b>: !34

<b>Ver informações de hardware</b>: lshw
<b>Ver informações sobre processador</b>: lscpu (mesmo que '/proc/cpuinfo')
<b>Ver informações da distro</b> (necessário instalar): neofetch
<b>Ver versão da distro</b>: lsb_release -a (ou cat /etc/*-release)
<b>Ver versão do kernel</b>: uname -r
<b>Ver detalhes do kernel</b>: uname -a
<b>Ver informações de memória cache em tempo real</b>: sudo slabtop (ctrl+c para sair)
<b>Ver informações de tempos em tempos</b>: watch –n 5 date (mostrará date a cada 5seg)
<b>Ver nome do dispositivo</b>: hostname ('-i' mostrará ip)
<b>Ver arquitetura do dispositivo</b>: arch
<b>Ver particionamento do disco</b>: lsblk (dispositivos de bloco disponíveis)
<b>Ver espaços das partições</b>: df ('-h' para mostrar valores organizados, '-i' para mostrar inodes, buracos de memória no hardware de cada partição)
<b>Ver informações sobre uso do disco</b>: du (du -sh *)
<b>Ver mensagens do sistema</b>: sudo dmesg (mesmo que '/var/log/dmesg')
<b>Ver quantidade de memória livre</b>: free ('-m' para valores em Megabytes, '-h' para valores organizados. Comando analisa '/proc/meminfo')
<b>Verificar e reparar sistema de arquivos</b>: fsck (ou 'fsck nomeDisco'. Comando 'mkfs' é similar. 'mkswap' para disco swap)
<b>Gerenciar partições do dispositivo</b>: fdisk ('-l' listará, Ex: 'fdisk -l /dev/sda')
<b>Ver módulos kernel carregados em memória</b>: lsmod
<b>Ver arquivos abertos</b>: lsof
<b>Ver dispositivos pci</b>: lspci
<b>Ver dispositivos scsi</b>: lsscsi
<b>Ver dispositivos usb</b>: lsusb
<b>Ver se comando é interno/externo</b>: type comando ('type ls', comando interno é 'shell builtin')
<b>Subshell (comando dentro de comando)</b>: ls $(which docker)
<b>Gravar shell</b>: script arquivoGravacao (Todos comandos/saídas no shell serão gravados no arquivoGravacao até ser informado 'exit' no shell)
<b>Filme Star Wars ep4</b>: telnet towel.blinkenlights.nl
<b>Animação no shell</b>: hollywood (Necessário instalação, 'sudo apt install hollywood')
<b>Funcionalidades extras ao shell, como divisão em abas</b>: tmux (Necessário instalação, 'sudo apt install tmux')
<b>Ranger, file manager CLI:</b> ranger (Necessário instalação)

<b>Desligar</b>: shutdown now (ou poweroff, ou init 0, ou shutdown 0)
<b>Logout</b>: logout
<b>Reiniciar</b>: reboot (ou shutdown -r, ou init 6)
</code></pre></small>

                    <h5>Create:</h5>
<small><pre><code>
<b>Criar diretório</b> (make directory): mkdir diretorio1 diretorio2 diretorio3
<b>Criar diretório com subdiretório</b>: mkdir -p diretorio1/diretorio2/diretorio\ 3/ ('\' não interpreta próximo caractere como comando ("diretorio 3"). '-p' não sobrescreve, caso diretório já exista)
<b>Criar arquivo</b>: touch nomearquivo (ou 'touch arquivo\ de\ teste' para criar "arquivo de teste")
</code></pre></small>

                    <h5>Remove:</h5>
<small><pre><code>
<b>Remover arquivo</b>: rm arquivo
<b>Remover diretório vazio</b>: rmdir diretorio
<b>Remover diretório não vazio</b> (recursive): rm -r diretorio (-f para remoção forçada)
<b>Remover sob confirmação</b> (interactive): rm -i arquivo
</code></pre></small>

                    <h5>List:</h5>
<small><pre><code>
<b>Listar conteúdo do diretório atual</b>: ls
<b>Listar conteúdo em diretório específico</b>: ls nomeDiretorio
<b>Listar diretório e subdiretórios</b>: ls -R (recursivamente)
<b>Listagem com detalhes</b>: ls -l
<b>Listagem com informações aprimoradas de armazenamento</b>: ls -l -h
<b>Listagem incluindo arquivos ocultos</b>: ls -a
<b>Listar diretório e subdiretórios, recursivamente</b>: ls -lR
<b>Listagem com informações de armazenamento, arquivos ocultos e subdiretórios</b>: ls -Rlah
<b>Ver diretórios árvore FHS</b>: tree ('tree -L 1 /' nível 1, somente 1 diretório. 2 para diretório e subdiretórios)
<b>Ver metadados de arquivo</b> (via inodes): stat nomeArquivo
<b>Ver formato de arquivo</b>: file nomeArquivo
<b>Ver conteúdo de arquivo</b>: cat nomeArquivo ('tac' mostra inversamente)
<b>Ver contagens de arquivo</b>: wc nomeArquivo (nº de linhas, palavra e bytes, respectivamente)
<b>Ver início de conteúdo de arquivo</b>: head nomeArquivo ('tail' mostra o final)
<b>Ver conteúdo de arquivo, com paginação</b>: less /etc/services ou 'ls | more' (Less: 'n' pula pra próxima página, '/termo' procura por termo específico, 'more' é o inverso de less)
<b>Inserir conteúdo de arquivo em outro arquivo</b>: cat arquivo &gt; arquivoGravacao
<b>Inserir conteúdo de arquivo no final de outro arquivo</b>: cat arquivo &gt;&gt; arquivoGravacao

<b>Conteúdo do 'ls -l'</b> (long listing format):
<span class="text-danger">[tipoArquivo] [permissões(proprietário/grupo/outros)] [contagem linksFisicos] [proprietárioDoUsuario] [proprietárioDoGrupo] [tamanhoArquivoBouKB] [dthrRegistro] [nomeArquivo.extensao]</span>
Exemplo (arquivo): <span class="text-muted">-rw-r--r-- 1 root root 18047 Dec 20 2021 alternatives.log</span>
Exemplo (diretório): <span class="text-muted">drwxr-x--- 2 root adm 4096 Dec 20 2021 apache2</span>

<b>d</b>: Diretório
<b>-</b>: Arquivo regular (Indica que é arquivo, não sendo diretório)
<b>l</b>: Link simbólico (Aponta para outro arquivo, 'soft link'. Links físicos, não simbólicos, são entrada adicional no sistema de arquivos que aponta para mesmo local (inode) do disco. Comando 'ls -i' mostra inodes)
<b>s</b>: Arquivo é um socket (Comunicação entre processos)
<b>p</b>: Arquivo é um fifo, named pipe (Comunicação entre processos. Fifo- FistIn FirstOut, muito usado para filas de elementos em lista de espera)
<b>b</b>: Arquivo é dispositivo de bloco (Comunicação com hardware, com buffer: região temporária de memória para escrita/leitura)
<b>c</b>: Arquivo é dispositivo de caractere (Comunicação com hardware, sem buffer)
<b>u</b>: O mesmo que <i>c</i>
</code></pre></small>

                    <h5>Print:</h5>
<small><pre><code>
<b>Impressão simples</b> (line printer): lp arquivo.txt
<b>Impressão avançada</b>: lp -d nomeOuIdImpressora -n 2 -P 1,3 Documents/arquivo (2 cópias, páginas 1 e 3)
<b>Detalhes da impressora</b>: lpstat -p -d
<b>Ver fila de impressão</b>: lpq
</code></pre></small>

                    <h5>Change directory:</h5>
<small><pre><code>
<b>Entrar em outro diretório</b>: cd nomeDiretorio (Exemplo: 'cd /home/usuario/Documents')
<b>Voltar 1 diretório (diretório pai)</b>: cd ..
<b>Voltar 2 diretórios</b>: cd ../../ (e assim por diante)
<b>Entrar no diretório do usuário</b>: cd (ou cd ~)
<b>Entrar no diretório root</b>: cd /
<b>Criar links</b>: ln -s arqOrigem /home/arqLinkSimbolico (ou somente 'ln' para criar link físico - hard link)
<b>Listar links simbólicos</b>: ln -lh
</code></pre></small>

                    <h5>Copy e move:</h5>
<small><pre><code>
<b>Copiar e colar arquivo</b>: cp arquivo diretorioDestino
<b>Copiar e colar recursivamente</b>: cp -r dirOrigem dirDestino (-p mantém metadados, 'preserve')
<b>Copiar e colar, renomeando</b>: cp arquivo dirDestino/novoNomeArquivo
<b>Mover</b>: mv arquivo diretorioDestino (o mesmo vale para diretórios)
<b>Renomear</b>: mv arquivoAtual arquivoNovo (o mesmo vale para diretórios)
<b>Comparar arquivos</b>: diff arquivo1 arquivo2 ('-r' recursivo, '-i' ignora CamelCase, '-a' compara qualquer tipo de arquivo. 'cmp' é comando similar)
<b>Sincronizar arquivos</b>: rsync arqOriginal arqDuplicado ('-r' recursivo, '-v' verbose, '-a' mantém todos metadados)

<b>Copiar e colar</b> (bit a bit): dd if=/dev/arquivo1 of=/tmp/arquivo2 bs=1M count=50
if: arquivo de entrada, a ser lido
of: arquivo de saída, a ser gravado
bs: tamanho do bloco (Kilobyte, Megabyte, Gigabyte, Terabyte, etc.)
count: contagem de blocos a serem lidos da entrada
</code></pre></small>

                    <h5>Regular expressions:</h5>
                    <p>Também conhecidos por globbing (file globbing), são caracteres regex utilizados em conjunto.</p>
<small><pre><code>
<u><b>Metacaracteres</b> (representação)</u>:
<b>.</b> Qualquer caractere único
<b>*</b> Conjunto de caracteres
<b>?</b> Apenas 1 caractere
<b>[ ]</b> Intervalo de caracteres
<b>[a-z][0-9]</b> Caracteres de 'a' até 'z', caracteres de '0' até '9'
<b>[a,z][0,9]</b> Caracteres 'a' e 'z', caracteres '0' e '9'
<b>[a-z,1,0]</b> Caracteres de 'a' até 'z' ou '1' ou '0'
<b>[^ ]</b> Faixa de caracteres ausentes
<b>{ }</b> Padrões de caracteres
<b>x{ab,01}</b> Caracteres 'xab' ou 'x01'
<b>x{a-c,f}</b> Caracteres 'xa', 'xb', 'xc' ou 'xf'
<b>^</b> Se o 1º caractere do padrão, o padrão deve estar no início da linha
<b>$</b> Se o último caractere do padrão, o padrão deve estar no final da linha
<b>+</b> 1 ou mais do padrão anterior
<b>|</b> Alternativa ao <b>-</b> um 'ou' lógico
<b>( )</b> Agrupamento
<b>!</b> Excluir caractere da operação
<b>\b</b> Borda de uma palavra
<b>\n</b> Recuperar n agrupamento (n é um nº)
<b>\</b> Acessar caracteres especiais e metacaracteres (também considerado caractere de escape)

<u><b>Classificação</b></u>:
<b>Marcação</b> (âncoras): ^ $ \b
<b>Quantificadores</b>: . ? * + {n[,m]} [...] [^...]
<b>Agrupamento</b>: () \n
<b>Outros</b>: \

<u><b>Exemplos</b></u>:
<b>Criar arquivos</b>: touch arq{1-3}.txt (gerará 'arq1.txt', 'arq2.txt' e 'arq3.txt')
<b>Listar tudo que começa com 'x'</b>: ls /etc/x*
<b>Listar tudo que tem 'x' no meio</b>: ls /etc/*x*
<b>Listar tudo que termina com '.conf'</b>: ls /etc/*.conf
<b>Listar tudo que termina com, ou 'tab' ou 'swd'</b>: ls /etc/*{tab,swd}
<b>Listar tudo que tem 2º caractere 'a', 3º 's', e depois qualquer coisa</b>: ls /etc/?as*
<b>Listar tudo que tem 'a' na 4ª posição, depois qualquer coisa</b>: ls /etc/???a*
<b>Listar tudo que começa com 'f', seguido de caractere na faixa entre 'a' e 'i', depois qualquer coisa</b>: ls /etc/f[a-i]*
<b>Listar tudo que começa com 'f', seguido de caractere 'a' ou 'c', depois qualquer coisa</b>: ls /etc/f[a,c]*
<b>Listar tudo que começa com 'f', seguido de caractere entre 'a' até c, ou 'e', depois qualquer coisa</b>: ls /etc/f[a-c,e]*
<b>Listar tudo que tenha no meio caracteres de 'a' até 'c', depois qualquer coisa</b>: ls /etc/*[a-c]*
<b>Listar tudo que, por 2º, listar ou 'am' ou 'ul', depois qualquer coisa</b>: ls /etc/?{am,ul}*
<b>Listar tudo que, por 2º, listar sequência do 'a' até 'm' ou do 'u' até 'l', depois qualquer coisa</b>: ls /etc/?[am,ul]*
<b>Procurar em 'arquivo.txt' termos que terminam com 'teste'</b>: grep '$teste' arquivo.txt (-i ignora case sensitive, -r recursivo)
<b>Codificar arquivo</b>: gpg -c arq1 ('gpg arq1.gpg' para decodificar)
</code></pre></small>

                    <h5>Permissões:</h5>
                    <p>No GNU/Linux, nenhum arquivo externo tem permissão de execução nativamente. Precisa-se aplicá-la com comandos <b>chown</b>, <b>chgrp</b>, <b>chmod</b> e <b>chattr</b>:</p>
                    <p>Change owner: <span class="text-danger">chown &lt;parâmetros&gt; &lt;novoDono&gt;[:novoGrupo] &lt;arquivo(s)&gt;</span><br>Change group: <span class="text-danger">chgrp &lt;parâmetros&gt; &lt;novoGrupo&gt; &lt;arquivo(s)&gt;</span><br>Change mode: <span class="text-danger">chmod &lt;[conjunto][ação][permissões]&gt;[,[conjunto][ação][permissões]] [parâmetros] &lt;arquivo(s)&gt;</span><br>Change attribute: <span class="text-danger">chattr &lt;[ação][parâmetros]&gt; &lt;arquivo(s)&gt;</span></p>
                    Ordenamento (ls -l):
                    <ol>
                        <span class="text-muted">-rw-r--r-- 1 sysadmin sysadmin 647 Dec 20 2017 hello.sh</span>
                        <li>(-): Indica arquivo;</li>
                        <li>(rw-) <b>Proprietário</b>, no caso o primeiro sysadmin;</li>
                        <li>(r--) <b>Grupo</b>, no caso o segundo sysadmin;</li>
                        <li>(r--) <b>Outros</b>, no caso outros usuários não proprietários do arquivo;</li>
                        <li>(1) Quantidade de subdiretórios;</li>
                        <li>(647) Tamanho do diretório;</li>
                        <li>(Dec 20 2017) Data de criação/modificação;</li>
                        <li>(hello.sh) Nome do arquivo/diretório.</li>
                    </ol>
                    Conjunto:
                    <ul>
                        <li>(<b>u</b>) User/Usuário proprietário do arquivo;</li>
                        <li>(<b>g</b>) Group/Grupo proprietário do arquivo;</li>
                        <li>(<b>o</b>) Other/Outros (qualquer usuário que não seja o proprietário do usuário ou membro do proprietário do grupo);</li>
                        <li>(<b>a</b>) All/Todos (refere-se ao usuário, grupo e outros)</li>
                    </ul>
                    Classificação:
                    <ul>
                        <li>Simbólico (literal): Alterar conjunto de permissões de cada vez, respectivamente 'rwx';
                            <ul>
                                <li>(<b>r</b>): Read (leitura);</li>
                                <li>(<b>w</b>): Write (escrita);</li>
                                <li>(<b>x</b>): Execution (execução);</li>
                                <li>(<b>-</b>): Não possui permissão.</li>
                            </ul>
                        </li>
                        <li>Octal (numérico): Alterar todos conjuntos de permissões (usuário, grupo e outros).
                            <ul>
                                <li>(<b>0</b>) Nenhuma permissão (-);</li>
                                <li>(<b>1</b>) Execução (x);</li>
                                <li>(<b>2</b>) Escrita (w);</li>
                                <li>(<b>3</b>) Escrita e execução (wx);</li>
                                <li>(<b>4</b>) Leitura (r);</li>
                                <li>(<b>5</b>) Leitura e execução (rx);</li>
                                <li>(<b>6</b>) Leitura e escrita (rw);</li>
                                <li>(<b>7</b>) Leitura, escrita e execução (rwx).</li>
                            </ul>
                        </li>
                    </ul>
                    Ação:
                    <ul>
                        <li>(<b>+</b>) Adicionar permissão;</li>
                        <li>(<b>=</b>) Especificar permissão;</li>
                        <li>(<b>-</b>) Remover permissão.</li>
                    </ul>
<small><pre><code>
<u>Exemplos</u>:
chown novoUser arq1 (alterar usuário proprietário do arquivo 'arq1' para 'novoUser')
chgrp novoGrupo arq1 (alterar grupo proprietário do arquivo 'arq1' para 'novoGrupo')
chown novoUser:novoGrupo arq1 (alterar usuário e grupo proprietário do 'arq1')

chmod u-rwx arq1 (usuário sem permissões)
chmod g+w arq1 (grupo com permissão de escrita)
chmod o=w (outros somente com permissão de escrita)
chmod a+x arq1 (all, user/group/others, com permissão de execução)
chmod ugo=rwx arq1 (permissão total para user/group/others)
chmod uo=,g=rx arq1 (usuário e outros sem permissões, grupo com leitura e execução)
chmod u+rw,g-rw,o=rx (ou 'o-w+rx') arq1 (usuário adiciona leitura e escrita, grupo remove leitura e escrita, outros com leitura e execução)
chmod -Rv a=rwx dir1/ (permissão total e recursiva para todos, no diretório 'dir1'. -v para verbose)

chmod 764 arquivo (proprietário(7) com leitura/escrita/execução, grupo(6) com leitura/escrita, outros(4) com somente leitura)
chmod 40 arquivo (proprietário não foi modificada, grupo(4) somente leitura, outros(0) nenhuma)

<u>Permissões especiais</u>:
chmod 1755 dir1/ (o '1' representa permissão sticky bit, ou restricted deletion flag, representada com '-t' no final do arquivo ao 'ls'. Somente para diretórios. Impede que usuários não proprietários de deletar ou renomear arquivos no diretório. Diretórios geralmente representados com fundo azul)
chmod 2755 arq1 (ou 'g+s' em simbólico ou '2' octal. Permissão SGID ou bit set group id, concede permissão aos privilégios do grupo proprietário, incluindo respectivos arquivos, se diretório. Representa 's' no lugar do 'x' nas permissões do grupo. Geralmente representados por fundo amarelo)
chmod 6755 arq1 ('4' octal, incluindo SGID. SUID ou set user id, representa um 's' no lugar do 'x' nas permissões do usuário. Aplicado a arquivos regulares. Semelhante ao SGID, mas aplicado ao usuário proprietário. Geralmente representados com fundo vermelho)

chattr +a arq1 (permite gravar apenas abrindo arquivo acrescentar modo)
chattr +c arq1 (permite que arquivo seja compactado/descompactado automaticamente)
chattr +d arq1 (garante que programa ignore excluir arquivos durante o backup)
chattr +i arq1 (torna o arquivo inalterado, não podendo ser excluído, alterado, renomeado ou vinculado)
chattr +s arq1 (permite que arquivo possa ser excluído com segurança)
chattr +S arq1 (garante que arquivo é modificado, as alterações são gravadas no modo síncrono)
chattr +u arq1 (permite recuperar conteúdo de arquivo, mesmo se está cancelado)
lsattr (listar atributos especiais, pode ser utilizado com parâmetros de 'ls')
lsattr arq1 (listar atributos especiais do arquivo)
</code></pre></small>

                    <h5>Lançador:</h5>
                    <p>Atalho (launcher) de binário no desktop environment, em arquivo '.desktop'. Lançadores globais (disponíveis para todos usuários) ficam em '/usr/share/applications', lançadores locais (disponíveis somente para usuário da sessão) ficam em '~/.local/share/applications'.</p>
<small><pre><code>
<b>Conteúdo de arquivo do lançador</b>:
[Desktop Entry]
Type=Application
Version=1.0
Name=Nome do binário
Comment=Descrição do binário
Icon=Diretório do ícone do binário
Exec=Diretório do executável do binário
Terminal=Abrir shell (true ou false)
StartupNotify=Notificação quando executado (true ou false)
Categories=Categoria do binário
</code></pre></small>
                    Categorias:
                    <ul>
                        <li>Configurações: Settings;</li>
                        <li>Desenvolvimento: Development; Documentation;</li>
                        <li>Educação: Education;</li>
                        <li>Ciência: Science;</li>
                        <li>Escritório: Office;</li>
                        <li>Gráficos: Graphics</li>
                        <li>Rede: Network;</li>
                        <li>Jogos: Game;</li>
                        <li>Multimídia: AudioVideo;Audio;Video;AudioVideoEditing;</li>
                        <li>Sistema: System;</li>
                        <li>Utilitários: Utility.</li>
                    </ul>

                    <h5>Processos:</h5>
                    <p>Processos são chamados de process, task, service ou job. Enquanto uma tarefa (<b>task</b>) é um conjunto de instruções em execução, um processo (<b>process</b>) é um conjunto de instruções ou programas em execução, geralmente iniciado pelo usuário. No GNU/Linux, task e process são sinônimos. Um serviço (<b>service</b>) é um processo iniciado pelo sistema. Um trabalho (<b>job</b>) são muitas tasks/process em execução, geralmente em lote. No GNU/Linux, o gerenciamento de processos segue padrão POSIX. Processo é um binário que, quando executado, consome recursos do dispositivo. Possui ciclo de vida/estado (stat, state ou s), time (tempo usado pelo processador no processo), CMD (command - binário que iniciou o processo), recursos (resources) e usuário (user) proprietário. Todo processo é identificado pelo <b>PID</b> (process identification) e, em alguns casos, <b>PPID</b> (parent process identification), com prioridade de execução (nice), do -20 (máxima) ao 19 (mínima) e 0 (padrão). O root possui permissão para alterar prioridades. Processos criados pelo root têm prioridade 0. Processos criados por usuário comum têm prioridade 10 (baixa). Processos em realtime (normalmente internos do kernel) possuem prioridade 1 a 99. Processos convencionais possuem têm prioridade 100 (maior) até 139 (menor), sendo 120 (padrão) e rt (realtime). A prioridade padrão (PRI/PR), diferente da nice (NI), é definida automaticamente no escalonamento definido pelo kernel. Processos em execução possuem seus diretórios em '/proc', nomeados por PID. Processos podem ser inicializados pelos gerenciadores <i>systemctl</i> e <i>systemd</i>. Comando 'top' mostra lista de processos. No 'top', load average é a média de tempo para execução de cada processo (geralmente deve-se manter abaixo de 3). A gestão do processo ocorre via sinais (signal) de kill (comando 'kill -l' mostra todos sinais de kill). Processos em 1º plano são foreground (binários executados em shell), processos em 2º plano são background. Toda vez que um processo é executado em background, estará executando em subshell. Arquivo '/proc/cmdline' armazena strings do kernel na inicialização.</p>
                    Componentes do processo:
                    <ul>
                        <li>Estado (stat, state, s);
                            <ul>
                                <li>(<b>R</b>) running ou runnable (em execução, consome recursos);</li>
                                <li>(<b>T</b>) stopped (parado por processo, não consome recursos);</li>
                                <li>(<b>t</b>) stopped (parado por execução de debugger, não consome recursos);</li>
                                <li>(<b>D</b>) uninterruptible sleep/sleeping (hibernando ou com dificuldades de retornar à execução, não consome recursos. Geralmente processo IO);</li>
                                <li>(<b>S</b>) interruptible sleep/sleeping (hibernando ou com dificuldades de retornar à execução, não consome recursos, pode ser interrompido);</li>
                                <li>(<b>Z</b>) defunct ou zoombie (travado, não executa funções, consome recursos);</li>
                                <li>(<b>X</b>) dead ou finish (finalizado, não consome recursos);</li>
                                <li>(<b>W</b>) paging (não válido pelo kernel 2.6.xx ou superior. Não consome recursos);</li>
                                <li>(<b>I</b>) idle (ocioso, não consome recursos).</li>
                            </ul>
                        </li>
                        <li>Recursos (resources): Recursos de hardware ou sistema (libraries);
                            <ul>
                                <li>(<b>VSZ</b> ou <b>VIRT</b>) virutal size (tamanho virtual);</li>
                                <li>(<b>RSS</b> ou <b>RES</b>) resident set size (memória utilizada);</li>
                                <li>(<b>SHR</b>) share (memória compartilhada);</li>
                                <li>(<b>tty ?</b>) processo daemon (execução independente de tty);</li>
                                <li>(stat <b>l</b> ou <b>L</b>) processo com recurso bloqueado (locked) na memória.</li>
                            </ul>
                        </li>
                        <li>Proprietário (user): Usuário que gerou o processo, com permissão para modificá-lo. Usuário comum é proprietário somente de seus processos. root é proprietário de todos processos;</li>
                        <li>Prioridade (priority): Quantidade disponibilizada de recursos fornecidos;
                            <ul>
                                <li>(stat <b>&lt;</b> ou <b>N</b>) prioridade menor que normal (low-priority);</li>
                                <li>(stat <b>&gt;</b>) prioridade maior que normal (high-priority);</li>
                                <li>(stat <b>s</b>) líder da sessão (session);</li>
                                <li>(stat <b>+</b>) executando em 1º plano (foreground);</li>
                                <li>(stat <b>L</b>) partes bloqueadas (locked) na memória (por realtime ou IO);</li>
                                <li>(stat <b>I</b>) multi-threaded (thread's compartilhadas. Fluxos de controle, compartilhados entre processos, atuando em mesmo endereço, num mesmo processo);</li>
                                <li>(<b>NI</b>) nice/renice, valor de prioridade definido na criação/alteração do processo;</li>
                            </ul>
                        </li>
                        <li>PID, PPID: Identificadores do processo.</li>
                    </ul>
<small><pre><code>
<b>Ver processos da sessão, tty e usuário atual</b> (process status): 'ps -ef' ou 'ps -aux' ou 'ps -r' (-r para somente running. 'pgrep termoBusca' faz mesmo que 'ps aux | grep termoBusca')
<b>Similar acima, mas em todos tty</b>: ps u
<b>Ver processos, filtro</b>: 'ps -ef | grep init' (todos processos 'init') ou 'ps --pid numPID' ou '--ppid numPPID' (filtro por id)
<b>Ver processos do usuário, em 1º e 2º plano, em todos tty</b>: ps a
<b>Ver processos, forma personalizada</b>: ps ax -o user,pid,ppid,%cpu,%mem,stat,start,command | head -3
<b>Listar processos e processos filhos</b>: 'ps faux' ou 'ps -ef'
<b>Ver PID do processo</b>: pidof nomeProcesso (pidof init)
<b>Mostrar dados de processo</b>: top numPID ('q' para sair) ('top' é 'table of process/processes')
<b>Processos de usuário específico</b>: top -u usuario
<b>Mostrar processos, via HTOP</b>: htop (O 'Hisham Top' - nome do criador, é uma ferramenta CLI para visualizar processos do sistema. sudo apt install htop)
<b>Mostrar processos, Bashtop</b>: bashtop (Similar ao HTOP, mas com visualização aperfeiçoada. Necessário instalação)
<b>Processos de arquivo específico</b>: fuser nomeArquivo
<b>Processos em árvore</b>: pstree
<b>Processos enviados para background pelo usuário da sessão atual</b>: jobs (-l mostra PIDs, -r somente running, -s somente stopped)
<b>Encerrar processo</b>: kill -15 numPID (função sigterm, similar a 'kill numPID' ou 'kill -SIGTERM numPID')
<b>Parar processo</b>: kill -19 numPID (sigstop)
<b>Parar processo em background</b>: ctrl+z (sigquit, similar a 'kill -3')
<b>Matar processo</b>: kill -9 numPID (sigkill. O sigkill encerra processo forçadamente, enquanto o sigterm encerra processo naturalmente)
<b>Matar processo pelo nome</b>: pkill nomeProcesso (ou 'pkill -9 nomeProcesso')
<b>Continuar processo stopped</b>: kill -18 numPID (sigcont)
<b>Criar processo com prioridade</b>: nice -n -10 nomeProcesso (prioridade -10)
<b>Matar todos processos de software</b>: 'killall nomeSoftware'
<b>Alterar prioridade</b>: 'renice numPrioridade -p numPID' ou 'nice -n numPrioridade nomeProcesso'
<b>Ignorar sinais ao processo</b>: Torná-lo daemon, para mantê-lo em execução mesmo com shell fechado (2º plano, background), 'nohup ping 8.8.8.8 &' (sighup. As saídas do nohup ficam em 'nohup.out')
<b>Retomar processo parado em background, para foreground</b>: fg idJob
<b>Retomar processo parado em foreground, para background</b>: bg idJob
<b>Enviar processo para ser executado em background</b>: nomeProcesso & (ou 'comando &')
<b>Ver carga do sistema</b>: uptime
<b>Scanner disco, checar por arquivos residuais em diretórios</b>: ncdu (Tecla 'd' apagará arquivos residuais do diretório destaque)
</code></pre></small>

                    <h5>Mensagens do sistema:</h5>
                    <p>Registros (logs) do sistema são gerenciados pelo <i>syslog</i> ou seus derivados, <i>syslog-ng</i> ou <i>rsyslog</i>. O daemon de log coleta mensagens de arquivos em '/var/log'. Geralmente logs são armazenados em arquivos '.log'. Respectivamente, os logs 'messages' compõem-se de data e hora, host do log, service que gerou o log, PID do processo que gerou o log, e descrição do log. O <i>logrotate</i> implementa rotação/ciclo de log, criando/movendo/arquivando arquivos de grandes logs, a fim de simplificar/organizar/otimizar a organização dos arquivos de logs (geralmente arquivos possuem nome 'dataHoraLog.log' ou 'log1.log' 'log2.log' etc). Comando <i>journalctl</i> faz leitura dos logs(diário) do systemd.</p>
                    <ul>
                        <li><i>/var/log/auth.log</i>: Informações sobre autenticação;</li>
                        <li><i>/var/log/wtmp</i>: Informações de logins bem sucedidos (comando 'last' interpreta o arquivo);</li>
                        <li><i>/var/log/btmp</i>: Informações de logins malsucedidas (comando 'lastb' interpreta o arquivo);</li>
                        <li><i>/var/log/kern.log</i>: Informações do kernel;</li>
                        <li><i>/var/log/syslog</i>: Informações do sistema;</li>
                        <li><i>/var/log/messages</i>: Dados do sistema e binários.</li>
                    </ul>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Shell script</h4>
                <div class="card-body">
                    <p id="textoPost">Script de execução em shell GNU/Linux, em linguagem shell, arquivos com terminação '.sh'. Realizam manipulação em rotinas shell Linux. <span class="text-muted">#!/bin/bash</span> ou <span class="text-muted">#!/bin/sh</span> é o shebang (ou sha-bang, hashbang, pound-bang, hash-pling), interpretador do script, gerará um subshell para executar os códigos, não considerado comentário. Para executar shell script sem permissão de execução, deve-se executar '<span class="text-muted">source arquivo.sh</span>' (ou '. arquivo.sh', ou 'bash arquivo.sh'). Também, pode-se atribuir permissão de execução ao mesmo com '<span class="text-muted">chmod a+x arquivo.sh</span>' e executá-lo com '<span class="text-muted">./arquivo.sh</span>' (ou '/home/usuario/arquivo.sh'). Scripts são utilizados para automatização de tarefas - como configurar ambiente, executar binários, fazer limpezas, gestão de processos e serviços, registros, etc. Essas tarefas são conhecidas <b>Shell Wrapper</b>. Exemplo prático de Shell Wrapper é script para criação de logins e usuários, respectivos grupos e diretórios, além de escalonar privilégios para cada usuário criado. O Kernel GNU/Linux, a partir da versão 6.1, está em upgrade através da linguagem <b>Rust</b>, que fornece maior desempenho e segurança. Codificação shell script possui lógica procedural (cascade), possibilitando modularização através de funções.</p>

                    <h5>Operadores aritméticos:</h5>
                    <ul>
                        <li>'<b>=</b>': igual a (1=1);</li>
                        <li>'<b>!=</b>': diferente de (1!=2);</li>
                        <li>'<b>-z</b>': vazio (-z $valor);</li>
                        <li>'<b>-n</b>': não vazio (-n $valor);</li>
                        <li>'<b>+</b>': adição (1+1);</li>
                        <li>'<b>-</b>': subtração (2-1);</li>
                        <li>'<b>/</b>': divisão (12/6);</li>
                        <li>'<b>*</b>': multiplicação (12*6);</li>
                        <li>'<b>%</b>': módulo, resto da divisão inteira (12%6 será 0);</li>
                        <li>'<b>++</b>': incremento (1++ será 2);</li>
                        <li>'<b>--</b>': decremento (2-- será 1);</li>
                        <li>'<b>+=</b>': atribuição com adição (5+=1 é mesmo que 5=5+1);</li>
                        <li>'<b>-=</b>': atribuição com subtração (5-=1 é mesmo que 5=5-1);</li>
                        <li>'<b>*=</b>': atribuição com multiplicação (5*=1 é mesmo que 5=5*1);</li>
                        <li>'<b>/=</b>': atribuição com divisão (5/=1 é mesmo que 5=5/1);</li>
                        <li>'<b>%=</b>': atribuição com resto da módulo (5%=1 é mesmo que 5=5%1);</li>
                        <li>'<b>**</b>': exponenciação (2**2 (base,expoente) será 4);</li>
                        <li>'<b>bc</b>': basic calculator, para radiciação (raiz_quadrada=$(echo "scale=4; sqrt($numero)" | bc)).</li>
                    </ul>

                    <h5>Operadores lógicos:</h5>
                    <ul>
                        <li>'<b>&lt;&lt;</b>': deslocamento a esquerda;</li>
                        <li>'<b>&lt;&lt;=</b>': deslocamento a esquerda;</li>
                        <li>'<b>&gt;&gt;</b>': deslocamento a direita;</li>
                        <li>'<b>&gt;&gt;=</b>': deslocamento a direita;</li>
                        <li>'<b>!</b>': operador not, diferente de (! 1 = 2, se 1 é diferente de 2);</li>
                        <li>'<b>-o</b>' ou '<b>||</b>' ou '<b>|</b>' ou '<b>!=</b>': operador or ($x = 22 -o $x = 23, se x = 22 ou 23);</li>
                        <li>'<b>^</b>' ou '<b>^=</b>': operador xor, 'ou exclusivo';</li>
                        <li>'<b>~</b>': negação de bit;</li>
                        <li>'<b>-a</b>' ou '<b>&&</b>' ou '<b>&</b>' ou '<b>&=</b>': operador and ($y = 22 -a $x = 22, se x = 22 e y = 22).</li>
                    </ul>

                    <h5>Operadores relacionais:</h5>
                    <ul>
                        <li>'<b>-eq</b>': equal, igual a ($x -eq 2);</li>
                        <li>'<b>-ne</b>': not equal, diferente de ($x -ne 2);</li>
                        <li>'<b>-gt</b>': greater than, maior que ($y -gt 10);</li>
                        <li>'<b>-ge</b>': greater than or equal, maior que ou igual a ($s -ge 6.2);</li>
                        <li>'<b>-lt</b>': less than, menor que ($y -lt 4);</li>
                        <li>'<b>-le</b>': less than or equal, menor que ou igual a ($k -le 0.4).</li>
                    </ul>

                    <h5>Operadores de String:</h5>
                    <ul>
                        <li>'<b>-z</b>': verifica se tamanho do operando da string é zero/nulo (-z $x);</li>
                        <li>'<b>-n</b>': verifica se tamanho do operando da string é diferente de zero/não nulo (-n $x);</li>
                        <li>'<b>=</b>': verifica se string é igual;</li>
                        <li>'<b>!=</b>': verifica se string é diferente;</li>
                        <li>'<b>[ $x ]</b>': verifica se $x não é string vazia;</li>
                        <li>'<b>:=</b>': atribui valor padrão a variável se estiver vazia ou não definida;</li>
                        <li>'<b>:-</b>': fornece valor padrão sem alterar variável original.</li>
                    </ul>

                    <h5>Operadores de arquivo:</h5>
                    <ul>
                        <li>'<b>-a</b>': verifica se arquivo existe (-a /etc/arquivo);</li>
                        <li>'<b>-b</b>': verifica se é arquivo de bloco (-b /etc/arquivo);</li>
                        <li>'<b>-c</b>': verifica se é arquivo de caracteres (-c /etc/arquivo);</li>
                        <li>'<b>-d</b>': verifica se é diretório (-d /etc/arquivo);</li>
                        <li>'<b>-e</b>': verifica se arquivo existe (-e /etc/arquivo);</li>
                        <li>'<b>-f</b>': verifica se é arquivo comum (-f /etc/arquivo);</li>
                        <li>'<b>-g</b>': verifica se arquivo possui SGID (-g /etc/arquivo);</li>
                        <li>'<b>-h</b>': verifica se arquivo é link simbólico (-h /etc/arquivo);</li>
                        <li>'<b>-k</b>': verifica se arquivo possui bit fixo (-k /etc/arquivo);</li>
                        <li>'<b>-p</b>': verifica se arquivo é pip nomeado (-p /etc/arquivo);</li>
                        <li>'<b>-r</b>': verifica se arquivo é legível (-r /etc/arquivo);</li>
                        <li>'<b>-s</b>': verifica se arquivo existe e tem tamanho maior que 0 (-s /etc/arquivo);</li>
                        <li>'<b>-t</b>': verifica se descritor de arquivo está aberto e associado a terminal (-t /etc/arquivo);</li>
                        <li>'<b>-u</b>': verifica se arquivo possui SUID (-u /etc/arquivo);</li>
                        <li>'<b>-w</b>': verifica se arquivo é gravável (-w /etc/arquivo);</li>
                        <li>'<b>-x</b>': verifica se arquivo é executável (-x /etc/arquivo);</li>
                        <li>'<b>-G</b>': arquivo existe e pertence ao grupo do usuário;</li>
                        <li>'<b>-L</b>': arquivo existe e é link simbólico;</li>
                        <li>'<b>-N</b>': arquivo existe e modificado desde última leitura;</li>
                        <li>'<b>-O</b>': arquivo existe e usuário é dono do arquivo;</li>
                        <li>'<b>-S</b>': arquivo é socket;</li>
                        <li>'<b>arq1 nt arq2</b>': arquivo arq1 é mais novo (new to) que arquivo arq2;</li>
                        <li>'<b>arq1 ot arq2</b>': arquivo arq1 é mais antigo (old to) que arquivo arq2.</li>
                    </ul>

                    <h5>Blocos e agrupamentos:</h5>
                    <ul>
                        <li>'<b>{...}</b>': agrupa comandos em bloco;</li>
                        <li>'<b>(...)</b>': executa comandos em subshell;</li>
                        <li>'<b>$(...)</b>': executa comandos em subshell, retornando resultado;</li>
                        <li>'<b>((...))</b>': testa operação aritmética, retornando 0 ou 1;</li>
                        <li>'<b>$((...))</b>': retorna resultado de operação aritmética;</li>
                        <li>'<b>[...]</b>': testa expressão, retornando 0 ou 1 (alias do comando 'test');</li>
                        <li>'<b>[[...]]</b>': testa expressão, retornando 0 ou 1 (podendo usar && e ||).</li>
                    </ul>

                    <h5>Argumentos:</h5>
                    <p>Argumento(s) informado(s) junto ao comando de execução do arquivo.sh</p>
                    <ul>
                        <li>'<b>$0</b>': nome do script que foi executado;</li>
                        <li>'<b>$1 .. $n</b>': argumentos na ordem em que foram passados ($1 é argumento1, $2 argumento2, etc);</li>
                        <li>'<b>$#</b>': nº de argumentos passado;</li>
                        <li>'<b>$*</b>': todos argumentos de uma vez só;</li>
                        <li>'<b>$@</b>': todos parâmetros passados depois do script;</li>
                        <li>'<b>*?</b>': último comando executado;</li>
                        <li>'<b>$$</b>': PID do processo executando;</li>
                        <li>'<b>$!</b>': PID do processo executado em background.</li>
                    </ul>

                    <h5>Exit status codes:</h5>
                    <p>Lista de códigos para feedback de status de saída. Comandos 'man sysexits' exibe man page com lista de códigos.</p>
                    <ul>
                        <u>Status comuns</u>:
                        <li>'<b>0</b>': sucesso (binário executado sem erros). Todos códigos diferentes de 0 representam erro;</li>
                        <u>Erros gerais</u>:
                        <li>'<b>1</b>': erro geral (erro genérico não específico);</li>
                        <li>'<b>2</b>': uso incorreto do shell builtins (comando inválido);</li>
                        <u>Erros de comandos binários comuns</u>:
                        <li>'<b>3</b>' a '<b>124</b>': erros em jobs;</li>
                        <li>'<b>125</b>': excedeu armazenamento de memória;</li>
                        <li>'<b>126</b>': binário encontrado, mas não pode ser executado;</li>
                        <li>'<b>127</b>': binário não encontrado;</li>
                        <u>Erros de comandos binários específicos</u>:
                        <li>'<b>128</b>': argumento inválido ao binário 'exit';</li>
                        <li>'<b>128+n</b>': binário terminado por signal n (1 a 255);</li>
                        <li>'<b>129</b>' a '<b>192</b>': jobs terminados por signals;</li>
                        <li>'<b>130</b>': job terminado por SIGINT 'ctrl+c';</li>
                        <u>Erros de jobs e programas específicos</u>:
                        <li>'<b>137</b>': job terminado por SIGKILL (137=128+9);</li>
                        <li>'<b>143</b>': job terminado por SIGTERM;</li>
                        <li>'<b>255</b>': exit status code fora do intervalo (0-255).</li>
                    </ul>
<small><pre><code>
<b><u>Exemplo de arquivo.sh</u></b>:
#!/bin/bash
echo "Seu nome de usuário é:"
whoami
# comentário

<b>========== SAÍDA DE DADOS ==========</b>
echo "ola" # com ou sem aspas duplas (aspas simples são considerados string como todo, aspas duplas consideram valores de variáveis)
$a = ola2 # variável local
export $b = 12 # variável global
echo $a
echo $HOME ola
echo "$a, $b" # concatenar variáveis
echo $a > novoArquivo # redirecionar stdout para arquivo
echo "O nome da variável é \$nome" # \ é caractere scape, não mostrará variável

nome=""
echo "Valor inicial: '$nome'"
nome=${nome:=Maria}
echo "valor da variável depois: $nome" # saída será 'Maria'

echo "variável inicial: $var" # saída será ''
echo "variável após expansão: '${var:-ValorPadrao}'" # saída será 'ValorPadrao'
echo "valor da variável depois: $var" # saída será ''

<b>========== ENTRADA DE DADOS ==========</b>
read -p "Digite um nome: " nome
echo "${nome:=$(whoami)}"

<b>========== TIPOS DE DADOS ==========</b>
$texto = "ola"
$numInteiro = 12
$numReal = 12.41
$booleano = 0 # 0 para false e 1 para true. Ou pode-se utilizar "false" e "true"
$lista = (1 2 3 4 5 6 7 8 9)
$lista2 = ("abc" "def" "ghi")
frutas=("maçã" "banana" "laranja" "goiaba") # Arrays (listas)
echo "Todas as chaves: ${!frutas[@]}"
echo "Todas as frutas (@): ${frutas[@]}"
echo "Todas as frutas (*): ${frutas[*]}"
echo "Terceira fruta: ${frutas[2]}" # item 3 do array
echo "Número de frutas: ${#frutas[@]}" # tamanho array

declare -A dicionario # dicionário: array associativo
dicionario["Brasil"]="Brasília"
dicionario["Goiás"]="Goiânia"
echo ${dicionario["Brasil"]}
unset dicionario["Goiás"] # apagar chave

# Iterando sobre chaves
for chave in ${!frutas[@]}; do
    echo $chave
done

# Iterando sobre valores
for valor in ${frutas[@]}; do
    echo $valor
done

<b>========== CONDICIONAL IF-ELIF-ELSE ==========</b>
if [ $3 ]; then
    echo "$3"
elif [ $2 ]; then
    echo "$2"
else
    echo "$1"
fi

<u>Exemplo 1</u>:
if [ -e /etc/group ]; then
    echo 'arquivo existe'
else
    echo 'arquivo não existe'
fi

<u>Exemplo 2</u>:
num=14
if [ $num -ge 10 -o $num -lt 20 ]; then
    echo 'nº maior que 10 e menor que 20'
else
    echo 'fora do intervalo'
fi

<u>Exemplo 3</u>:
num=12
if [[ $num = ?(+|-)+([0-9]) ]]; then
    echo 'Número'
else
    echo 'String'
fi

<u>Exemplo 4</u>:
echo "you have provided the following arguments $arg1 $arg2 $arg3"
if [ "$arg1" = "$arg2" ] && [ "$arg1" != "$arg3" ]
then 
    echo "2 of the provided args are equal."
    exit 3
elif [ $arg1 = $arg2 ] && [ $arg1 = $arg3 ]
then
    echo "all of the specified args are equal"
    exit 0
else
    echo "all of the specified args are different"
    exit 4 
fi

<b>========== CONDICIONAL CASE ==========</b>
case $1 in
    caso_um) echo "1";;
    caso_dois) echo "2";;
    6|SEIS|Seis|seis) echo "6";;
    *) echo "outro";;
esac

<u>Exemplo 1</u>:
cor="azul"
case $cor in
    "preto") echo "preto é a cor escolhida";;
    "azul") echo "azul é a cor escolhida";;
    "vermelho") echo "vermelho é a cor escolhida";;
    *) echo "outra cor for escolhida";;
esac

<b>========== CONDICIONAL SELECT ==========</b>
$FRUTA="Selecione fruta: "
select FRUTA in uva laranja banana ... outra
do
    echo "Fruta escolhida $FRUTA"
    break;
done

<u>Exemplo 1</u>:
PS3="Select your language please: "
select lng in Bash Java C++ Quit
do
    case $lng in
        "Bash")
            echo "$lng - that's what we're talking about";;
        "Java")
           echo "$lng - is your VM ready?";;
        "C++")
           echo "$lng - let's prepare for a lot of compilation";;
        "Quit")
           echo "We're done"
           break;;
        *)
           echo "Ooops";;
    esac
done

<u>Exemplo 2</u>:
PS3="Select item please: "
items=("Item 1" "Item 2" "Item 3")
select item in "${items[@]}" Quit
do
    case $REPLY in
        1) echo "Selected item #$REPLY which means $item";;
        2) echo "Selected item #$REPLY which means $item";;
        3) echo "Selected item #$REPLY which means $item";;
        $((${#items[@]}+1))) echo "We're done!"; break;;
        *) echo "Ooops - unknown choice $REPLY";;
    esac
done

<u>Exemplo 3 (dialog)</u>:
# dialog é popup de diálogo CLI, zenity é GUI
items=(1 "Item 1" 2 "Item 2")
while choice=$(dialog --title "$TITLE" --menu "Please select" 10 40 3 "${items[@]}" 2&gt;&1 &gt;/dev/tty)
    do
    case $choice in
        1) ;;
        2) ;;
        *) ;;
    esac
done
clear

<b>========== REPETIÇÃO LOOP FOR ==========</b>
for i in 1 2 3
do
    echo "teste"
done

#ou inline: for i in 1 2 3; do echo "teste"; done

for i in {1..10};
do
    echo "Valor: $i"
done

for i in {10..0}; # decrescente
do
   echo "$i"
done

for i in $(seq 1 5 100); # de 1 a 100, pulando de 5 em 5
do
    echo "$i"
done

for ((j=1; j&lt;20; j+=2))
do
    echo $j
done

# para cada argumento como $i
for i in "$@"
do
    echo $i
done

<b>========== REPETIÇÃO LOOP WHILE ==========</b>
while [ -z $a_input ]; do
    read -p "Enter para continuar ou digite qualquer coisa para sair: " a_input
done

$i = 0
while [ $i -le 10 ]; do
    echo "$i"
    $i++
done

<u>Exemplo 1</u>:
while read -p "Digite um numero: " c_input
do
    if [ $c_input -gt 25 ]; then
        echo "Numero $c_input é maior que 25"
        break
    else
        echo "Numero $c_input é menor que 25"
        break
    fi
done

<u>Exemplo 2</u>:
while getopts ae:f:hd:s:qx: option
do
    case "${option}"
    in
        a) ALARM="TRUE";;
        e) ADMIN=${OPTARG};;
        d) DOMAIN=${OPTARG};;
        f) SERVERFILE=$OPTARG;;
        s) WHOIS_SERVER=$OPTARG;;
        q) QUIET="TRUE";;
        x) WARNDAYS=$OPTARG;;
        \?) usage
            exit 1;;
    esac
done

<u>Exemplo 3</u>:
while:
do
    read -p "Enter two numbers ( - 1 to quit ): " a b
    if [ $a -eq -1 ]
    then
        break
    fi
    ans=$(( a + b ))
    echo "$ans"
done

<b>========== REPETIÇÃO LOOP UNTIL ==========</b>
# O while 1º verifica, depois executa. O until 1º executa, depois verifica
count=1
until [ $count -gt 5 ]; do
    echo $count
    count=$(($count+1))
done

<u>Exemplo 1</u>:
#!/bin/bash
echo "until loop"
i=10
until [ $i == 1 ]
do
    echo "$i is not equal to 1";
    ((i--))
done
echo "i value is $i"
echo "loop terminated"

<u>Exemplo 2</u>:
n=1
sum=0
until [[ $n -gt 15  || $sum -gt 20 ]]
do
    sum=$(($sum + $n))
    echo "n = $n & sum of first n = $sum"
    ((n++))
done

<b>========== BREAK e CONTINUE ==========</b>
# Break encerra o loop. Continue pula iteração e avança para próxima
count=1
while true; do
    echo "Contagem é $count"
    count=$(($count+1))
    if [ $count -gt 5 ]; then
        echo "instrução break alcançada"
        break
    fi
done

for i in {1..10}; do
    if [ $i -eq 5 ]; then
        continue
    fi
    echo $i
done

<u>Exemplo 1:</u>
for i in {1..3}; do
    for j in {1..3}; do
        if [[ $j -eq 2 ]]; then
            break 2 # break 2 primeiro encerra o loop, depois sai
        fi
        echo "j: $j"
    done
    echo "i: $i"
done
echo "All Done!"

<u>Exemplo 2</u>:
for val in {1..20..2}
do
    if [[ $val -eq 9 ]]
    then
        continue
    fi
    echo "printing ${val}"
done

<b>========== FUNÇÕES FUNCTION ==========</b>
function minha_funcao() {
    echo "ola"
}
minha_funcao

# Função com retorno
soma(){
    echo "Os números são: $n1 $n2"
    sum_val=$(($n1+$n2))
    echo "Soma: $sum_val"
    return $sum_val
}
n1=$1
n2=$2
soma
echo "Valor retornado pela função é $?"

<u>Exemplo 1</u>:
addUser(){
    USER=$1
    PASSWORD=$2
    shift; shift;
    COMMENTS=$@
    echo "Adding user $USER ..."
    echo useradd -c "$COMMENTS" $USER
    echo passwd $USER $PASSWORD
    echo "Added user $USER ($COMMENTS) with pass $PASSWORD"
}
addUser bob letmein Bob Holness the presenter
addUser fred badpassword Fred Durst the singer
addUser bilko worsepassword Sgt. Bilko the role model

<u>Exemplo 2</u>:
find_avg(){ 
    len=$#
    sum=0
    for x in "$@"
    do
        sum=$((sum + x))
    done
    avg=$((sum/len))
    return $avg
}
find_avg 30 40 50 60
printf "%f" "$?"
printf "\n"

<b>========== IMPORTS ==========</b>
# source ou '.' importa código shell script externo ao código em que está referenciado
<u>externo.sh</u>:
diga_ola() {
    echo "Olá do script externo!"
}

<u>arquivo.sh</u>:
source externo.sh #ou '. externo.sh'
diga_ola

<b>========== PARÂMETROS ==========</b>
<u>Comando shift</u>:
# shift executa sequência de parâmetros ordenadamente a partir da origem ou valor informado (ex: shift 5 a partir do 5º parâmetro)
echo "$#: $*"
echo -e "executando \"shift\""
shift
echo "$#: $*"
echo -e "executando \"shift 5\""
shift 5
echo "$#: $*"
echo -e "executando \"shift 7\""
shift 7
echo "$#: $*"

<u>Comando set</u>:
# set pode ser usado para editar parâmetros
echo "Os $# parâmetros passados inicialmente foram:"
echo "$@"
echo "Mas agora eu vou alterá-los para 'um', 'dois' e 'tres'."
set um dois tres
echo "Os $# novos parâmetros agora são:
echo "$@" #novos valores a partir do set

<b>========== ARGUMENTOS ==========</b>
if [ $# -lt 1 ];
then
    echo "Precisa fornecer pelo menos 1 argumento!"
    exit 1
fi
echo "Número de argumentos passados: $#"
i=0
for argumento in $*
do
    i=$(($i+1))
    echo "argumento $i passado: $argumento"
done

<b>========== INTEGRAÇÃO COM PYTHON ==========</b>
arquivos=$(ls *txt)
for i in $arquivos
do
    python3 script.py $i
done

arquivos=$(ls *txt)
for i in $arquivos
do
    nohup python3 script.py $i &
done

<b>========== ERROS ==========</b>
# Formas de aplicar estrutura similar a 'try/catch/finally' em shell script

<u>Forma 1 (via return)</u>:
mv /non/existent/path /tmp/file1
if [[ $? != 0 ]]; then
    echo "mv failed"
    exit 1
fi

if ! command_call; then
    echo "command_call did not complete successfully"
fi

<u>Forma 2 (via blocos or e set e)</u>:
mv /non/existent/path /tmp/file1 || exit 1
mv /non/existent/path /tmp/file1 || { echo "mv failed"; exit 1; }

<u>Forma 3</u>:
source includes/logging.sh "script4.log"
set -e
mv /non/existent/path /tmp/file1

mv /non/existent/path /tmp/file1 || {
    echo "mv failed, but it's expected to happen"
}

{
    echo "try block"
    false
} || {
    echo "catch block"
    echo "..."
}

{
    echo "try block" &&
    false &&
    echo "try block after failed command"
} || {
    echo "catch block" &&
    true  &&
    echo "..."
} || { FAILED_CATCH="$?"; } ; {
    echo "finally block" &&
    false
} || { FAILED_FINALLY="$?"; } ; {
    if [[ ! -z $FAILED_CATCH ]]; then exit $FAILED_CATCH; fi
    if [[ ! -z $FAILED_FINALLY ]]; then exit $FAILED_FINALLY; fi
}

<u>Forma 3 (trap)</u>:
trap "echo 'ERROR: An error occurred during execution, check log $LOGFILE for details.' >&3" ERR

source includes/logging.sh "script4.log"
set -e

TEST_FILE_PATH='/tmp/dummy-marker'
cleanup() {
  echo "A command failed with return code of $?" >&3
  rm -f "$TEST_FILE_PATH"
}

trap 'cleanup' ERR # from now on, if any command fails cleanup is executed
trap 'cleanup' INT # do int for SIGINT as well (ctrl + c)
 
echo "Creating a test file"
touch $TEST_FILE_PATH
echo "echo before executing a command that exits with non-zero return code"
false
echo "echo after the command is executed

<u>Forma 4 (SIGKILL)</u>:
#!/bin/bash
function_that_generates_a_segfault() {
  ulimit -s 1
  function_that_generates_a_segfault
}
function_that_generates_a_segfault

#!/bin/bash
source includes/logging.sh "script4.log"
set -e
./segfault.sh || {
    echo "Operation failed"
}
echo "..."

#!/bin/bash
source includes/logging.sh "script4.log"
set -e

function_that_generates_a_segfault() {
  ulimit -s 1
  function_that_generates_a_segfault
}
function_that_generates_a_segfault

function_that_generates_a_segfault || {
    echo "Operation failed"
}
echo "..."
</code></pre></small>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Localização</h4>
                <div class="card-body">
                    <p>Encontrar arquivos no sistema. Comando 'locate' realiza pesquisa simples, utilizando base de dados (updatedb) ao invés de recursividade nas buscas (Ex: '<span class="text-muted">locate howto</span>'). Comando 'find' utiliza recursividade nas buscas.<br>Sintaxe: <span class="text-danger">find [diretórioBusca] [opção] [termo/expressãoBusca]</span></p>
<small><pre><code>
<u><b>Exemplos de buscas</b></u>:
<b>Arquivos com 'teste' no diretório atual</b>: find teste
<b>Arquivos com final '.conf' no diretório '/etc'</b>: find /etc -name *.conf
<b>Limitar recursividade em diretórios</b>: find /etc -maxdepth 1 -name *.conf (apenas 1 diretório, ou seja, o atual)
<b>Arquivos acessados minutos atrás</b>: find / -amin -5 (últimos 5min)
<b>Arquivos acessados dias atrás</b>: find / -atime 10 (acessados 10 dias atrás)
<b>Arquivos por id do usuário</b>: find / -uid 1000 (arquivos do usuário 1000)
<b>Arquivos por nome do usuário</b>: find / -user root (arquivos do root)
<b>Arquivos por permissão</b>: find / -perm 644 (arquivos de permissão 644)
<b>Arquivos por tamanho</b>: find / -size +50M (arquivos com mais de 50 megabytes)
<b>Arquivos por tipo (bloco, caractere, diretório...)</b>: find /dev -type b (arquivos de bloco)
<b>Arquivos regulares vazios</b>: find / -type f -empty
<b>Arquivos executando nos últimos minutos</b>: find / -cmin -60 (últimos 60min)
<b>Diretórios modificados nos últimos dias</b>: find / -mtime 50 (últimos 50 dias)
<b>Diretórios modificados entre datas</b>: find / -mtyme +50 -mtyme -100 (entre últimos 50 e 100 dias)
</small></pre></code>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Ajuda</h4>
                <div class="card-body">
                    <ul>
                        <li><b>how-to</b> (cookbook): Documentos, disponíveis em '/usr/share/doc', focados em necessidade específica, como montar um firewall. Possuem formatos HTML, Markdown, entre outros (Ex: how-to do iptables estão em '/usr/share/doc/iptables');</li>
                        <li><b>man page</b>: Manuais de ajuda geral, via comando 'man'. Há o termo com o nº do manual indicado ('gzip(1)' é o man1 do gzip). Sintaxe: <span class="text-danger">man [sessão] &lt;termo&gt;</span>. Sessão pode alterar manual do comando (Ex: 'man passwd' é man1 do comando passwd, 'man 5 passwd' é man5 do arquivo de configuração passwd). Comando 'catman' atualiza a base de dados dos manuais. Manuais estão em '/usr/share/man'. Cada manual possui 11 seções de organização de conteúdo, sendo padronizados globalmente (nome, sinopse, descrição, opções/parâmetros, argumentos, arquivos, exemplos, veja mais, diagnósticos, direitos autorais e bugs). Além disso, existem 9 categorias de manuais. Comandos <b>yelp</b> e <b>xman</b> são ferramentas GUI para tal;
                            <ul>
                                <li>man 1: Binários e executáveis;</li>
                                <li>man 2: Rotinas do sistema Linux e linguagem C;</li>
                                <li>man 3: Rotinas e libraries da linguagem C;</li>
                                <li>man 4: Arquivos especiais (dispositivos em '/dev');</li>
                                <li>man 5: Arquivos de configurações e convenções;</li>
                                <li>man 6: Games;</li>
                                <li>man 7: Diversos (macros textuais, por exemplo, regex);</li>
                                <li>man 8: Super binários;</li>
                                <li>man 9: Rotinas internas do kernel.</li>
                            </ul>
                        </li>
                        <li><b>help</b>: Providencia manuais de ajuda específicos para binários internos (Ex: 'help type' ajuda para comando type). Binários externos são executados com '--help' (Ex: 'cd --help');</li>
                        <li><b>info</b>: Info pages são similares às man pages, sendo em formato HTML, possuindo mais recursos de navegação, como hyperlinks. Sintaxe: <span class="text-danger">info [termo]</span> (Ex: 'info vim');</li>
                        <li><b>whatis</b>: Busca por referências idênticas (Ex: 'whatis passwd'). Comando '<span class="text-muted">man -f termo</span>' é similar;</li>
                        <li><b>which</b>: Mostra localização do binário (Ex: 'which ls');</li>
                        <li><b>apropos</b>: Busca por referências similares (Ex: 'apropos email address'). Comando '<span class="text-muted">man -k termo</span>' é similar;
                            <ul>
                                <li>(<b>-d</b>): Exibir mensagens de depuração;</li>
                                <li>(<b>-v</b>): Verbose, exibir detalhes do andamento da pesquisa;</li>
                                <li>(<b>-e</b> ou <b>--exact</b>): Busca por referência idêntica;</li>
                                <li>(<b>-w</b> ou <b>--wildcard</b>): Busca com expressões regulares;</li>
                                <li>(<b>-a</b> ou <b>--and</b>): Busca concatenada de 2 ou mais termos que se correspondam;</li>
                                <li>(<b>-l</b> ou <b>--long</b>): Resultado de saída sem quebra de linha;</li>
                                <li>(<b>-C</b>): Dispensar padrão (/ manpath), trocando-o por arquivo de configuração personalizado;</li>
                                <li>(<b>-L</b>): Definir diretório da busca;</li>
                                <li>(<b>-m</b> ou <b>--systems</b>): Usar man pages externas;</li>
                                <li>(<b>-M</b> ou <b>--manpath</b>): Definir caminho de busca das man pages para PATH ao invés do $MANPATH padrão;</li>
                                <li>(<b>-s</b> ou <b>--section</b> ou <b>--sections</b>): Busca em sessões específica (separadas por '<b>:</b>');</li>
                                <li>(<b>-r</b> ou <b>--regex</b>): Interpretar termo pesquisado como regex.</li>
                            </ul>
                        </li>
                        <li><b>whereis</b>: Localizar binário e manual do comando (Ex: 'whereis ls' mostrará '/usr/bin/ls' e '/usr/share/man/man1/ls.1.gz').
                            <ul>
                                <li>(<b>-b</b>): Buscar somente localização do binário;</li>
                                <li>(<b>-m</b>): Somente man pages;</li>
                                <li>(<b>-s</b>): Somente fontes;</li>
                                <li>(<b>-u</b>): Buscar termos incomuns, como arquivos de origem ou binários;</li>
                                <li>(<b>-B</b>): Alterar/limitar locais de pesquisa por binários;</li>
                                <li>(<b>-M</b>): Alterar/limitar locais de pesquisa por man pages;</li>
                                <li>(<b>-S</b>): Alterar/limitar locais de pesquisa por fontes;</li>
                                <li>(<b>-f</b>): Termina última lista de diretórios e sinaliza início dos nomes dos arquivos (deve ser usado com opções -B , -M ou -S).</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Nano editor</h4>
                <div class="card-body">
                    <p>O GNU nano (nano editor) é editor CLI de texto, baseado no Joe, presente na maioria das distros GNU/Linux. Carregado automaticamente no modo de edição. Para utilizá-lo basta digitar nano, seguido do nome do arquivo que deseja criar/editar. O arquivo '/etc/nanorc' realiza a inicialização do GNU nano.<br>Sintaxe: <span class="text-danger">nano [parâmetros] [arquivo(s)]</span></p>
<small><pre><code>
<b><u>Atalhos do GNU nano</u></b>:
<b>ctrl+g</b>: Ajuda
<b>ctrl+k</b>: Recortar linha
<b>ctrl+u</b>: Colar linha recortada
<b>ctrl+_</b>: Ir para linha informada
<b>ctrl+y</b>: Sobir 1 página
<b>ctrl+v</b>: Descer 1 página
<b>alt+/</b>: Ir para última linha
<b>alt+\</b>: Ir para 1ª linha
<b>ctrl+a</b>: Mover cursor para início da linha
<b>ctrl+e</b>: Mover cursor para fim da linha
<b>ctrl+c</b>: Informações sobre a posição do cursor
<b>ctrl+j</b>: Justificar texto
<b>ctrl+t</b>: Acionar corretor ortográfico (Se comando 'spell' instalado)
<b>ctrl+w</b>: Pesquisar ('alt+w' avança para próxima ocorrência)
<b>ctrl+w texto, ctrl+r novoTexto</b>: Substituir texto ('y' seleciona texto, 'a' substitui todas ocorrências)
<b>alt+a</b>: Ativar/desativar seleção de texto (setas direcionais fazem a seleção quando ativado)
<b>alt+6</b>: Copiar seleção
<b>ctrl+o</b>: Salvar arquivo (pode salvar uma cópia do mesmo em outro local, com outro nome também, 'salvar como')
<b>ctrl+x</b>: Sair do editor
<b>alt+u</b>: Desfazer última alteração (undo)
<b>alt+e</b>: Refazer última alteração, se desfeita (redo)

O nano possibilita a abertura de diversos arquivos ao mesmo tempo
<b>alt+,</b>: Mover para arquivo à esquerda (ou <i>alt+&lt;</i>)
<b>alt+.</b>: Mover para arquivo à direita (ou <i>alt+&gt;</i>)
</small></pre></code>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Vim editor</h4>
                <div class="card-body">
                    <p>Editor CLI, evolução do <b>vi</b> (visual, visual editor), o <b>vim</b> (Vi IMproved), sendo <b>gVim</b> sua versão GUI e <b>neovim</b> (nvim) sua evolução CLI. O vi é a evolução do <b>ex</b> editor (stands for extended), o qual originou o modo 'ex' no vim. Dessa forma, o vim possui vários modos, sendo iniciado no <i>ex mode</i> (modo de comandos e visual. Basicamente, o 'menu' de inicialização), onde as teclas têm função de comandos e somente visualização do conteúdo do arquivo. Para criar/editar conteúdo de arquivo, deve-se entrar no <i>insert mode</i> (modo de inserção/edição), com tecla 'i', onde as teclas têm função de texto comum. Tecla 'esc' sai dos modos, retornando ao ex mode. Arquivo de configuração do vim é '/etc/vim/vimrc'. Sintaxe: <span class="text-danger">vim [parâmetros] [arquivo(s)]</span>. O vim aceita expressões regulares para pesquisa, via comando '/temoOUexpressao' (ou '?termo' para pesquisa reversa). 'enter' para pesquisar. O cursor se moverá para 1ª correspondência que for encontrada. 'n' para seguir às próximas correspondências, 'N' para retroceder. Abaixo, comandos do ex mode:</p>
<small><pre><code>
<u><b>Atalhos gerais</b></u>:
(<b>:i</b>) Entrar no modo Inserção
(<b>:w</b>) Salvar arquivo
(<b>:w arquivo</b>) Salvar cópia do arquivo atual como arquivo
(<b>:w!</b>) Forçar salvar arquivo atual
(<b>:1</b>) Ir para linha 1 ou qualquer nº fornecido
(<b>:e arquivo</b>) Abrir arquivo
(<b>:q</b>) Sair, quando não há alterações no arquivo
(<b>:q!</b>) Sair forçadamente, sem salvar alterações no arquivo
(<b>:wq</b>) Sair e salvar arquivo (mesmo que ':x')
(<b>:u</b>) Desfazer última ação
(<b>ctrl+r</b>) Repetir comando (ou redo-refazer)
(<b>.</b>) Repetir último comando
(<b>:X</b>) Criptografar arquivo
(<b>:set nu</b>) Ativar linhas numeradas (':set nu!' para desativar)
(<b>:syntax on</b>) Ativar syntax highlighting (para ativar, descomentar linha no arquivo de configuração, removendo as aspas da mesma)

<u><b>Movimentações</b></u>:
(<b>gg</b>) Ir para início do arquivo
(<b>G</b>) Ir para final do arquivo
(<b>36G</b>) Ir para 36ª linha
(<b>M</b>) Ir para linha do meio da tela
(<b>h</b>) Voltar 1 caractere ('5h' moverá cursor 5 caracteres para esquerda)
(<b>l</b>) Avançar 1 caractere
(<b>H</b>) Ir para 1ª linha exibida na tela
(<b>L</b>) Ir para última linha exibida na tela
(<b>J</b>) Juntar linha atual com linha seguinte
(<b>gwip</b>) Refazer parágrafo
(<b>k</b>) Subir 1 linha
(<b>j</b>) Descer 1 linha
(<b>w</b>) 1 palavra para direita ('3w' moverá cursor 3 palavras para direita)
(<b>b</b>) 1 palavra para esquerda
(<b>^</b>) Ir para início da linha
(<b>$</b>) Ir para fim da linha
(<b>&#125;</b>) Ir para próximo parágrafo
(<b>&#123;</b>) Ir para parágrafo anterior
(<b>ctrl+B</b>) Voltar 1 página
(<b>ctrl+F</b>) Avançar 1 página
(<b>ctrl+e</b>) Mover tela 1 linha para baixo (sem mover cursor)
(<b>ctrl+y</b>) Mover tela 1 linha para cima (sem mover curso)
(<b>ctrl+b</b>) Mover tela 1 página para cima (cursor na última linha)
(<b>ctrl+f</b>) Mover tela 1 página para baixo (cursor na 1ª linha)
(<b>ctrl+d</b>) Mover tela e cursor meia página para baixo
(<b>ctrl+u</b>) Mover tela e cursor meia página para cima
(<b>ctrl+w, s</b>) Criar janelas verticais
(<b>ctrl+w, v</b>) Criar janelas horizontais
(<b>ctrl+w, w</b>) Movimentar entre janelas
(<b>F1</b>) Exibir tela de ajuda (':q' para sair)

<u><b>Manipulações</b></u>:
(<b>u</b>) Desfazer modificação (undo)
(<b>U</b>) Restaurar linha inteira
(<b>ctrl+r</b>) Refazer modificação (redo)
(<b>s</b>) Deletar caractere atual e colar linha
(<b>S</b>) Deletar linha atual e colar linha
(<b>xp</b>) Trocar 2 letras (deletar e colar)
(<b>dgg</b>) Deletar a partir da linha visual do topo até linha do cursor
(<b>yw</b>) Copiar palavra sob cursor
(<b>dw</b>) Recortar palavra sob cursor
(<b>Y</b>) Copiar linha
(<b>y</b>) Copiar trecho selecionado ('3y' copiar próximas 3 letras, cursor + 2 letras seguintes)
(<b>D</b>) Recortar trecho selecionado
(<b>uu</b>) Recortar linha
(<b>V</b>) Selecionar linha(s), usando setas direcionais para seleção
(<b>v</b>) Selecionar palavra(s), usando setas direcionais para seleção
(<b>p</b>) Colar trecho selecionado/copiado após o cursor
(<b>P</b>) Colar trecho selecionado/copiado antes do cursor
(<b>r</b>) Substituir caractere atual (replace)
(<b>R</b>) Substituir conjunto de caracteres
(<b>yy</b>) Copiar linha atual (sem excluí-la)
(<b>3yy</b>) Copiar próximas 3 linhas (sem excluí-las)
(<b>yw</b>) Copiar próxima linha (sem excluí-la)

<u><b>Identação</b></u>:
(<b>&gt;&gt;</b>) Indentar (mover para direita) 1 linha
(<b>&lt;&lt;</b>) Desindentar (mover para esquerda) 1 linha
(<b>&gt;%</b>) Identar bloco com () ou {} (cursor na chave)
(<b>&lt;%</b>) Desindentar bloco com () ou {} (cursor na chave)
(<b>&gt;ib</b>) Dndentar bloco interno com ()
(<b>&gt;at</b>) Dndentar bloco com tags &lt;&gt;
(<b>3==</b>) Re-indentar 3 linhas
(<b>=%</b>) Re-indentar bloco com () ou {} (cursor na chave)
(<b>=iB</b>) Re-indentar bloco interno com {}
(<b>gg=G</b>) Re-indentar buffer inteiro
(<b>]p</b>) Colar e ajustar indentação para linha atual

<u><b>Exclusões</b></u>:
(<b>x</b>) Excluir caractere sob cursor
(<b>dd</b>) Excluir linha atual ('3dd' excluir próximas 3 linhas)
(<b>dw</b>) Excluir palavra atual ('d3w' excluir próximas 3 palavras. 'd4h' excluir 4 caracteres à esquerda)

<u><b>Modificações</b></u>:
(<b>cc</b>) Substituir linha atual
(<b>cw</b>) Substituir palavra atual
(<b>c3w</b>) Substituir próximas 3 palavras
(<b>c5h</b>) Substituir 5 caracteres para esquerda
(<b>:%s/termo/termoNovoNome/g</b>) Substituir todos 'termo' por 'termoNovoNome'

<u><b>Insert mode</b></u>:
(<b>a</b>) Entrar no modo de inserção após cursor
(<b>A</b>) Entrar no modo de inserção no final da linha
(<b>i</b>) Entrar no modo de inserção antes do cursor
(<b>I</b>) Entrar no modo de inserção no início da linha
(<b>o</b>) Entrar no modo de inserção 1 linha em branco após cursor
(<b>O</b>) Entrar no modo de inserção 1 linha em branco antes do cursor
(<b>ctrl+h</b>) Apagar caractere antes do cursor
(<b>ctrl+w</b>) Apagar palavra antes do cursor
(<b>ctrl+j</b>) Adicionar quebra de linha na posição do cursor
(<b>ctrl+t</b>) Recuar (mover para direita) 1 linha em um shiftwidth
(<b>ctrl+d</b>) Desrecuar (mover para esquerda) 1 linha em um shiftwidth
(<b>ctrl+n</b>) Inserir (auto-completar) próxima correspondência antes do cursor
(<b>ctrl+p</b>) Inserir (auto-completar) correspondência anterior antes do cursor

<u><b>Visual mode</b></u>:
(<b>aw</b>) Selecionar palavra
(<b>ab</b>) Selecionar bloco com ()
(<b>aB</b>) Selecionar bloco com &#123;&#125;
(<b>at</b>) Selecionar bloco com tags &lt;&gt;
(<b>ib</b>) Selecionar bloco interno com ()
(<b>iB</b>) Selecionar bloco interno com &#123;&#125;
(<b>it</b>) Selecionar bloco interno com tags &lt;&gt;
(<b>&gt;</b>) Deslocar texto para direita
(<b>&lt;</b>) Deslocar texto para esquerda
(<b>d</b>) Deletar texto marcado
(<b>~</b>) Alterar entre maiúscula e minúscula
(<b>u</b>) Alterar texto marcado para minúsculas
(<b>U</b>) Alterar texto marcado para maiúsculas

<u><b>Marcadores</b></u>:
(<b>:marks</b>) Listar marcadores
(<b>ma</b>) Atribuir posição atual no marcador A
(<b>`</b>) Pular para marcador
(<b>'</b>) Pular para início da linha do marcador
(<b>`a</b>) Pular para posição do marcador A
(<b>y`a</b>) Copiar texto para posição do marcador A
(<b>`0</b>) Ir para posição onde o Vim foi anteriormente encerrado
(<b>`"</b>) Ir para posição quando foi editado este arquivo pela última vez
(<b>`.</b>) Ir para posição da última alteração neste arquivo
(<b>``</b>) Ir para posição antes do último salto
(<b>:ju</b>) Listar saltos
(<b>ctrl+i</b>) Ir para posição mais recente na lista de saltos
(<b>ctrl+o</b>) Ir para posição mais antiga na lista de saltos
(<b>:changes</b>) Listar alterações
(<b>g,</b>) Ir para posição mais recente na lista de alterações
(<b>g;</b>) Ir para posição mais antiga na lista de alterações
(<b>ctrl+]</b>) Ir para tag sob o cursor

<u><b>Macros</b></u>:
(<b>qa</b>) Gravar macro A
(<b>q</b>) Parar gravação do macro
(<b>@a</b>) Executar macro
(<b>@@</b>) Re executar último macro

<u><b>Múltiplos arquivos</b></u> (via Ex mode):
<u>Buffers</u>:
vim arquivo1 arquivo2
(<b>:bn</b>) Ir para próximo arquivo
(<b>:bp</b>) Ir para arquivo anterior
(<b>:bf</b>) Ir para 1º arquivo
(<b>:bl</b>) Ir para último arquivo
(<b>:bd</b>) Deletar 1 buffer (fechar 1 arquivo)
(<b>:ls</b>) Listar arquivos abertos
<u>Windows</u>:
(<b>:sp nomeArquivo</b>) Abrir arquivo em janela horizontal dividida
(<b>:vsp nomeArquivo</b>) Abrir arquivo em janela vertical dividida
(<b>ctrl+w, h</b>) Ir para janela à esquerda
(<b>ctrl+w, j</b>) Ir para janela abaixo
(<b>ctrl+w, k</b>) Ir para janela acima
(<b>ctrl+w, l</b>) Ir para janela à direita
(<b>ctrl+w, w</b>) Alternar para próxima janela
(<b>ctrl+w, q</b>) Fechar janela
(<b>ctrl+w, x</b>) Trocar janela atual com a próxima
(<b>ctrl+w, =</b>) Tornar todas janelas de altura e largura iguais
(<b>ctrl+w, H</b>) Tornar janela atual com altura total à extrema esquerda (janela vertical mais à esquerda)
(<b>ctrl+w, L</b>) Tornar janela atual com altura total à extrema direita (janela vertical mais à direita)
(<b>ctrl+w, J</b>) Tornar janela atual com largura total na parte inferior (janela horizontal mais abaixo)
(<b>ctrl+w, K</b>) Tornar janela atual com largura total na parte superior (janela horizontal mais acima)
<u>Tabs</u>:
(<b>:tabnew nomeArquivo</b>) Abrir arquivo em nova guia
(<b>:tabn</b>) Ir para próxima guia
(<b>:tabp</b>) Ir para guia anterior
(<b>:tabc</b>) Fechar guia atual
(<b>:tabo</b>) Fechar todas guias, exceto atual
(<b>:tabdo</b>) Fechar todas guias
(<b>:tabfirst</b>) Ir para 1ª guia
(<b>:tablast</b>) Ir para última guia
(<b>:tabs</b>) Listar guias
</small></pre></code>
                    <h5>Modes:</h5>
                    <ul>
                        <li><b>Normal</b>: modo padrão do Vim (ao abrir arquivo), onde pode-se navegar pelo conteúdo interno do arquivo e utilizar comandos para edição, manipulação e movimentação do cursor. Compõe-se do modo command-line. Modo ativado através da tecla 'esc';</li>
                        <li><b>Insert</b>: modo de inserção, onde pode-se manipular o conteúdo interno do arquivo. Compõe-se do modo visual. Modo ativado, principalmente, através da tecla 'i';</li>
                        <li><b>Command-line</b>: modo de comandos, onde pode-se utilizar comandos de manipulação do arquivo e editor (habilitar novos modos). Compõe-se do modo visual. Modo ativado através da tecla ':', via normal/ex mode;</li>
                        <li><b>Visual</b>: modo visual, onde pode-se visualizar e selecionar conteúdo interno do arquivo. Compõe-se do modo select. Modo ativado através da tecla 'v';</li>
                        <li><b>Replace</b>: modo de substituição, onde pode-se substituir conteúdo interno do arquivo. Compõe-se do modo visual. Modo ativado através da tecla 'R';</li>
                        <li><b>Select</b>: modo de seleção, onde pode-se visualizar (visual mode) e selecionar conteúdo interno do arquivo. Compõe-se do modo view. Modo ativado, principalmente, através da tecla 'gh';</li>
                        <li><b>View</b>: modo de exibição, onde pode-se somente visualizar conteúdo interno do arquivo, somente leitura. Modo ativado nativamente ao abrir arquivo.</li>
                    </ul>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Compactação e empacotamento</h4>
                <div class="card-body">
                    <ul>
                        <li><b>Empacotamento</b>: Quando vários arquivos são empacotados em 1 só arquivo;
                            <ul>
                                <li>tar: tape arquive, empacotador de arquivos, preservando metadados dos arquivos, tornando-os com final '.tar'. Sintaxe: <span class="text-danger">tar &lt;parâmetros&gt; &lt;arquivo.tar&gt; &lt;arquivo1&gt; [arquivo2(s)]</span>
                                    <ul>
                                        <li>(<b>-f</b> ou <b>--file</b>): Parâmetro obrigatório. Indicar destino do arquivo.tar resultante;</li>
                                        <li>(<b>-c</b> ou <b>--create</b>): Empacotar arquivo;</li>
                                        <li>(<b>-t</b> ou <b>--list</b>): Exibir conteúdo interno do empacotado;</li>
                                        <li>(<b>-v</b> ou <b>--verbose</b>): Exibir detalhes do empacotamento/desempacotamento na tela;</li>
                                        <li>(<b>-j</b> ou <b>--bzip2</b>): Compactar arquivo, com bzip2, ao empacotá-lo (gerará 'arquivo.tar.bz2');</li>
                                        <li>(<b>-J</b> ou <b>--xz</b>): Compactar arquivo, com xz, ao empacotá-lo (gerará arquivo.tar.xz);</li>
                                        <li>(<b>-z</b> ou <b>--gzip</b>): Compactar, com gzip, ao empacotá-lo (gerará arquivo.tar.gz);</li>
                                        <li>(<b>-x</b> ou <b>--extract</b>): Desempacotar arquivo empacotado.</li>
                                    </ul>
<small><pre><code>
<b>Empacotar</b>: tar -cf arquivoFinal.tar arquivoEmpacotar
<b>Desempacotar</b>: tar -xf arquivoPronto.tar
</code></pre></small>
                                </li>
                                <li>zip: Empacotador de arquivos, tornando-os com final '.zip'. Sintaxe: <span class="text-danger">zip &lt;parâmetros&gt; &lt;arquivo[.zip]&gt; [arquivo2(s)]</span></li>
<small><pre><code>
<b>Empacotar</b>: zip arquivoFinal.zip arquivoEmpacotar
<b>Empacotar recursivamente</b>: zip -r arquivoFinal.zip diretorioEmpacotar
<b>Ver conteúdo de empacotado, sem extrair</b>: unzip -l arquivo.zip
<b>Desempacotar (extrair)</b>: unzip arquivo.zip
</code></pre></small>
                            </ul>
                        </li>
                        <li><b>Compactação</b>: Quando arquivo original é compactado em arquivo menor.
                            <ul>
                                <li>gzip: Compactador de arquivos, tornando-os com final '.gz'. Sintaxe: <span class="text-danger">gzip &lt;parâmetros&gt; &lt;arquivo.gz&gt; [arquivo2(s)]</span>
                                    <ul>
                                        <li>(<b>-c</b> ou <b>--stdout</b>): Compactar arquivo;</li>
                                        <li>(<b>-d</b> ou <b>--decompress</b>): Descompactar arquivo.gz;</li>
                                        <li>(<b>-f</b> ou <b>--force</b>): Forçar compactação/descompactação;</li>
                                        <li>(<b>-l</b> ou <b>--list</b>): Exibir informação do arquivo compactado;</li>
                                        <li>(<b>-q</b> ou <b>--quiet</b>): Sair;</li>
                                        <li>(<b>-r</b> ou <b>--recursive</b>): Compactar recursivamente;</li>
                                        <li>(<b>-t</b> ou <b>--test</b>): Testar integridade do arquivo compactado;</li>
                                        <li>(<b>-v</b> ou <b>--verbose</b>): Exibir progresso da operação;</li>
                                        <li>(<b>&lt;nivel&gt;</b> ou <b>--fast</b> ou <b>--best</b>): Gerenciar grau da operação. Nível(1 a 9), com menos detalhes ao mais detalhes. Fast equivale 1, best equivale 9.</li>
                                    </ul>
<small><pre><code>
<b>Ver arquivo compactado.gz</b>: zcat arquivo.gz (há também 'zgrep', 'zless', 'zmore')
<b>Compactar</b>: gzip arquivo
<b>Compactar, redirecionando saída</b>: gzip -c arquivo &gt; arquivoCompactado.gz
<b>Descompactar</b>: gzip -d arquivo.gz
<b>Empacotar/compactar (tar/gzip)</b>: tar -czf arquivo.tar.gz diretorioArquivosAlvo
<b>Descompactar/desempacotar (gzip/tar)</b>: tar -xzf arquivo.tar.gz
</code></pre></small>
                                </li>
                                <li>bzip2: Compactador de arquivos, tornando-os com final '.bz2'. Funcionamento similar ao gzip;</li>
<small><pre><code>
<b>Ver arquivo.bz2</b>: bzcat arquivo.bz2 (há também 'bzgrep', 'zless' e 'zmore')
<b>Compactar empacotado</b>: bzip2 dirEmpacotado.tar (gerará dirEmpacotado.tar.bz2)
<b>Descompactar</b>: bzip2 -d dirEmpacotado.tar.bz2
<b>Descompactar/desempacotar (bzip2/tar)</b>: tar -xjvf arquivo.tar.bz2
</code></pre></small>
                                <li>xz: Compactador de arquivos, tornando-os com final '.xz'. Funcionamento similar ao gzip;</li>
<small><pre><code>
<b>Compactar:</b> xz -c arquivo &gt; arquivoCompactado.xz
<b>Descompactar:</b> xz -d arquivoCompactado.xz
<b>Empacotar/compactar (tar/xz):</b> tar -cJf ./arquivo.tar.xz diretorioAlvo/
<b>Descompactar/desempacotar (xz/tar):</b> tar -xJf arquivo.tar.xz
</code></pre></small>
                                <li>gunzip: Descompactador, similar ao 'gzip -d' (Ex: 'gunzip arquivoCompactado.tar.gz');</li>
                                <li>bunzip2: Descompactador, similar ao 'bzip2 -d' (Ex: 'bunzip2 arquivoCompactado.tar.bz2');</li>
                                <li>unxz: Descompactador, similar ao 'xz -d' (Ex: 'unxz arquivoCompactado.tar.xz');</li>
                                <li>compress: Utilitário externo para compactar/descompactar arquivos. Arquivos compactados com o compress possuem final '.Z'.</li>
<small><pre><code>
<b>Instalar compress:</b> sudo apt(dnf) install ncompress
<b>Compactar:</b> compress -c aquivo &gt; arquivo.Z
<b>Descompactar:</b> uncompress arquivo.Z
</code></pre></small>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Pacotes</h4>
                <div class="card-body">
                    <p>Repositórios de pacotes, os PPAs (personal package archive) são servidores que hospedam pacotes, a fim de instalá-los e atualizá-los. Distros possuem repositórios de pacotes, havendo possibilidade de adição de repositórios (mirror) extras, no conteúdo do arquivo (Debian) '/etc/apt/sources.list' ou em arquivo.list em '/etc/apt/sources.list.d'. Pacotes <i>sandbox</i> funcionam isoladamente, sem intervenções ao sistema (similar ao conceito de container). Nativamente, GNU/Linux possui os tipos de pacotes:</p>
                    <ul>
                        <li><b>Fonte</b>: Contém código fonte do software, arquivos de configuração, documentação, scripts de controle, manuais e bibliotecas fonte. Pode ser compilado em qualquer distro;</li>
                        <li><b>Binário</b>: Contém código binário, pré-compilado, do software, arquivos de configuração, documentação, scripts de controle, manuais e bibliotecas. Cada distro possui seu formato de pacote binário.</li>
                    </ul>
                    <p>Gerenciador de pacotes de baixo nível tem função de somente organizar o mesmo internamente na distro (extração), conforme abaixo, não possuindo tratamento de dependências. Gerenciador de pacotes de alto nível tem função de baixar (via repositórios descritos) e organizar pacotes internamente na distro, tratando dependências e configurações extras, direcionando os arquivos da seguinte forma:</p>
                    <ul>
                        <li>Configuráveis -&gt; /etc</li>
                        <li>Binários -&gt; /usr/bin</li>
                        <li>Super binaries -&gt; /usr/sbin</li>
                        <li>Libraries -&gt; /usr/lib</li>
                        <li>Processos -&gt; /proc</li>
                    </ul>
                    <p>Sintaxe de repositório (Debian - arquivo.list): <span class="text-danger">&lt;tipoPacote&gt; &lt;protocoloAcesso:enderecoPacote&gt; &lt;versaoDistro&gt; &lt;classficacaoPacote&gt;</span><br>
                    Ex1: <span class="text-muted">deb http://ppa.launchpad.net/kdenlive/kdenlive-stable/ubuntu focal main</span><br>
                    Ex2: <span class="text-muted">deb cdrom:[Linux Mint 20.3 _Una_ - Release amd64 20220104]/ focal contrib main</span></p>
                    <ul>
                        <li>Tipo: deb (padrão) e deb-src (aponta ao código fonte);</li>
                        <li>Protocolo: HTTP e FTP;</li>
                        <li>Versão da distro: Codinome ou versão (stable, testing...);</li>
                        <li>Classificação do pacote:
                            <ul>
                                <li>main: Apenas pacotes free software;</li>
                                <li>contrib: Contém dependências de software proprietário;</li>
                                <li>nonfree: Código fonte fechado.</li>
                            </ul>
                        </li>
                    </ul>
                    <p>Existem gerenciadores de pacotes de alto nível externos, como <b>pip</b> (Python), <b>npm</b> (Node.js). Além disso, pacotes do tipo '<b>appimage</b>' funcionam em sandbox, podendo ser executados imediatamente, após baixados, com '<span class="text-muted">./pacote.appimage --install</span>', mediante permissão de execução. Além disso, pode-se instalar pacotes manualmente (pacotes <b>fonte/source</b>), fazendo download do arquivo empacotado compactado: Basta extraí-lo e, no diretório extraído, executar o arquivo './configure', após isso realizar o comando '<span class="text-muted">make</span>', seguido do comando '<span class="text-muted">make install</span>', seguido do '<span class="text-muted">make clean</span>'.</p>

                    <h5>Chaves (Keys):</h5>
                    <p>Chaves key <b>GPG</b> (GNU PGP - Pretty Good Privacy) permitem conexão segura entre host e repositório, ficam, publicamente, em '/usr/share/keyrings/'. Chaves <b>SSH</b> permitem conexão remota entre dispositivos e serviços.</p>
<small><pre><code>
<b>Listar chaves GPG</b>: gpg --list-keys (mesmo que '~/.gnupg')
<b>Gerar par de chaves GPG</b> (pública e privada): gpg --gen-key (gerará 'chave.asc' ou 'chave.gpg')
<b>Deletar chave GPG pública</b>: gpg --delete-keys numChave
<b>Deletar chave GPG privada</b>: gpg --delete-secret-keys numChave
<b>Editar chave GPG</b>: gpg --edit-key numChave
<b>Gerar chave SSH</b>: ssh-keygen (gerará 'chave.pub' em '~/.ssh')
</code></pre></small>

                    <h5>Pacotes empacotados compactados:</h5>
                    <ol>
                        <li>Baixar pacote em ~/Downloads: cd ~/Downloads && wget urlPacote -O nomePacote.extensao</li>
                        <li>Extrair para /opt:
                            <ul>
                                <li>.tar.gz: sudo tar -xzf nomePacote.tar.gz -C /opt</li>
                                <li>.tar.bz2: sudo tar -xjvf nomePacote.tar.bz2 -C /opt</li>
                                <li>.tar.xz: sudo tar -xJf nomePacote.tar.xz -C /opt</li>
                                <li>.zip: sudo unzip nomePacote.zip -d /opt/nomeDiretorioPacote</li>
                                <li>Ou renomear diretório, então movê-lo para /opt: sudo tar xvzf nomePacote.tar.gz && mv nomeAntigoPacote*/ novoNomePacote && sudo mv novoNomePacote /opt</li>
                            </ul>
                        </li>
                    </ol>
                    <ol>
                        <u>Arquivo bin</u>:
                        <li>Criar link simbólico do binário: sudo ln -s /opt/diretorioPacote/nomePacote /usr/bin/nomePacote</li>
                        <li>Criar lançador: sudo nano /usr/share/applications/nomePacote.desktop
<small><pre><code>
[Desktop Entry]
Encoding=UTF-8
Name=Pacote
Exec=/opt/diretorioPacote/nomePacote %U
Icon=/opt/diretorioPacote/iconPacote.png
Comment=Descrição do pacote
Terminal=false
StartupNotify=true
Type=Application
Categories=Development;
Keywords=termosChave;
</code></pre></small>
                        </li>
                    </ol>
                    <ol>
                        <u>Arquivo sh</u>:
                        <li>Torná-lo executável: sudo chmod +x /opt/nomeDiretorioPacote/nomePacote.sh</li>
                        <li>Criar lançador: sudo nano /usr/share/applications/nomePacote.desktop
<small><pre><code>
[Desktop Entry]
Encoding=UTF-8
Name=Pacote
Exec=sudo /opt/diretorioPacote/nomePacote.sh %f
Icon=/opt/diretorioPacote/iconPacote.png
Comment=Descrição do pacote
Terminal=false
StartupNotify=true
Type=Application
Categories=Development;
Keywords=termosChave;
</code></pre></small>
                        </li>
                    </ol>
                    
                    <h5>Debian (.deb):</h5>
                    <ul>
                        <li><b>dpkg</b> (Debian package): Gerenciador de pacotes (baixo nível);
<small><pre><code>
<b>Instalar pacote</b>: dpkg -i pacote.deb ('-v' para verbose)
<b>Remover pacote</b>: dpkg -r pacote
<b>Remover pacote e dependências</b> (purge): dpkg -p pacote
<b>Listar pacotes instalados</b>: dpkg -l
</code></pre></small>
                        </li>
                        <li><b>apt</b> (advanced package tool): Ou 'apt-get', gerenciador de pacotes (alto nível);
                            <ul>
                                Sintaxe: <span class="text-danger">apt [parâmetros] &lt;operação&gt; [pacote(s)]</span>
                                <li>(<b>-d</b>) download-only, realiza apenas download, não instala. Pacotes ficam em '/var/cache/apt/archives';</li>
                                <li>(<b>-f</b>) fix-broken, corrige erros gerados na operação;</li>
                                <li>(<b>-s</b>) simulate, simula operação, não realizando-a de fato;</li>
                                <li>(<b>-u</b>) show upgrade, lista pacotes que serão atualizados;</li>
                                <li>(<b>-y</b>) assume yes, assume confirmação de instalação diretamente;</li>
                                <li>(<b>--reinstall</b>) reinstala pacote já instalado.</li>
                            </ul>
<small><pre><code>
<u><b>Operações</b></u>:
<b>Instalar pacote</b>: apt install pacote (ou 'apt-get install pacote')
<b>Procurar pacote</b>: apt search termoBusca
<b>Informações sobre pacote</b>: apt info pacote
<b>Remover pacote</b>: apt remove pacote
<b>Remover pacote e dependências/arquivos</b>: apt purge pacote
<b>Remover libraries não utilizadas</b>: apt autoremove
<b>Reinstalar pacote</b>: apt reinstall pacote
<b>Exibir detalhes de pacote</b>: apt show pacote
<b>Listar pacotes disponíveis</b>: apt list ('--installed' para listar somente instalados)
<b>Atualizar lista de repositórios</b> (update): apt update
<b>Atualizar pacotes</b> (upgrade): apt upgrade
<b>Atualizar distro</b> (dist-upgrade): apt dist-upgrade
<b>Atualizar pacotes e distro</b>: apt full-upgrade
<b>Identificar e corrigir falhas</b>: apt-check
<b>Esvaziar repositório local</b>: apt-clean (Esvazia '/var/cache/apt/archives')
<b>Adicionar PPA</b>: add-apt-repository ppa:nomeRepositorio
<b>Remover PPA</b>: add-apt-repository -remove ppa:nomeRepositorio
</code></pre></small>
                        </li>
                        <li><b>aptitude</b>: Gerenciador de pacotes (alto nível) externo, necessário instalar;
<small><pre><code>
<b>Entrar</b>: aptitude
<b>Procurar pacotes</b>: aptitude search pacote
<b>Informações sobre pacote</b>: aptitude info pacote (ou 'aptitude show pacote')
<b>Instalar pacote</b>: aptitude install pacote
<b>Atualizar pacotes</b>: aptitude safe-upgrade
</code></pre></small>
                        </li>
                        <li><b>synaptic</b>: Gerenciador de pacotes (alto nível) GUI para manipulação de repositórios e gestão de pacotes (basicamente um front-end do 'apt').</li>
                    </ul>

                    <h5>RHEL (.rpm):</h5>
                    <ul>
                        <li><b>rpm</b> (Red Hat package manager): Gerenciador de pacotes (baixo nível);
<small><pre><code>
<b>Instalar pacote</b>: rpm -i pacote.rpm ('-v' para verbose)
<b>Atualizar pacote</b>: rpm -U pacote.rpm
<b>Remover pacote</b>: rpm -e pacote
<b>Listar pacotes instalados</b>: rpm -l
</code></pre></small>
                        </li>
                        <li><b>yum</b> (yellowdog updater modified): Gerenciador de pacotes (alto nível);</li>
                        <li><b>dnf</b> (dandified yum): Gerenciador de pacotes (alto nível) fork e evolução do yum. No RHEL, repositórios ficam em '/etc/yum.repos.d' (RHEL - arquivo.repo), cujos arquivos de repositórios possuem final '.repo';<br>
                            Sintaxe: <span class="text-danger">dnf [parâmetros] &lt;operação&gt; [pacote(s)]</span>
<small><pre><code>
<span class="text-muted">Os mesmos comandos dnf equivalem ao yum. Os parâmetros do apt são similares no dnf.</span>
<b>Instalar pacote</b>: dnf install pacote (ou 'dnf localinstall pacote' ou 'dnf localinstall pacote.rpm')
<b>Procurar pacote</b>: dnf search termoBusca
<b>Informações sobre pacote</b>: dnf info pacote
<b>Remover pacote</b>: dnf remove pacote (ou 'dnf erase pacote')
<b>Remover libraries não utilizadas</b>: dnf autoremove
<b>Reinstalar pacote</b>: dnf reinstall pacote
<b>Listar pacotes disponíveis</b>: dnf list ('list installed' para listar somente instalados)
<b>Atualizar lista de repositórios</b>: dnf check-update
<b>Atualizar pacotes</b>: dnf upgrade
<b>Atualizar distro</b> (dist-upgrade): dnf system-upgrade
<b>Atualizar pacotes e distro</b>: dnf distro-sync
<b>Identificar e corrigir falhas</b>: dnf check-update pacote
<b>Esvaziar repositório local</b>: dnf clean (Esvazia '/var/cache/dnf/{repo-name}/packages')
</code></pre></small>
                        </li>
                    </ul>
                    <h5>SUSE (.rpm):</h5>
                    <ul>
                        <li><b>ZYpp</b> (zypper): Gerenciador de pacotes (alto nível), similar ao yum;</li>
                    </ul>
                    <h5>Gentoo, Sabayon (ebuild):</h5>
                    <ul>
                        <li><b>portage</b>: Gerenciador de pacotes binários (Gentoo);</li>
                        <li><b>entropy</b> (equo): Gerenciador de binários compilados em portage (Sabayon).</li>
                    </ul>
                    <h5>Arch (.pkg.tar.xz):</h5>
                    <ul>
                        <li><b>pacman</b>: Gerenciador de pacotes (alto nível);</li>
                        <li><b>pamac</b>: Gerenciador de pacotes (alto nível), distro Manjaro, englobando repositórios oficiais, AUR, opcionalmente snap e flatpak.</li>
                    </ul>
                    <h5>Pacotes sandbox:</h5>
                    <ul>
                        <li><b>snap</b>: Gerenciador (proprietário) de pacotes sandbox. Binários ficam em '/snap/bin'. Snapstore é sua versão GUI;
<small><pre><code>
<b>Instalar pacote</b>: snap install pacote
<b>Instalar pacote</b> (outro canal): snap install --channel=edge pacote (Ou simplesmente '--edge'. Canais: stable, edge, latest, beta, candidate, classic...)
<b>Procurar pacote</b>: snap find pacote (ou "expressão de busca")
<b>Informações sobre pacote</b>: snap info pacote
<b>Listar pacotes disponíveis</b>: snap list ('--installed' para listar somente instalados)
<b>Remover pacote</b>: snap remove pacote
<b>Atualizar pacote</b>: snap refresh pacote (canal também permitido)
</code></pre></small>
                        </li>
                        <li><b>flatpak</b>: Gerenciador (free) de pacotes sandbox. Binários ficam globalmente em '/var/lib/flatpak' ou localmente em '/home/usuario/.local/share/flatpak. Flathub é sua versão GUI.
<small><pre><code>
<b>Instalar pacote</b>: flatpak install pacote
<b>Procurar pacote</b>: flatpak search pacote (ou "expressão de busca")
<b>Informações sobre pacote</b>: flatpak info pacote
<b>Listar pacotes disponíveis</b>: flatpak list ('--app' para listar somente instalados)
<b>Remover pacote</b>: flatpak uninstall pacote (ou 'repair' para reparar pacote)
<b>Atualizar pacote</b>: flatpak update pacote
</code></pre></small>
                        </li>
                    </ul>
                </div>
            </div>

            <div class="card mb-4">
                <h4 class="card-header">Certificação</h4>
                <div class="card-body">
                    <p id="textoPost">Provas de certificações profissionais globais, sobre Linux e free software.</p>
                    <h5>Principais órgãos certificadores:</h5>
                    <u>LPI (Linux Professional Institute)</u>:
                    <ol>
                        <li>LPI Linux Essentials: certificação de introdução, validade vitalícia, prova em pt-br composta de 40 questões de múltipla escolha, com 60 minutos de duração. Presencial e EAD. Esse resumo possui todo conteúdo abordado nessa certificação;</li>
                        <li>LPIC-1 Linux Administrator;</li>
                        <li>LPIC-2 Linux Engineer;</li>
                        <li>LPIC-3 Linux Enterprise, subdividida:
                            <ul>
                                <li>300: Mixed Environment;</li>
                                <li>303: Security;</li>
                                <li>304: Virtualization and High Availability.</li>
                            </ul>
                        </li>
                    </ol>
                    <u>CompTIA (Computing Technology Industry Association)</u>:
                    <ol>
                        <li>Linux+.</li>
                    </ol>
                    <u>Red Hat</u>:
                    <ol>
                        <li>RHCSA: Red Hat Certified System Administrator;</li>
                        <li>RHCE: Red Hat Certified Engineer;</li>
                        <li>RHCA: Red Hat Certified Architect.</li>
                    </ol>
                    <u>SUSE</u> (programa de certificações):
                    <ol>
                        <li>SCA: Suse Certified Administrator;</li>
                        <li>SCE: Suse Certified Engineer;</li>
                        <li>SEA: Suse Enterprise Architect.</li>
                        Níveis 1 e 2 (SCA e SCE) podem ser obtidos via certificações:
                        <ul>
                            <li>Enterprise Linux</li>
                            <li>OpenStack Cloud</li>
                            <li>Enterprise Storage</li>
                            <li>Systems Management</li>
                        </ul>
                    </ol>
                </div>
            </div>

        </div>
    </div>


<!--Rodapé-->
<div class="row">
    <div class="col-sm-12 text-center bg-black text-light pt-4 pb-3">
        <p>Elaborado por Mateus Schwede<br><small class="text-muted">ubsocial.github.io<br>LPI000573399</small></p>
    </div>
</div>

</div>
</body>
</html>